\chapter{Model and Analysis}
First, we specify some sorts with which we can then define the global type.
Afterwards, we define the processes for the proposer and the acceptor.
Finally, we will study an example run of the model.

\subsection{Sorts}
\newcommand{\Maybe}[1]{\operatorname{Maybe}\; #1}
\newcommand{\Just}[1]{\operatorname{Just}\; #1}
\newcommand{\Nothing}[0]{\operatorname{Nothing}}
\newcommand{\Or}[0]{\; | \;}
\newcommand{\Promise}[1]{\operatorname{Promise}\; #1}
\newcommand{\Proposal}[1]{\operatorname{Proposal}\; #1}
\newcommand{\ProposalC}[2]{\operatorname{Proposal}\; #1\; #2}
\newcommand{\Nack}[1]{\operatorname{Nack}\; #1}
\newcommand{\Value}[0]{\operatorname{Value}}

\newcommand{\Sort}[1]{\left\{#1\right\}}
\newcommand{\Paren}[1]{\left(#1\right)}

We assume the following sorts.

$\Maybe{a} = \Sort{\Just{a}, \Nothing}$

$\Value =$ Set of values.

$\Promise{a} = \Sort{\Promise{\Paren{\Maybe{\Paren{\Proposal{a}}}}}, \Nack{\mathbb{N}}}$

$\Proposal{a} = \Sort{\ProposalC{\mathbb{N}}{a}}$

\subsection{Global Type}
\newcommand{\DotForall}[1]{\bigodot_{#1}\;}
\newcommand{\SendUnreliableG}[4]{#1 \to_u #2 : #3 \left\langle #4 \right\rangle}
\newcommand{\SendWeaklyG}[3]{#1 \to_w #2 : #3}

\newcommand{\Accept}[0]{\mathnormal{Accept}}
\newcommand{\Restart}[0]{\mathnormal{Restart}}
\newcommand{\Abort}[0]{\mathnormal{Abort}}

\newcommand{\Mu}[1]{\left(\mu #1\right)}

Since each proposer initiates its own session the global type can be defined for one proposer.
A quorum of acceptors $A_Q$ is assumed.

The last phase of Paxos contains no inter-process communication, so it is not modeled in the global type.

$G_{p, A_Q} = \Mu{X} \DotForall{a \in A_Q} \SendUnreliableG{p}{a}{l1a}{\mathbb{N}} . \DotForall{a \in A_Q} \SendUnreliableG{a}{p}{l1b}{\Promise{\Value}} .\\
\hspace*{0.5em}\SendWeaklyG{p}{A_Q}{\Accept.\Paren{\DotForall{a \in A_Q} \SendUnreliableG{p}{a}{l2a}{\Proposal{\Value}}}.end\\
\hspace*{1em}\oplus \Restart.X\\
\hspace*{1em}\oplus \Abort.end}$

We can distinguish the individual phases of the Paxos algorithm by the labels $l1a$, $l1b$, and $l2a$.

In the first two steps, $1a$ and $1b$, the proposer sends its proposal number to each acceptor in $A_Q$ and listens for their responses.
In step 2a the proposer decides whether to send an $\Accept$ or $\Restart$ message to restart the algorithm.
This decision is broadcast to all acceptors in $A_Q$.
Should the proposer crash the algorithm ends for this particular proposer and quorum of acceptors.

\subsection{Functions and Sets}
\newcommand{\Bool}[0]{\operatorname{Bool}}
\newcommand{\prNumber}[2]{\operatorname{prNumber}\left( #1, #2 \right)}
\newcommand{\promValue}[1]{\operatorname{promValue}\left(#1\right)}
\newcommand{\anyNack}[1]{\operatorname{anyNack}\left(#1\right)}
\newcommand{\promCount}[1]{\operatorname{promCount}\left(#1\right)}
\newcommand{\greaterThan}[2]{\operatorname{gt}\left(#1, #2\right)}
\newcommand{\greaterEqual}[2]{\operatorname{ge}\left(#1, #2\right)}
\newcommand{\nFromPr}[1]{\operatorname{nFromPr}\left(#1 \right)}
\newcommand{\genAq}[3]{\operatorname{genA_Q}\left(#1, #2, #3\right)}

$\Bool = \{ true, false \}$

$\operatorname{prNumber} : \mathbb{N} \times \mathbb{N} \to \mathbb{N}$ returns a proposal number when given two natural numbers.

$\operatorname{promValue} : [\Promise{a}] \to a$ if none of the promises in the given list contain a value a new value is returned.
A promise contains a value if it is of the form $\Promise{(\Just{v})}$.
$v$ is the value.

$\operatorname{anyNack} : [\Promise{a}] \to \Bool\\
\anyNack{[]} = false\\
\anyNack{\Paren{\Nack{\_}: \_}} = true\\
\anyNack{\Paren{\_:xs}} = \anyNack{xs}$

$\operatorname{promCount} : [\Promise{a}] \to \mathbb{N}\\
\promCount{[]} = 0\\
\promCount{\Paren{\Promise{\_}:xs}} = 1 + \promCount{xs}\\
\promCount{\Paren{\_:xs}} = \promCount{xs}$

$\operatorname{gt}: a \to \Maybe{a} \to \Bool\\
\greaterThan{\_}{\Nothing} = true\\
\greaterThan{a}{\Just{b}} = a > b$

$\operatorname{ge}: a \to \Maybe{a} \to \Bool\\
\greaterEqual{\_}{\Nothing} = true\\
\greaterEqual{a}{\Just{b}} = a \ge b$

$\operatorname{nFromPr} : \Proposal{a} \to \mathbb{N}\\
\nFromPr{\ProposalC{n}{\_}} = n$

$\genAq{i}{ac}{pc}$ returns a set $A_Q$ with $A_Q \subseteq A = \{1, \dots, ac\}$ and $|A_Q| > \frac{|A|}{2}$.

\subsection{Processes}
\newcommand{\Sys}[2]{\operatorname{Sys}\left(#1, #2\right)}
\newcommand{\Pa}[0]{\operatorname{P^a}}
\newcommand{\Pp}[0]{\operatorname{P^p}}
\newcommand{\PaCont}[0]{\operatorname{P^a_{cont}}}

\newcommand{\PpInit}[4]{\operatorname{P^p_{init}}\left(#1, #2, #3, #4\right)}
\newcommand{\PaInit}[6]{\operatorname{P^a_{init}}\left(#1, #2, #3, #4, #5, #6\right)}

\subsubsection{System Initialization}
\newcommand{\SessionRequest}[3]{\overline{#1}\left[#2\right]\left(#3\right)}
\newcommand{\SessionAccept}[3]{#1\left[#2\right]\left(#3\right)}
\newcommand{\ParallelFor}[1]{\Pi_{#1}\;}

% Idea: One shared-point per Proposer over which the session is initialized.
$\Sys{ac}{pc} = \SessionRequest{a}{2}{t} . \PpInit{ac + 1}{\genAq{ac + pc}{ac}{pc}}{ac + pc}{[]}\\
\Or \SessionAccept{a}{1}{t} . \ParallelFor{ac < i < ac + pc} \PpInit{ac + 1}{\genAq{i}{ac}{pc}}{i}{[]} \\
\Or \ParallelFor{1 \le j \le ac} \PaInit{j}{ac + 1}{ac}{pc}{n_j}{pr_j}$

$\PpInit{i}{A_Q}{n}{\overrightarrow{V}} = \SessionRequest{b_n}{i}{s} . \Pp$

$\PaInit{j}{i}{ac}{pc}{n}{pr} = \ParallelFor{ac < k \le ac + pc} \SessionAccept{b_k}{j}{s} . \Pa$

$\Sys{ac}{pc}$, $\PpInit{i}{A_Q}{n}{\overrightarrow{V}}$, and $\PaInit{j}{i}{ac}{pc}{n}{pr}$ describe the system initialization.
$ac$ and $pc$ are the number of acceptors and proposers respectively.

An outer session is created through shared-point $a$.
This outer session is not strictly necessary but was left in to allow for easier extension of the model.
The acceptors are initialized using indices from 1 to $ac$ and the proposers are initialized using indices from $ac + 1$ to $ac + pc$.

$\PpInit{i}{A_Q}{n}{\overrightarrow{V}}$ is initialized with the proposer's role in its own session $i$, which is always $ac + 1$, a quorum of acceptors $A_Q$, an index $n$, and a vector $\overrightarrow{V}$.
Each proposer has the same role $i = ac + 1$ but uses a different shared-point $b_n$ according to its index $n$.
$\overrightarrow{V}$ is used in the proposer to collect and evaluate the responses from the acceptors.
It is always initialized with an empty list $[]$.
Shared-point $b_n$ is used to initiate a session.
Afterwards, the process behaves like $\Pp$.

$\PaInit{j}{i}{ac}{pc}{n}{pr}$ is initialized with the acceptor's index $j$, the proposer index $i$, which is always $ac + 1$, $ac$, $pc$, initial knowledge for the highest promised proposal number $n$, if available, and initial knowledge for the most recently accepted proposal $pr$, if available.
$n$ is of type $\Maybe{\mathbb{N}}$ and $pr$ is of type $\Maybe{\Paren{\Proposal{\Value}}}$ thus both can be $\Nothing$.
Each of the proposers' session requests are accepted in a separate subprocess.
These subprocesses run parallel to each other but still access the same values for $n$ and $pr$.
Afterwards, each subprocess behaves like $\Pa$.

\subsubsection{Proposer}
\newcommand{\SendUnreliableP}[5]{#1\left[#2, #3\right]!_u #4 \left\langle #5 \right\rangle}
\newcommand{\ReceiveUnreliableP}[6]{#1\left[#2, #3\right]?_u #4 \left\langle #5 \right\rangle \left(#6\right)}
\newcommand{\ceil}[1]{\Big\lceil #1 \Big\rceil}
\newcommand{\SendWeaklyP}[5]{#1\left[#2, #3\right]!_w #4.#5}
\newcommand{\ReceiveWeaklyP}[4]{#1\left[#2, #3\right]?_w #4}
\newcommand{\If}[1]{\operatorname{if}\; #1}
\newcommand{\Then}[1]{\operatorname{then}\; #1}
\newcommand{\Else}[1]{\operatorname{else}\; #1}
\newcommand{\update}[2]{\operatorname{update} \left(#1, #2\right)}

$\Pp = \Mu{X} \update{n}{n + 1} . \left(\DotForall{j \in A_Q} \SendUnreliableP{s}{i}{j}{l1a}{\prNumber{n}{i}}\right) .\\
\hspace*{0.5em}\left(\DotForall{j \in A_Q} \ReceiveUnreliableP{s}{j}{i}{l1b}{\perp}{v_j}\right) .\\
\hspace*{0.5em}\If{\anyNack{\overrightarrow{V}} \text{ or } \promCount{\overrightarrow{V}} < \ceil{\frac{|A_Q|}{2}}}\\
\hspace*{1em}\Then{\SendWeaklyP{s}{i}{A_Q}{\Restart}{X}}\\
\hspace*{1em}\Else{\\\hspace*{1.5em}\SendWeaklyP{s}{i}{A_Q}{\Accept}{\DotForall{j \in A_Q} \SendUnreliableP{s}{i}{j}{l2a}{\ProposalC{\prNumber{n}{i}}{\promValue{\overrightarrow{V}}}}.\\\hspace*{1.5em}end}}$

\subsubsection{Acceptor}
$\Pa = \Mu{X} \ReceiveUnreliableP{s}{i}{j}{l1a}{\perp}{n'} .\\
\hspace*{0.5em}\If{n' = \perp}\\
\hspace*{1em}\Then{\PaCont}\\
\hspace*{1em}\Else{\\
\hspace*{1.5em}\If{\greaterThan{n'}{n}}\\
\hspace*{1.5em}\Then{\update{n}{n'}.\SendUnreliableP{s}{j}{i}{l1b}{\Promise{pr}}.\PaCont}\\
\hspace*{1.5em}\Else{\SendUnreliableP{s}{j}{i}{l1b}{\Nack{n}}.\PaCont}}$

$\PaCont = \ReceiveWeaklyP{s}{i}{j}{\Accept . \ReceiveUnreliableP{s}{i}{j}{l2a}{\perp}{pr'} .\\
\hspace*{1em}\If{pr' = \perp}\\
\hspace*{1.5em}\Then{X}\\
\hspace*{1.5em}\Else{\\
\hspace*{2em}\If{\greaterEqual{\nFromPr{pr'}}{n}}\\
\hspace*{2.5em}\Then{\update{pr}{pr'} . \update{n}{\Just{\nFromPr{pr'}}}.X}\\
\hspace*{2.5em}\Else{X}}\\
\hspace*{0.5em} \oplus \Restart.X\\
\hspace*{0.5em} \oplus \Abort.end}$

\section{Example}
\newcommand{\Nu}[1]{\left(\nu #1\right)}

$ac = 3\; pc = 2$

$\Sys{3}{2} =
\SessionAccept{a}{1}{t}.\ParallelFor{3 < i < 5} \PpInit{4}{\genAq{i}{3}{2}}{i}{[]}\\
\Or \SessionRequest{a}{2}{t}.\PpInit{4}{\genAq{5}{3}{2}}{5}{[]}\\
\Or \ParallelFor{1 \le j \le 3} \PaInit{j}{4}{3}{2}{n_j}{pr_j}\\
\longmapsto (\operatorname{Init})\\
\Nu{t}\big (
\PpInit{4}{A_{Q,1}}{4}{[]} \Or \PpInit{4}{A_{Q,2}}{5}{[]}\\
\Or \PaInit{1}{4}{3}{2}{n_1}{pr_1} \Or \PaInit{2}{4}{3}{2}{n_2}{pr_2} \Or \PaInit{3}{4}{3}{2}{n_3}{pr_3}
\big )$
