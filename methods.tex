\chapter{Model and Analysis}

\section{Technical Preliminaries}
First, we define the sorts, some additional notation, and use them to define the global type.
Afterwards we define some sets and functions to create the processes.

\subsection{Sorts}
The sorts utilize type variables, which represent mathematical variables that range over types.

\newcommand{\Maybe}[1]{\operatorname{Maybe}\; #1}
\newcommand{\Just}[1]{\operatorname{Just}\; #1}
\newcommand{\Nothing}[0]{\operatorname{Nothing}}
\newcommand{\Or}[0]{\; | \;}
\newcommand{\Promise}[1]{\operatorname{Promise}\; #1}
\newcommand{\Proposal}[1]{\operatorname{Proposal}\; #1}
\newcommand{\ProposalC}[2]{\operatorname{Proposal}\; #1\; #2}
\newcommand{\Nack}[1]{\operatorname{Nack}\; #1}
\newcommand{\Value}[0]{\operatorname{Value}}

$\Maybe{a} = \Just{a} \Or \Nothing$

$\Value =$ Set of values.

$\Promise{a} = \Promise{\left(\Maybe{\left(\Proposal{a}\right)}\right)} \Or \Nack{\mathbb{N}}$

$\Proposal{a} = \ProposalC{\mathbb{N}}{a}$

\subsection{Notation}
TODO im Grunde einfach von Peters et al klauen.

\subsection{Global Type}
\newcommand{\DotForall}[1]{\bigodot_{#1}\;}
\newcommand{\SendUnreliableG}[4]{#1 \to_u #2 : #3 \left\langle #4 \right\rangle}
\newcommand{\SendWeaklyG}[3]{#1 \to_w #2 : #3}

\newcommand{\Accept}[0]{\mathnormal{Accept}}
\newcommand{\Restart}[0]{\mathnormal{Restart}}
\newcommand{\Abort}[0]{\mathnormal{Abort}}

\newcommand{\Mu}[1]{\left(\mu #1\right)}

\newcommand{\Paren}[1]{\left(#1\right)}

Since each proposer has its own session the global type can be defined for one proposer.
A quorum of acceptors $A_Q$ is assumed.

The last phase of Paxos contains no inter-process communication, so it is not modeled in the global type.

$G_{p, A_Q} = \Mu{X} \DotForall{a \in A_Q} \SendUnreliableG{p}{a}{l1a}{\mathbb{N}} . \DotForall{a \in A_Q} \SendUnreliableG{a}{p}{l1b}{\Promise{\Value}} .\\
\hspace*{0.5em}\SendWeaklyG{p}{A_Q}{\Accept.\Paren{\DotForall{a \in A_Q} \SendUnreliableG{p}{a}{l2a}{\Proposal{\Value}}}.end\\
\hspace*{1em}\oplus \Restart.X\\
\hspace*{1em}\oplus \Abort.end}$

We can distinguish the individual steps of the Paxos algorithm by the labels $l1a$, $l1b$, and $l2a$.

In the first two steps the proposer sends its proposal number to each acceptor in $A_Q$ and then listens for their responses.
In step 2a the proposer decides whether to send an accept message or restart the algorithm.
This decision is broadcast to all acceptors in $A_Q$.

\subsection{Functions and Sets}
\newcommand{\Bool}[0]{\operatorname{Bool}}
\newcommand{\prNumber}[2]{\operatorname{prNumber}\left( #1, #2 \right)}
\newcommand{\promValue}[1]{\operatorname{promValue}\left(#1\right)}
\newcommand{\anyNack}[1]{\operatorname{anyNack}\left(#1\right)}
\newcommand{\promCount}[1]{\operatorname{promCount}\left(#1\right)}
\newcommand{\greaterThan}[2]{\operatorname{gt}\left(#1, #2\right)}
\newcommand{\greaterEqual}[2]{\operatorname{ge}\left(#1, #2\right)}
\newcommand{\nFromPr}[1]{\operatorname{nFromPr}\left(#1 \right)}
\newcommand{\genAq}[3]{\operatorname{genA_Q}\left(#1, #2, #3\right)}

$\Bool = \{ true, false \}$

$\operatorname{prNumber} : \mathbb{N} \times \mathbb{N} \to \mathbb{N}$ returns a proposal number when given two natural numbers.

$\operatorname{promValue} : [\Promise{a}] \to a$ if none of the promises in the given list contain a value a new value is returned.
A promise contains a value if it is of the form $\Promise{(\Just{v})}$.
$v$ is the value.

$\operatorname{anyNack} : [\Promise{a}] \to \Bool\\
\anyNack{[]} = false\\
\anyNack{\Paren{\Nack{\_}: \_}} = true\\
\anyNack{\Paren{\_:xs}} = \anyNack{xs}$

$\operatorname{promCount} : [\Promise{a}] \to \mathbb{N}\\
\promCount{[]} = 0\\
\promCount{\Paren{\Promise{\_}:xs}} = 1 + \promCount{xs}\\
\promCount{\Paren{\_:xs}} = \promCount{xs}$

$\operatorname{gt}: a \to \Maybe{a} \to \Bool\\
\greaterThan{\_}{\Nothing} = true\\
\greaterThan{a}{\Just{b}} = a > b$

$\operatorname{ge}: a \to \Maybe{a} \to \Bool\\
\greaterEqual{\_}{\Nothing} = true\\
\greaterEqual{a}{\Just{b}} = a \ge b$

$\operatorname{nFromPr} : \Proposal{a} \to \mathbb{N}\\
\nFromPr{\ProposalC{n}{\_}} = n$

$\genAq{i}{ac}{pc}$ returns a set $A_Q$ with $A_Q \subseteq A = \{pc + 1, \dots, pc + ac\}$ and $|A_Q| > \frac{|A|}{2}$.

\subsection{Processes}
\newcommand{\Sys}[3]{\operatorname{Sys}\left(#1, #2, #3\right)}
\newcommand{\Pa}[0]{\operatorname{P^a}}
\newcommand{\Pp}[0]{\operatorname{P^p}}
\newcommand{\PaCont}[0]{\operatorname{P^a_{cont}}}

\newcommand{\PpInit}[4]{\operatorname{P^p_{init}}\left(#1, #2, #3, #4\right)}
\newcommand{\PaInit}[4]{\operatorname{P^a_{init}}\left(#1, #2, #3, #4\right)}

\subsubsection{System Initialization}
\newcommand{\SessionRequest}[3]{\overline{#1}\left[#2\right]\left(#3\right)}
\newcommand{\SessionAccept}[3]{#1\left[#2\right]\left(#3\right)}
\newcommand{\ParallelFor}[1]{\Pi_{#1}\;}

% Idea: One shared-point per Proposer over which the session is initialized.
$\Sys{pc}{ac}{\overrightarrow{V}} = \SessionRequest{a}{1}{t} . \PpInit{1}{\genAq{1}{ac}{pc}}{1}{[]}\\
\Or \SessionAccept{a}{1}{t} . \ParallelFor{2 \le i \le pc} \PpInit{i}{\genAq{i}{pc}{ac}}{i}{[]} \\
\Or \ParallelFor{pc < j \le pc + ac} \PaInit{j}{pc}{\overrightarrow{V}_{j,n}}{\overrightarrow{V}_{j,pr}}$

$\PpInit{i}{A_Q}{n}{\overrightarrow{V}} = \SessionRequest{b_i}{a_1, \dots, a_{|A_Q|}}{s} . \Pp$

$\PaInit{j}{pc}{n}{pr} = \ParallelFor{1 \le i \le pc} \SessionAccept{b_i}{j}{s} . \Pa$

\subsubsection{Proposer}
\newcommand{\SendUnreliableP}[5]{#1\left[#2, #3\right]!_u #4 \left\langle #5 \right\rangle}
\newcommand{\ReceiveUnreliableP}[6]{#1\left[#2, #3\right]?_u #4 \left\langle #5 \right\rangle \left(#6\right)}
\newcommand{\ceil}[1]{\Big\lceil #1 \Big\rceil}
\newcommand{\SendWeaklyP}[5]{#1\left[#2, #3\right]!_w #4.#5}
\newcommand{\ReceiveWeaklyP}[4]{#1\left[#2, #3\right]?_w #4}
\newcommand{\If}[1]{\operatorname{if}\; #1}
\newcommand{\Then}[1]{\operatorname{then}\; #1}
\newcommand{\Else}[1]{\operatorname{else}\; #1}
\newcommand{\update}[2]{\operatorname{update} \left(#1, #2\right)}

$\Pp = \Mu{X} \left(\DotForall{j \in A_Q} \SendUnreliableP{s}{i}{j}{l1a}{\prNumber{n}{i}}\right) .\\
\hspace*{0.5em}\left(\DotForall{j \in A_Q} \ReceiveUnreliableP{s}{j}{i}{l1b}{\perp}{v_j}\right) .\\
\hspace*{0.5em}\If{\anyNack{\overrightarrow{V}} \text{ or } \promCount{\overrightarrow{V}} < \ceil{\frac{|A_Q|}{2}}}\\
\hspace*{1em}\Then{\SendWeaklyP{s}{i}{A_Q}{restart}{\update{n}{n + 1} . X}}\\
\hspace*{1em}\Else{\\\hspace*{1.5em}\SendWeaklyP{s}{i}{A_Q}{accept}{\DotForall{j \in A_Q} \SendUnreliableP{s}{i}{j}{l2a}{\ProposalC{\prNumber{n}{i}}{\promValue{\overrightarrow{V}}}}.\\\hspace*{1.5em}end}}$

\subsubsection{Acceptor}
$\Pa = \Mu{X} \ReceiveUnreliableP{s}{i}{j}{l1a}{\perp}{n'} .\\
\hspace*{0.5em}\If{n' = \perp}\\
\hspace*{1em}\Then{\PaCont}\\
\hspace*{1em}\Else{\\
\hspace*{1.5em}\If{\greaterThan{n'}{n}}\\
\hspace*{1.5em}\Then{\update{n}{n'}.\SendUnreliableP{s}{j}{i}{l1b}{\Promise{pr}}.\PaCont}\\
\hspace*{1.5em}\Else{\SendUnreliableP{s}{j}{i}{l1b}{\Nack{n}}.\PaCont}}$

$\PaCont = \ReceiveWeaklyP{s}{i}{j}{\Accept . \ReceiveUnreliableP{s}{i}{j}{l2a}{\perp}{pr'} .\\
\hspace*{1em}\If{pr' = \perp}\\
\hspace*{1.5em}\Then{X}\\
\hspace*{1.5em}\Else{\\
\hspace*{2em}\If{\greaterEqual{\nFromPr{pr'}}{n}}\\
\hspace*{2.5em}\Then{\update{pr}{pr'} . \update{n}{\nFromPr{pr'}}.X}\\
\hspace*{2.5em}\Else{X}}\\
\hspace*{0.5em} \oplus \Restart.X\\
\hspace*{0.5em} \oplus \Abort.end}$
