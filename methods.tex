\chapter{Model and Analysis}
First, we specify some sorts with which we can then define the global type.
Afterwards, we define the processes for the proposer and the acceptor.
Finally, we will study an example run of the model.

\section{Sorts}
\newcommand{\Bool}[0]{\operatorname{Bool}}
\newcommand{\True}[0]{\operatorname{true}}
\newcommand{\False}[0]{\operatorname{false}}
\newcommand{\Maybe}[1]{\operatorname{Maybe}\; #1}
\newcommand{\Just}[1]{\operatorname{Just}\; #1}
\newcommand{\Nothing}[0]{\operatorname{Nothing}}
\newcommand{\Or}[0]{\; | \;}
\newcommand{\Promise}[1]{\operatorname{Promise}\; #1}
\newcommand{\Proposal}[1]{\operatorname{Proposal}\; #1}
\newcommand{\ProposalC}[2]{\operatorname{Proposal}\; #1\; #2}
\newcommand{\Nack}[1]{\operatorname{Nack}\; #1}
\newcommand{\Value}[0]{\operatorname{Value}}

\newcommand{\Curly}[1]{\left\{#1\right\}}
\newcommand{\Paren}[1]{\left(#1\right)}

We assume the following sorts.

$\Maybe{a} = \Curly{\Just{a}, \Nothing}$

$\Bool = \Curly{\True, \False}$

$\Value =$ Set of values.

$\Promise{a} = \Curly{\Promise{\Paren{\Maybe{\Paren{\Proposal{a}}}}}, \Nack{\mathbb{N}}}$

$\Proposal{a} = \Curly{\ProposalC{\mathbb{N}}{a}}$

\section{Global Type}
\newcommand{\DotForall}[1]{\bigodot_{#1}\;}
\newcommand{\SendUnreliableG}[4]{#1 \to_u #2 : #3 \left\langle #4 \right\rangle}
\newcommand{\SendWeaklyG}[3]{#1 \to_w #2 : #3}

\newcommand{\Accept}[0]{\mathnormal{Accept}}
\newcommand{\Restart}[0]{\mathnormal{Restart}}
\newcommand{\Abort}[0]{\mathnormal{Abort}}

\newcommand{\Mu}[1]{\left(\mu #1\right)}

Since each proposer initiates its own session the global type can be defined for one proposer.
A quorum of acceptors $A_Q$ is assumed.

The last phase of Paxos contains no inter-process communication, so it is not modeled in the global type.

$G_{p, A_Q} = \Mu{X} \DotForall{a \in A_Q} \SendUnreliableG{p}{a}{l1a}{\mathbb{N}} . \DotForall{a \in A_Q} \SendUnreliableG{a}{p}{l1b}{\Promise{\Value}} .\\
\hspace*{0.5em}\SendWeaklyG{p}{A_Q}{\Accept.\Paren{\DotForall{a \in A_Q} \SendUnreliableG{p}{a}{l2a}{\Proposal{\Value}}}.end\\
\hspace*{1em}\oplus \Restart.X\\
\hspace*{1em}\oplus \Abort.end}$

We can distinguish the individual phases of the Paxos algorithm by the labels $l1a$, $l1b$, and $l2a$.

In the first two steps, $1a$ and $1b$, the proposer sends its proposal number to each acceptor in $A_Q$ and listens for their responses.
In step 2a the proposer decides whether to send an $\Accept$ or $\Restart$ message to restart the algorithm.
This decision is broadcast to all acceptors in $A_Q$.
Should the proposer crash the algorithm ends for this particular proposer and quorum of acceptors.

\section{Functions}
We define some functions which we use in the next section to define the processes.

\newcommand{\prNumber}[2]{\operatorname{proposalNumber}\left( #1, #2 \right)}
\newcommand{\promValue}[1]{\operatorname{promiseValue}\left(#1\right)}
\newcommand{\anyNack}[1]{\operatorname{anyNack}\left(#1\right)}
\newcommand{\promiseCount}[1]{\operatorname{promiseCount}\left(#1\right)}
\newcommand{\greaterThan}[2]{\operatorname{gt}\left(#1, #2\right)}
\newcommand{\greaterEqual}[2]{\operatorname{ge}\left(#1, #2\right)}
\newcommand{\nFromProposal}[1]{\operatorname{nFromProposal}\left(#1 \right)}
\newcommand{\genAq}[3]{\operatorname{genA_Q}\left(#1, #2, #3\right)}
\newcommand{\update}[2]{\operatorname{update} \left(#1, #2\right)}

$\operatorname{proposalNumber} : \mathbb{N} \times \mathbb{N} \to \mathbb{N}$

$\prNumber{a}{b}$ returns a proposal number when given two natural numbers.

$\operatorname{promiseValue} : [\Promise{a}] \to a$

$\promValue{ps}$ returns a new value if none of the promises in $ps$ contain a value. Otherwise, the best value is returned. Usually, that means the value with the highest associated proposal number.
A promise contains a value $v$ if it is of the form $\Promise{(\Just{v})}$.

$\operatorname{anyNack} : [\Promise{a}] \to \Bool\\
\anyNack{[]} = false\\
\anyNack{\Paren{\Nack{\_}: \_}} = true\\
\anyNack{\Paren{\_:xs}} = \anyNack{xs}$

$\anyNack{ps}$ returns $\True$ if the list contains at least one promise of the form $\Nack{n}$.
Otherwise, it returns $\False$.

$\operatorname{promiseCount} : [\Promise{a}] \to \mathbb{N}\\
\promiseCount{[]} = 0\\
\promiseCount{\Paren{\Promise{\_}:xs}} = 1 + \promiseCount{xs}\\
\promiseCount{\Paren{\_:xs}} = \promiseCount{xs}$

$\promiseCount{ps}$ takes a list of promises $ps$ and calculates the number of promises in that list of that have the form $\Promise{m}$.

$\operatorname{gt}: a \to \Maybe{a} \to \Bool\\
\greaterThan{\_}{\Nothing} = true\\
\greaterThan{a}{\Just{b}} = a > b$

$\operatorname{ge}: a \to \Maybe{a} \to \Bool\\
\greaterEqual{\_}{\Nothing} = true\\
\greaterEqual{a}{\Just{b}} = a \ge b$

$\operatorname{nFromProposal} : \Proposal{a} \to \mathbb{N}\\
\nFromProposal{\ProposalC{n}{\_}} = n$

$\nFromProposal{p}$ retrieves the proposal number $n$ inside proposal $p$, which has the form $\ProposalC{n}{pr}$.

$\operatorname{genA_Q} : \mathbb{N} \times \mathbb{N} \times \mathbb{N} \to \mathbb{N}$

$\genAq{i}{ac}{pc}$ returns a randomly selected set $A_Q$ with $A_Q \subseteq A = \Curly{1, \dots, ac}$ and $|A_Q| > \frac{|A|}{2}$.

$\update{n}{m}$ replaces the value inside $n$ with the value in $m$.

\section{Processes}
\newcommand{\Sys}[2]{\operatorname{Sys}\left(#1, #2\right)}
\newcommand{\Pa}[0]{\operatorname{P^a}}
\newcommand{\Pp}[0]{\operatorname{P^p}}
\newcommand{\PaCont}[0]{\operatorname{P^a_{cont}}}

\newcommand{\PpInit}[5]{\operatorname{P^p_{init}}\left(#1, #2, #3, #4, #5\right)}
\newcommand{\PaInit}[6]{\operatorname{P^a_{init}}\left(#1, #2, #3, #4, #5, #6\right)}

\subsection{System Initialization}
\newcommand{\SessionRequest}[3]{\overline{#1}\left[#2\right]\left(#3\right)}
\newcommand{\SessionAccept}[3]{#1\left[#2\right]\left(#3\right)}
\newcommand{\ParallelFor}[1]{\Pi_{#1}\;}
\newcommand{\VectorV}[0]{\overrightarrow{V}}

% Idea: One shared-point per Proposer over which the session is initialized.
$\Sys{ac}{pc} = \SessionRequest{a}{2}{t} . \PpInit{ac + 1}{\genAq{ac + pc}{ac}{pc}}{ac + pc}{ac + pc}{[]}\\
\Or \SessionAccept{a}{1}{t} . \ParallelFor{ac < i < ac + pc} \PpInit{ac + 1}{\genAq{i}{ac}{pc}}{i}{i}{[]} \\
\Or \ParallelFor{1 \le j \le ac} \PaInit{j}{ac + 1}{ac}{pc}{n_j}{pr_j}$

$\PpInit{i}{A_Q}{n}{m}{\VectorV} = \SessionRequest{b_n}{i}{s} . \Pp$

$\PaInit{j}{i}{ac}{pc}{n}{pr} = \ParallelFor{ac < k \le ac + pc} \SessionAccept{b_k}{j}{s} . \Pa$

$\Sys{ac}{pc}$, $\PpInit{i}{A_Q}{n}{m}{\VectorV}$, and $\PaInit{j}{i}{ac}{pc}{n}{pr}$ describe the system initialization.
$ac$ and $pc$ are the number of acceptors and proposers respectively.

An outer session is created through shared-point $a$.
This outer session is not strictly necessary but was left in to allow for easier extension of the model.
The acceptors are initialized using indices from 1 to $ac$ and the proposers are initialized using indices from $ac + 1$ to $ac + pc$.

$\PpInit{i}{A_Q}{n}{m}{\VectorV}$ is initialized with the proposer's role in its own session $i$, which is always $ac + 1$, a quorum of acceptors $A_Q$, an index $n$, and a vector $\VectorV$.
Each proposer has the same role $i = ac + 1$ but uses a different shared-point $b_n$ according to its index $n$.
$\VectorV$ is used in the proposer to collect and evaluate the responses from the acceptors.
It is always initialized with an empty list $[]$.
Shared-point $b_n$ is used to initiate a session.
Afterwards, the process behaves like $\Pp$.

$\PaInit{j}{i}{ac}{pc}{n}{pr}$ is initialized with the acceptor's index $j$, the proposer index $i$, which is always $ac + 1$, $ac$, $pc$, initial knowledge for the highest promised proposal number $n$, if available, and initial knowledge for the most recently accepted proposal $pr$, if available.
$n$ is of type $\Maybe{\mathbb{N}}$ and $pr$ is of type $\Maybe{\Paren{\Proposal{\Value}}}$ thus both can be $\Nothing$.
Each of the proposers' session requests are accepted in a separate subprocess.
These subprocesses run parallel to each other but still access the same values for $n$ and $pr$.
We observe that each subprocess in an acceptor accesses a different channel $s$, since it is generated by the proposer and passed through when the proposers' session request is accepted.
Afterwards, each subprocess behaves like $\Pa$.

\subsection{Proposer}
\newcommand{\SendUnreliableP}[5]{#1\left[#2, #3\right]!_u #4 \left\langle #5 \right\rangle}
\newcommand{\ReceiveUnreliableP}[6]{#1\left[#2, #3\right]?_u #4 \left\langle #5 \right\rangle \left(#6\right)}
\newcommand{\ceil}[1]{\Big\lceil #1 \Big\rceil}
\newcommand{\SendWeaklyP}[5]{#1\left[#2, #3\right]!_w #4.#5}
\newcommand{\ReceiveWeaklyP}[4]{#1\left[#2, #3\right]?_w #4}
\newcommand{\If}[1]{\operatorname{if}\; #1}
\newcommand{\Then}[1]{\operatorname{then}\; #1}
\newcommand{\Else}[1]{\operatorname{else}\; #1}
\newcommand{\tOr}[0]{\text{ or }}

$\Pp = \Mu{X} \update{n}{n + 1} .\\
\hspace*{0.5em}\left(\DotForall{j \in A_Q} \SendUnreliableP{s}{i}{j}{l1a}{\prNumber{n}{m}}\right) .\\
\hspace*{0.5em}\left(\DotForall{j \in A_Q} \ReceiveUnreliableP{s}{j}{i}{l1b}{\perp}{v_j}\right) .\\
\hspace*{0.5em}\If{\anyNack{\VectorV} \tOr \promiseCount{\VectorV} < \ceil{\frac{i}{2}}}\\
\hspace*{1em}\Then{\SendWeaklyP{s}{i}{A_Q}{\Restart}{X}}\\
\hspace*{1em}\Else{\\\hspace*{1.5em}\SendWeaklyP{s}{i}{A_Q}{\Accept}{\\\hspace*{1.5em}\DotForall{j \in A_Q} \SendUnreliableP{s}{i}{j}{l2a}{\ProposalC{\prNumber{n}{m}}{\promValue{\VectorV}}}.\\\hspace*{1.5em}end}}$

At the start of the recursion $n$ is incremented to make sure every run of the recursion uses a different $n$ and thus a different proposal number.
The proposal number is sent to every acceptor in $A_Q$ and their replies are gathered in $\VectorV$ through $v_j$.
Because $i = ac + 1$, the minimum number of acceptors needed to form a majority is $\ceil{\frac{i}{2}} = \ceil{\frac{ac + 1}{2}}$.
If any $\Nack{x}$ was received or the number of $\Promise{y}$ received is less than that needed for the smallest majority the proposer restarts the algorithm.
Otherwise, the proposer sends its proposal to the acceptors and terminates.

\subsection{Acceptor}
$\Pa = \Mu{X} \ReceiveUnreliableP{s}{i}{j}{l1a}{\perp}{n'} .\\
\hspace*{0.5em}\If{n' = \perp}\\
\hspace*{1em}\Then{\PaCont}\\
\hspace*{1em}\Else{\\
\hspace*{1.5em}\If{\greaterThan{n'}{n}}\\
\hspace*{1.5em}\Then{\update{n}{n'}.\SendUnreliableP{s}{j}{i}{l1b}{\Promise{pr}}.\PaCont}\\
\hspace*{1.5em}\Else{\SendUnreliableP{s}{j}{i}{l1b}{\Nack{n}}.\PaCont}}$

$\PaCont = \ReceiveWeaklyP{s}{i}{j}{\Accept . \ReceiveUnreliableP{s}{i}{j}{l2a}{\perp}{pr'} .\\
\hspace*{1em}\If{pr' = \perp}\\
\hspace*{1.5em}\Then{end}\\
\hspace*{1.5em}\Else{\\
\hspace*{2em}\If{\greaterEqual{\nFromProposal{pr'}}{n}}\\
\hspace*{2.5em}\Then{\update{pr}{pr'} . \update{n}{\Just{\nFromProposal{pr'}}}.end}\\
\hspace*{2.5em}\Else{end}}\\
\hspace*{0.5em} \oplus \Restart.X\\
\hspace*{0.5em} \oplus \Abort.end}$

For each proposer an acceptor has a corresponding subprocess, which behaves like $\Pa$.
These subprocesses access the same values for $n$ and $pr$.
This means that updating these values with $\update{n}{m}$ updates them for all subprocesses of an acceptor.

Each subprocess can communicate with one proposer.
Thus, if that proposer does not or can not communicate with a particular subprocess of an acceptor then there is no need for that subprocess.
It is possible that an acceptor participates in a proposers' session but is not contained in the proposers' quorum of acceptors $A_Q$, in which case the proposer does not communicate with that acceptor.
It is also possible for a proposer to crash or otherwise terminate, in which case the proposer can not communicate with that acceptor.

Each subprocess starts out by potentially receiving a proposal number $n'$ from the corresponding proposer.
If the acceptor does receive a proposal number $n'$ it responds with either $\Promise{pr}$ or $\Nack{n}$, depending on the values of $n'$ and $n$.
If the acceptor does not receive a proposal number then it sends no response to the proposer.
In either case the subprocess moves on to receive the proposers' decision in phase $2a$.
% why does the acceptor move on if it received no proposal number?

% Abort -> end
Since the proposers' decision broadcast is weakly reliable, there are two cases in which the acceptor receives no decision.
The proposer might have terminated or this particular acceptor is not in the proposers' quorum of acceptors $A_Q$.
In either case this particular subprocess of the acceptor is no longer needed, because each subprocess of the acceptor exclusively communicates with one proposer.
Thus, the subprocess terminates in the default branch $\Abort$.

% Restart -> recurse
In the $\Restart$ branch this particular subprocess of the acceptor restarts the algorithm to match the corresponding proposer.

% Accept -> receive pr', update, end because proposer ends
In the $\Accept$ branch the acceptor potentially receives a proposal $pr'$ from the corresponding proposer.
The acceptor updates $n$ and $pr$ if the proposal number in $pr'$ is greater or equal to $n$.
Then the subprocess terminates.
If the acceptor does not receive a proposal or the proposal number of $pr'$ is less than $n$ the subprocess terminates without updating $n$ or $pr$.

\section{Failure Patterns}
\newcommand{\FPuget}[0]{\mathtt{FP_{uget}}}
\newcommand{\FPuskip}[0]{\mathtt{FP_{uskip}}}
\newcommand{\FPml}[0]{\mathtt{FP_{ml}}}
\newcommand{\FPwskip}[0]{\mathtt{FP_{wskip}}}
\newcommand{\FPcrash}[0]{\mathtt{FP_{crash}}}
\newcommand{\EventuallyWeak}[0]{\Diamond\mathscr{W}}
Chandra and Toueg introduce a class of failure detectors $\EventuallyWeak$, which is called \emph{eventually weak} in \cite{failure_detectors}.
Failure detectors in $\EventuallyWeak$ satisfy the following properties: (1) eventually every process that crashes is permanently suspected by some correct process and (2) eventually some correct process is never suspected by any correct process.

In all three phases modeled in the global type it is possible to suspect senders.
In phases $1a$ and $2a$, with labels $l1a$ and $l2a$ respectively, the acceptors may suspect some proposers.
The proposers may suspect some acceptors in phase $1b$ with label $l1b$.
Accordingly, $\FPuskip$ is implemented with a failure detector in $\EventuallyWeak$ for phases $1a$, $1b$, and $2a$.

Similarly, message loss is possible in all phases modeled in the global type.
Thus, $\FPml$ is also implemented with a failure detector in $\EventuallyWeak$.

For the weakly reliable broadcast in phase $2a$, the failure pattern $\FPwskip$ returns $\True$ if, and only if, the corresponding proposer crashed or otherwise terminated.

For Paxos to work a majority of acceptors needs to be alive.
That means that the number of failed acceptors $f$ needs to satisfy $n > 2f$ where $n$ is the total number of acceptors, except in one case where there are 2 acceptors.
Then, at most one acceptor may crash \cite{lower_bounds}.
$\FPcrash$ returns $\True$ if, and only if, at least one more acceptor may crash, i.e. $n > 2(f + 1)$ is satisfied.

In Paxos there is no need to reject outdated messages so $\FPuget$ is implemented with a constant $\True$.


\section{Example}
\newcommand{\Nu}[1]{\left(\nu #1\right)}
\newcommand{\OuterSessionQueues}[0]{\ParallelFor{1 \le k,l \le 2, k \neq l} t_{k\to l}:[]}
\newcommand{\InnerSessionQueues}[1]{\ParallelFor{1 \le k,l \le 4, k \neq l} #1_{k\to l}:[]}
\newcommand{\NuChannels}[0]{\Nu{t}\Nu{s}\Nu{r}}

\newcommand{\BeginPaCont}[0]{\Accept \dots \oplus \Restart .X \oplus \Abort .end}
\newcommand{\ABC}[0]{\operatorname{abc}}
\newcommand{\Acceptor}[1]{\operatorname{A#1}}
\newcommand{\Proposer}[1]{\operatorname{P#1}}

\begin{figure}
\begin{tikzpicture}[node distance=2cm, >=stealth', arrt/.style={above, font=\footnotesize}, arr/.style={->, thick}]
    \def\InitialOffset{0.4}
    \def\StepSize{0.7}
    \newcommand{\Step}[1]{\InitialOffset + #1 * \StepSize}
    \def\MaxSteps{14}
    \def\FullHeight{\Step{\MaxSteps} + 0.66 * \StepSize}

    \node (a1) {$\Acceptor{1}$};
    \node[right = of a1] (a2) {$\Acceptor{2}$};
    \node[right = of a2] (a3) {$\Acceptor{3}$};
    \node[right = of a3] (p4) {$\Proposer{4}$};
    \node[right = of p4] (p5) {$\Proposer{5}$};
    \node[left = of a1] (notes) {};

    \draw[dashed] (a1) -- ($(a1) - (0, \FullHeight)$);
    \draw[dashed] (a2) -- ($(a2) - (0, \FullHeight)$);
    \draw[dashed] (a3) -- ($(a3) - (0, \FullHeight)$);
    \draw[dashed] (p4) -- ($(p4) - (0, \Step{14.5})$);
    \draw[dashed] (p5) -- ($(p5) - (0, \Step{5.5})$);
    
    \draw[arr] ($(p5) - (0, \Step{1})$) -- node[arrt] {$\prNumber{6}{5} = 10$} ($(a2) - (0, \Step{1})$);
    \draw[arr] ($(p5) - (0, \Step{1})$) -- ($(a3) - (0, \Step{1})$);

    \draw[arr] ($(a2) - (0, \Step{2})$) -- node[arrt] {$\Promise{\Nothing}$} ($(p5) - (0, \Step{2})$);

    \draw[arr] ($(a3) - (0, \Step{3})$) -- node[arrt] {$\Promise{\Nothing}$} ($(p5) - (0, \Step{3})$);

    \draw[arr] ($(p5) - (0, \Step{4})$) -- node[arrt] {$\Accept$} ($(a2) - (0, \Step{4})$);
    \draw[arr] ($(p5) - (0, \Step{4})$) -- ($(a3) - (0, \Step{4})$);

    \draw[arr] ($(p5) - (0, \Step{5})$) -- node[arrt] {$\ProposalC{10}{\ABC}$} ($(a2) - (0, \Step{5})$);
    \draw[arr] ($(p5) - (0, \Step{5})$) -- ($(a3) - (0, \Step{5})$);

    \draw[arr] ($(p4) - (0, \Step{6})$) -- node[arrt] {$\prNumber{5}{4} = 5$} ($(a1) - (0, \Step{6})$);
    \draw[arr] ($(p4) - (0, \Step{6})$) -- ($(a2) - (0, \Step{6})$);

    \draw[arr] ($(a1) - (0, \Step{7})$) -- node[arrt] {$\Promise{\Nothing}$} ($(p4) - (0, \Step{7})$);

    \draw[arr] ($(a2) - (0, \Step{8})$) -- node[arrt] {$\Nack{10}$} ($(p4) - (0, \Step{8})$);

    \draw[arr] ($(p4) - (0, \Step{9})$) -- node[arrt] {$\Restart$} ($(a1) - (0, \Step{9})$);
    \draw[arr] ($(p4) - (0, \Step{9})$) -- ($(a2) - (0, \Step{9})$);

    \draw[arr] ($(p4) - (0, \Step{10})$) -- node[arrt] {$\prNumber{6}{4} = 15$} ($(a1) - (0, \Step{10})$);
    \draw[arr] ($(p4) - (0, \Step{10})$) -- ($(a2) - (0, \Step{10})$);

    \draw[arr] ($(a1) - (0, \Step{11})$) -- node[arrt] {$\Promise{\Nothing}$} ($(p4) - (0, \Step{11})$);
    
    \draw[arr] ($(a2) - (0, \Step{12})$) -- node[arrt] {$\Promise{\ProposalC{10}{\ABC}}$} ($(p4) - (0, \Step{12})$);

    \draw[arr] ($(p4) - (0, \Step{13})$) -- node[arrt] {$\Accept$} ($(a1) - (0, \Step{13})$);
    \draw[arr] ($(p4) - (0, \Step{13})$) -- ($(a2) - (0, \Step{13})$);

    \draw[arr] ($(p4) - (0, \Step{14})$) -- node[arrt] {$\ProposalC{15}{\ABC}$} ($(a1) - (0, \Step{14})$);
    \draw[arr] ($(p4) - (0, \Step{14})$) -- ($(a2) - (0, \Step{14})$);

    \foreach \r in {1,...,\MaxSteps} {
        \node[font=\footnotesize] at ($(notes) - (0, \Step{\r})$) {$(\r)$};
    }
\end{tikzpicture}
\caption{Example scenario with $3$ acceptors and $2$ proposers.}
\label{fig:scenario}
\end{figure}

We will take a look at an example run of the model with $3$ acceptors and $2$ proposers.
% first understand scenario and then check out the formulas?

Figure \ref{fig:scenario} provides an overview of the scenario we will go through where $\Acceptor{1}$, $\Acceptor{2}$, and $\Acceptor{3}$ are the acceptors and $\Proposer{4}$ and $\Proposer{5}$ are the proposers.
In steps $\Paren{1}$ to $\Paren{5}$, $\Proposer{5}$ completes the Paxos algorithm with $\Acceptor{2}$ and $\Acceptor{3}$ and terminates.

At this point $\Acceptor{2}$ has promised not to accept any proposal numbered less than $10$ and has accepted the value $\ABC$.
So, when $\Proposer{4}$ tries to use $4$ as its proposal number $\Paren{6}$, it receives $\Nack{10}$ from $\Acceptor{2}$ $\Paren{8}$ and has to restart the algorithm $\Paren{9}$.

$\Proposer{4}$ then runs through the Paxos algorithm with $\Acceptor{1}$ and $\Acceptor{2}$ starting with a new prepare request $\Paren{10}$ with a higher proposal number.
In step $\Paren{12}$ $\Proposer{4}$ learns that value $\ABC$ with proposal number $10$ has already been accepted by $\Acceptor{2}$.
Later, in step $\Paren{14}$, $\Proposer{4}$ issues a proposal with the value of the highest-numbered proposal that it receives as a response to its prepare request.
In this case there is only one such proposal, which is $\ProposalC{10}{\ABC}$.

In the end all $3$ acceptors have accepted the value $\ABC$.
$\Acceptor{1}$ and $\Acceptor{2}$ have accepted $\ProposalC{15}{\ABC}$ and $\Acceptor{3}$ has accepted $\ProposalC{10}{\ABC}$.
