\chapter{Model}
First, we specify some sorts with which we can then define the global type.
Afterwards, we define the processes for the proposer and the acceptor.
Finally, we will study an example run of the model.

\section{Sorts}
Sorts are basic data types.
We assume the following sorts.

First, we have $\Bool$ which we define as a set.

\[\Bool = \Curly{\True, \False}\]

Second, we assume a set of proposable values $\Value$.
This set contains at least two elements of any kind.
For example, $\Value=\Curly{\ABC, \operatorname{def}, \dots, \operatorname{vwx}, \operatorname{yz}}$.

Then, we have some sorts which we define using a grammar.
Each of these definitions contains a type parameter, which is a variable ranging over types.
In this case the type parameter in each definition is called $a$.

\[\Maybe{a} = \Just{a} \Or \Nothing\]

A value of type $\Maybe{a}$ can have the form $\Just{a}$ or $\Nothing$.
Some examples include $\Just{4}$ of type $\Maybe{\mathbb{N}}$, $\Just{\False}$ of type $\Maybe{\Bool}$, and $\Nothing$.
$\Nothing$ itself does not dictate an exact type because its definition does not include the type parameter $a$.
The type is underspecified and is specified manually or through the context in which $\Nothing$ is used.
It can be of type $\Maybe{\mathbb{N}}$, $\Maybe{\Bool}$, or $\Maybe{b}$ for any other type $b$.
We use $\Maybe{a}$ where optional values are needed.

\[\Proposal{a} = \ProposalC{\mathbb{N}}{a}\]

$\Proposal{a}$ only has one possible form, which is $\ProposalC{\mathbb{N}}{a}$.
A proposal contains its proposal number of type $\mathbb{N}$ and its value of type $a$.
Again, $a$ is a variable ranging over types.
An example for a value of type $\Proposal{\Bool}$ could be $\ProposalC{1}{\True}$ and an example for a value of type $\Proposal{\Paren{\Maybe{\mathbb{N}}}}$ could be $\ProposalC{1}{\Paren{\Just{1}}}$.
This sort models the proposals issued by the proposers in phase $\PTwoA$.

\[\Promise{a} = \Promise{\Paren{\Maybe{\Paren{\Proposal{a}}}}} \Or \Nack{\mathbb{N}}\]

$\Promise{a}$ has two possible forms.
$\Promise{\Paren{\Maybe{\Paren{\Proposal{a}}}}}$ and $\Nack{\mathbb{N}}$.
Possible values include $\Nack{1}$ and $\Promise{\Paren{\Just{\Paren{\ProposalC{1}{{\False}}}}}}$ of type $\Promise{\mathbb{\Bool}}$.
The actual type of $\Nack{1}$, much like that of $\Nothing$, is underspecified.
Again, we have to specify the exact type manually or through context.

In phase $\POneB$ the acceptors respond to the proposers prepare request with a value of type $\Promise{\Value}$.
The prepare request contains a number $n$.
The acceptors may respond to the prepare request with a promise to not accept any proposal numbered less than $n$ or with a rejection.
In the first case the acceptor's response optionally includes the last proposal it accepted, if available, and is of the form $\Promise{\Paren{\Maybe{\Paren{\Proposal{a}}}}}$.
In the second case it includes the highest $n$ that acceptor promised and is of the form $\Nack{\mathbb{N}}$.

\section{Global Type}
Since each proposer initiates its own session the global type can be defined for one proposer $\ProposerIndex$ and a quorum $\AQ$.

The last phase of Paxos contains no inter-process communication, so it is not modeled in the global type.

\begin{align*}
&\GlobalType = \Mu{\RecursionVariableType}
\DotForall{\AcceptorIndex \in \AQ}{\SendUnreliableG{\ProposerIndex}{\AcceptorIndex}{\LOneA}{\mathbb{N}}} .
\DotForall{\AcceptorIndex \in \AQ}{\SendUnreliableG{\AcceptorIndex}{\ProposerIndex}{\LOneB}{\Promise{\Value}}} .\\
&\Indent{1}\SendWeaklyG{\ProposerIndex}{\AQ}{
\Accept.\DotForall{\AcceptorIndex \in \AQ}{\SendUnreliableG{\ProposerIndex}{\AcceptorIndex}{\LTwoA}{\Proposal{\Value}}}.\End \oplus
\Restart.\RecursionVariableType \oplus
\Abort.\End}
\end{align*}

We can distinguish the individual phases of the Paxos algorithm by the labels $\LOneA$, $\LOneB$, and $\LTwoA$.

In the first two steps, $\POneA$ and $\POneB$, the proposer sends its proposal number to each acceptor in $\AQ$ and listens for their responses.
In step $\PTwoA$ the proposer decides whether to send an $\Accept$ or $\Restart$ message to restart the algorithm.
This decision is broadcast to all acceptors in $\AQ$.
Should the proposer crash the algorithm ends for this particular proposer and the subprocesses of the acceptors in its quorum.

\section{Functions}
We define some functions which we use in the next section to define the processes.

\[\proposalNumberName : \mathbb{N} \times \mathbb{N} \to \mathbb{N}\]

$\proposalNumber{\NumberRegister}{p}$ returns a proposal number for proposer $p$ when given a natural number $n$.
It is used to pick a number for the prepare request in phase $\POneA$, which is also used in phase $\PTwoA$ in the actual proposal.
We have two requirements for this function.

Let $\SetOfProposers$ be the set of proposers.

\[\forall p,q \in \SetOfProposers . \forall n,m \in \mathbb{N}: p \neq q \to \proposalNumber{\NumberRegister}{p} \neq \proposalNumber{m}{q}\]

Different proposers pick their proposal numbers from disjoint sets of numbers.
This way different proposers never issue a proposal with the same proposal number.

\[\forall p \in \SetOfProposers . \forall n,m \in \mathbb{N}: n > m \to \proposalNumber{\NumberRegister}{p} > \proposalNumber{m}{p}\]

We require $\proposalNumber{\NumberRegister}{p}$ to be strictly increasing for each proposer $p$ so every proposer uses a higher proposal number than any it has already used.

\[\promiseValueName : \List{\Promise{a}} \to a\]

$\promiseValue{ps}$ returns a fresh value if none of the promises in $ps$ contain a value. Otherwise, the best value is returned. Usually, that means the value with the highest associated proposal number.
A promise contains a value $v$ if it is of the form $\Promise{\Just{v}}$.
With this function we can model the picking of a value for a proposal in phase $\PTwoA$.

\begin{align*}
&\anyNackName : \List{\Promise{a}} \to \Bool\\
&\anyNack{\EmptyList} = \False\\
&\anyNack{\ListPattern{\Nack{\Wildcard}}{\Wildcard}} = \True\\
&\anyNack{\ListPattern{\Promise{\Wildcard}}{xs}} = \anyNack{xs}
\end{align*}

$\anyNack{ps}$ returns $\True$ if the list contains at least one promise of the form $\Nack{n}$.
Otherwise, it returns $\False$.

\begin{align*}
&\promiseCountName : \List{\Promise{a}} \to \mathbb{N}\\
&\promiseCount{\EmptyList} = 0\\
&\promiseCount{\ListPattern{\Promise{\Wildcard}}{xs}} = 1 + \promiseCount{xs}\\
&\promiseCount{\ListPattern{\Nack{\Wildcard}}{xs}} = \promiseCount{xs}
\end{align*}

$\promiseCount{ps}$ takes a list of promises $ps$ and counts the number of promises that have the form $\Promise{m}$.

$\anyNack{ps}$ and $\promiseCount{ps}$ are used in the proposer to decide which branch to take in phase $\PTwoA$.

\begin{align*}    
&\greaterThanName : a \times \Maybe{a} \to \Bool\\
&\greaterThan{\Wildcard}{\Nothing} = \True\\
&\greaterThan{a}{\Just{b}} = a > b
\end{align*}

\begin{align*}
&\greaterEqualName : a \times \Maybe{a} \to \Bool\\
&\greaterEqual{\Wildcard}{\Nothing} = \True\\
&\greaterEqual{a}{\Just{b}} = a \ge b
\end{align*}

\begin{align*}    
&\nFromProposalName : \Proposal{a} \to \mathbb{N}\\
&\nFromProposal{\ProposalC{n}{\Wildcard}} = n
\end{align*}

$\nFromProposal{p}$ retrieves the proposal number $n$ inside proposal $p$, which has the form $\ProposalC{n}{pr}$.

$\nFromProposal{p}$, $\greaterThan{a}{ma}$, and $\greaterEqual{a}{ma}$ are used to extract and compare proposal numbers in phase $\PTwoB$ of the acceptor.

\[\genAqName : \mathbb{N} \times \mathbb{N} \times \mathbb{N} \to \List{\mathbb{N}}\]

$\genAq{\ProposerIndex}{\AcceptorCount}{\ProposerCount}$ returns a randomly selected set $\AQ$ with $\AQ \subseteq A = \Curly{1, \dots, \AcceptorCount}$ and $|\AQ| > \frac{|A|}{2}$.
$\AQ$ consists of any majority of acceptors.
In Paxos a majority of acceptors forms a quorum, i.e. an accepting set with which a value can be chosen \cite{Lamport06}.
We use this function when initiating the proposers to give them a quorum with which they communicate.

\section{Processes}
\subsection{System Initialization}
\begin{align*}
&\Sys{\AcceptorCount}{\ProposerCount} = \SessionRequest{\OuterSharedPoint}{2}{\OuterSessionChannel} . \PpInit{\AcceptorCount + 1}{\genAq{\AcceptorCount + \ProposerCount}{\AcceptorCount}{\ProposerCount}}{\AcceptorCount + \ProposerCount}{\AcceptorCount + \ProposerCount}{\EmptyList}\\
&\Or \SessionAccept{\OuterSharedPoint}{1}{\OuterSessionChannel} . \ParallelFor{\AcceptorCount < k < \AcceptorCount + \ProposerCount} \PpInit{\AcceptorCount + 1}{\genAq{k}{\AcceptorCount}{\ProposerCount}}{k}{k}{\EmptyList} \\
&\Or \ParallelFor{1 \leq j \leq \AcceptorCount} \PaInit{j}{\AcceptorCount + 1}{\AcceptorCount}{\ProposerCount}{\NumberRegister_{\AcceptorIndex}}{\ProposalRegister_{\AcceptorIndex}}\\
\\
&\PpInit{\ProposerIndex}{\AQ}{\NumberRegister}{\ProcessIndex}{\VectorV} = \SessionRequest{\SharedPoint{\ProcessIndex}}{\ProposerIndex}{s} . \Pp{}\\
&\PaInit{\AcceptorIndex}{\ProposerIndex}{\AcceptorCount}{\ProposerCount}{n}{pr} = \ParallelFor{\AcceptorCount < k \le \AcceptorCount + \ProposerCount} \SessionAccept{\SharedPoint{k}}{\AcceptorIndex}{s} . \PaOne
\end{align*}

$\Sys{\AcceptorCount}{\ProposerCount}$, $\PpInit{\ProposerIndex}{\AQ}{\NumberRegister}{\ProcessIndex}{\VectorV}$, and $\PaInit{\AcceptorIndex}{\ProposerIndex}{\AcceptorCount}{\ProposerCount}{\NumberRegister}{\ProposalRegister}$ describe the system initialization.
$\AcceptorCount$ and $\ProposerCount$ are the number of acceptors and proposers respectively.

An outer session is created through shared channel $\OuterSharedPoint$.
This outer session is not strictly necessary but was left in to allow for easier extension of the model.
The acceptors are initialized using indices from 1 to $\AcceptorCount$ and the proposers are initialized using indices from $\AcceptorCount + 1$ to $\AcceptorCount + \ProposerCount$.

$\PpInit{\ProposerIndex}{\AQ}{\NumberRegister}{\ProcessIndex}{\VectorV}$ is initialized with the proposer's role in its own session $\ProposerIndex$, which is always $\AcceptorCount + 1$, a quorum $\AQ$, a register $\NumberRegister$, and a vector $\VectorV$.
Each proposer has the same role $\ProposerIndex = \AcceptorCount + 1$ but uses a different shared channel $\SharedPoint{\ProcessIndex}$ according to its index $\ProcessIndex$.
$\ProcessIndex$ is initialized to the same value as $\NumberRegister$ but is never updated.
$\VectorV$ is used in the proposer to collect and evaluate the responses from the acceptors.
It is always initialized with an empty list $\EmptyList$.
Shared channel $\SharedPoint{\ProcessIndex}$ is used to initiate a session.
Afterwards, the process behaves like $\Pp{}$.
We assume a mechanism for electing a distinguished proposer, which acts as the leader \cite{Lamport01}.
The leader is the only proposer that can try issuing proposers.
A new leader is elected via the same mechanism when the previous leader terminates or crashes.

$\PaInit{\AcceptorIndex}{\ProposerIndex}{\AcceptorCount}{\ProposerCount}{\NumberRegister}{\ProposalRegister}$ is initialized with the acceptor's index $\AcceptorIndex$, the proposer index $\ProposerIndex$, which is always $\AcceptorCount + 1$, $\AcceptorCount$, $\ProposerCount$, initial knowledge for the highest promised proposal number $\NumberRegister = \NumberRegister_{\AcceptorIndex}$, if available, and initial knowledge for the most recently accepted proposal $\ProposalRegister = \ProposalRegister_{\AcceptorIndex}$, if available.
$\NumberRegister$ holds a value of type $\Maybe{\mathbb{N}}$ and $\ProposalRegister$ holds a value of type $\Maybe{\Paren{\Proposal{\Value}}}$ thus both can contain $\Nothing$.
We assume both registers are implemented via stable storage, which is preserved during failures.
Each of the proposers' session requests are accepted in a separate subprocess.
These subprocesses run parallel to each other but still access the same registers $\NumberRegister$ and $\ProposalRegister$.
We observe that each subprocess in an acceptor accesses a different channel $s$, since it is generated by the proposer when its session request is accepted.
Afterwards, each subprocess behaves like $\PaOne$.

\subsection{Proposer}
To define the proposer and the acceptor we introduce a function $\update{r}{v}$ which replaces the value inside register $r$ with $v$.
We use this function to update the registers of the processes.

\begin{align*}
&\Pp{} = \Mu{\RecursionVariable} \update{\NumberRegister}{\NumberRegister + 1} .\\
&\Indent{1}\DotForall{\AcceptorIndex\in\AQ}{\SendUnreliableP{s}{\ProposerIndex}{\AcceptorIndex}{\LOneA}{\proposalNumber{\NumberRegister}{m}}} .\\
&\Indent{1}\DotForall{\AcceptorIndex\in\AQ}{\ReceiveUnreliableP{s}{\AcceptorIndex}{\ProposerIndex}{\LOneB}{\bot}{v_{\AcceptorIndex}}} .\\
&\Indent{1}\If{\anyNack{\VectorV} \tOr \Paren{\promiseCount{\VectorV} < \ceil{\frac{\ProposerIndex}{2}}}}\\
&\Indent{2}\Then{\SendWeaklyP{s}{\ProposerIndex}{\AQ}{\Restart}{\RecursionVariable}}\\
&\Indent{2}\Else{\SendWeaklyP{s}{\ProposerIndex}{\AQ}{\Accept}{\\
&\Indent{3}\DotForall{\AcceptorIndex\in\AQ}{\SendUnreliableP{s}{\ProposerIndex}{\AcceptorIndex}{\LTwoA}{\ProposalC{\Big ( \proposalNumber{\NumberRegister}{m} \Big )}{\Paren{\promiseValue{\VectorV}}}}}.\End
}}
\end{align*}

At the start of the recursion the value in $\NumberRegister$ is incremented to make sure every run of the recursion uses a different proposal number.
The proposal number is sent to every acceptor in $\AQ$ and their replies are gathered in $\VectorV$ through $v_{\AcceptorIndex}$.
Because $\ProposerIndex = \AcceptorCount + 1$, the minimum number of acceptors needed to form a majority is $\ceil{\frac{\ProposerIndex}{2}} = \ceil{\frac{\AcceptorCount + 1}{2}}$.
If any $\Nack{x}$ was received or the number of $\Promise{y}$ received is less than that needed for the majority the proposer restarts the algorithm.
Otherwise, the proposer sends its proposal to the acceptors and terminates.

\subsection{Acceptor}
\begin{align*}
&\PaOne = \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{\ProposerIndex}{\AcceptorIndex}{\LOneA}{\bot}{n'} .\\
&\Indent{1}\big ( \If{n' = \bot} \Then{\SendUnreliableP{s}{\AcceptorIndex}{\ProposerIndex}{\LOneB}{\bot}.\PaTwo}\\
&\Indent{2}\Else{\big( \If{\greaterThan{n'}{\NumberRegister}}\\
&\Indent{3}\Then{\update{\NumberRegister}{n'}}.\SendUnreliableP{s}{\AcceptorIndex}{\ProposerIndex}{\LOneB}{\Promise{\ProposalRegister}}.\PaTwo\\
&\Indent{3}\Else{\SendUnreliableP{s}{\AcceptorIndex}{\ProposerIndex}{\LOneB}{\Nack{\NumberRegister}}.\PaTwo}
\big ) \big )}
\\\\
&\PaTwo = \ReceiveWeaklyP{s}{\ProposerIndex}{\AcceptorIndex}{\Accept . \ReceiveUnreliableP{s}{\ProposerIndex}{\AcceptorIndex}{\LTwoA}{\bot}{pr'} .\\
&\Indent{2}\big( \If{pr' = \bot} \Then{\End}\\
&\Indent{3}\Else{\big( \If{\greaterEqual{\nFromProposal{pr'}}{\NumberRegister}}\\
&\Indent{5}\Then{\update{\ProposalRegister}{pr'} . \update{\NumberRegister}{\Just{\Paren{\nFromProposal{pr'}}}}.\End}\\
&\Indent{5}\Else{\End} \big ) \big )}\\
&\Indent{1} \oplus \Restart.\RecursionVariable\\
&\Indent{1} \oplus \Abort.\End
}
\end{align*}

For each proposer an acceptor has a corresponding subprocess, which behaves like $\PaOne$.
These subprocesses access the same registers $\NumberRegister$ and $\ProposalRegister$.
This means that updating these registers with $\update{r}{v}$ updates them for all subprocesses of an acceptor.

Each subprocess can communicate with one proposer.
Thus, if that proposer does not or can not communicate with a particular subprocess of an acceptor then there is no need for that subprocess.
It is possible that an acceptor participates in a proposer's session but is not contained in the proposer's quorum $\AQ$, in which case the proposer does not communicate with that acceptor.
It is also possible for a proposer to crash or otherwise terminate, in which case the proposer can not communicate with that acceptor.

Each subprocess begins by potentially receiving a proposal number $n'$ from the corresponding proposer.
If the acceptor does receive a proposal number $n'$ it responds with either $\Promise{\ProposalRegister}$ or $\Nack{\NumberRegister}$, depending on the values of $n'$ and $\NumberRegister$.
If the acceptor does not receive a proposal number then it sends $\bot$ to the proposer.
Sending $\bot$ to the proposer is only necessary to maintain the global type.
In either case the subprocess moves on to receive the proposers' decision in phase $\PTwoA$.
% why does the acceptor move on if it received no proposal number?

% Abort -> end
Since the proposers' decision broadcast is weakly reliable, there are two cases in which the acceptor receives no decision.
The proposer might have terminated or this particular acceptor is not in the proposers' quorum $\AQ$.
In either case this particular subprocess of the acceptor is no longer needed, because each subprocess of the acceptor exclusively communicates with one proposer.
Thus, the subprocess terminates in the default branch $\Abort$.

% Restart -> recurse
In the $\Restart$ branch this particular subprocess of the acceptor restarts the algorithm to match the corresponding proposer.

% Accept -> receive pr', update, end because proposer ends
In the $\Accept$ branch the acceptor potentially receives a proposal $pr'$ from the corresponding proposer.
The acceptor updates $\NumberRegister$ and $\ProposalRegister$ if the proposal number in $pr'$ is greater or equal to $\NumberRegister$.
Then the subprocess terminates.
If the acceptor does not receive a proposal or the proposal number of $pr'$ is less than $\NumberRegister$ the subprocess terminates without updating $\NumberRegister$ or $\ProposalRegister$.

\section{Failure Patterns}
Chandra and Toueg introduce a class of failure detectors $\FailureDetectorClass$ called \emph{eventually strong} in \cite{ChandraToueg96}.
Failure detectors in $\FailureDetectorClass$ satisfy the following properties: (1) eventually every process that crashes is permanently suspected by every correct process and (2) eventually some correct process is never suspected by any correct process.

% uskip and ml:
% false for l2a, eventually strong otherwise for proposers and acceptors
In phase $\POneA$ with label $\LOneA$ the acceptors may suspect some proposers and in phase $\POneB$ with label $\LOneB$ the proposers may suspect some acceptors.
Accordingly, $\FPuskip$ and $\FPml$ are implemented with a failure detector in $\FailureDetectorClass$ for phases $\POneA$ and $\POneB$.
For phase $\PTwoA$ with label $\LTwoA$ both $\FPuskip$ and $\FPml$ return $\False$ to ensure the proposal sent by the proposer to the members of its quorum is not lost.
Thus, the unreliable communication is treated like the weakly reliable broadcast before it.

% wskip: true <=> corresponding proposer is not alive
% leave undefined for proposers because they don't receive a broadcast
For the weakly reliable broadcast in phase $\PTwoA$, the failure pattern $\FPwskip$ eventually returns $\True$ for subprocesses of acceptors if the corresponding proposer crashed.

% crash:
% we need at least one proposer
% true if every correct proposers quorum is still a quorum without that acceptor, otherwise false
We require that every correct proposer is able to communicate with a quorum for Paxos to work.
Therefore, $\FPcrash$ eventually returns $\True$ for a subprocess of an acceptor $\AcceptorIndex$ only if the corresponding proposer with quorum $\AQ$ either crashed or still has access to a quorum without that particular acceptor \ie $\AQ\setminus\Curly{\AcceptorIndex}$ is still a quorum.
% implies that acceptors as a whole may crash if proposers are either correct and can still communicate with a quorum without that acceptor or crashed
% what about the requirement that we need at least one proposer?

In Paxos there is no need to reject outdated messages so $\FPuget$ is implemented with a constant $\True$.

These failure patterns satisfy the Conditions~\ref{cond:all}.\ref{cond:crash}--\ref{cond:all}.\ref{cond:fpWskip}.

\section{Example}
In this section we will study an example run of the model with $3$ acceptors and $2$ proposers.
First, we will take a look at the example scenario.
Then we will examine the scenario using reduction rules starting at system initialization.

\begin{figure}
\begin{center}
\begin{tikzpicture}[node distance=2.5cm, >=stealth', arrt/.style={above, font=\footnotesize}, arr/.style={->, thick}, lifeline/.style={dashed, black!35}]
    \def\InitialOffset{0.4}
    \def\StepSize{0.7}
    \newcommand{\Step}[1]{\InitialOffset + #1 * \StepSize}
    \def\MaxSteps{14}
    \def\FullHeight{\Step{\MaxSteps} + 0.66 * \StepSize}

    \node (a1) {$\Acceptor{1}$};
    \node[right = of a1] (a2) {$\Acceptor{2}$};
    \node[right = of a2] (a3) {$\Acceptor{3}$};
    \node[right = of a3] (p4) {$\Proposer{4}$};
    \node[right = of p4] (p5) {$\Proposer{5}$};
    \node[left = of a1] (notes) {};

    \draw[lifeline] (a1) -- ($(a1) - (0, \FullHeight)$);
    \draw[lifeline] (a2) -- ($(a2) - (0, \FullHeight)$);
    \draw[lifeline] (a3) -- ($(a3) - (0, \FullHeight)$);
    \draw[lifeline] (p4) -- ($(p4) - (0, \Step{14.5})$);
    \draw[lifeline] (p5) -- ($(p5) - (0, \Step{5.5})$);
    
    \draw[arr] ($(p5) - (0, \Step{1})$) -- node[arrt] {$\proposalNumber{6}{5} = 10$} ($(a2) - (0, \Step{1})$);
    \draw[arr] ($(p5) - (0, \Step{1})$) -- ($(a3) - (0, \Step{1})$);

    \draw[arr] ($(a2) - (0, \Step{2})$) -- node[arrt] {$\Promise{\Nothing}$} ($(p5) - (0, \Step{2})$);

    \draw[arr] ($(a3) - (0, \Step{3})$) -- node[arrt] {$\Promise{\Nothing}$} ($(p5) - (0, \Step{3})$);

    \draw[arr] ($(p5) - (0, \Step{4})$) -- node[arrt] {$\Accept$} ($(a2) - (0, \Step{4})$);
    \draw[arr] ($(p5) - (0, \Step{4})$) -- ($(a3) - (0, \Step{4})$);

    \draw[arr] ($(p5) - (0, \Step{5})$) -- node[arrt] {$\ProposalC{10}{\ABC}$} ($(a2) - (0, \Step{5})$);
    \draw[arr] ($(p5) - (0, \Step{5})$) -- ($(a3) - (0, \Step{5})$);

    \draw[arr] ($(p4) - (0, \Step{6})$) -- node[arrt] {$\proposalNumber{5}{4} = 5$} ($(a1) - (0, \Step{6})$);
    \draw[arr] ($(p4) - (0, \Step{6})$) -- ($(a2) - (0, \Step{6})$);

    \draw[arr] ($(a1) - (0, \Step{7})$) -- node[arrt] {$\Promise{\Nothing}$} ($(p4) - (0, \Step{7})$);

    \draw[arr] ($(a2) - (0, \Step{8})$) -- node[arrt] {$\Nack{10}$} ($(p4) - (0, \Step{8})$);

    \draw[arr] ($(p4) - (0, \Step{9})$) -- node[arrt] {$\Restart$} ($(a1) - (0, \Step{9})$);
    \draw[arr] ($(p4) - (0, \Step{9})$) -- ($(a2) - (0, \Step{9})$);

    \draw[arr] ($(p4) - (0, \Step{10})$) -- node[arrt] {$\proposalNumber{6}{4} = 15$} ($(a1) - (0, \Step{10})$);
    \draw[arr] ($(p4) - (0, \Step{10})$) -- ($(a2) - (0, \Step{10})$);

    \draw[arr] ($(a1) - (0, \Step{11})$) -- node[arrt] {$\Promise{\Nothing}$} ($(p4) - (0, \Step{11})$);
    
    \draw[arr] ($(a2) - (0, \Step{12})$) -- node[arrt] {$\Promise{\Paren{\ProposalC{10}{\ABC}}}$} ($(p4) - (0, \Step{12})$);

    \draw[arr] ($(p4) - (0, \Step{13})$) -- node[arrt] {$\Accept$} ($(a1) - (0, \Step{13})$);
    \draw[arr] ($(p4) - (0, \Step{13})$) -- ($(a2) - (0, \Step{13})$);

    \draw[arr] ($(p4) - (0, \Step{14})$) -- node[arrt] {$\ProposalC{15}{\ABC}$} ($(a1) - (0, \Step{14})$);
    \draw[arr] ($(p4) - (0, \Step{14})$) -- ($(a2) - (0, \Step{14})$);

    \foreach \r in {1,...,\MaxSteps} {
        \node[font=\footnotesize] at ($(notes) - (0, \Step{\r})$) {$(\r)$};
    }
\end{tikzpicture}
\end{center}
\caption{Example scenario with $3$ acceptors and $2$ proposers.}
\label{fig:scenario}
\end{figure}

\subsection{Scenario}
Figure \ref{fig:scenario} provides an overview where $\Acceptor{1}$, $\Acceptor{2}$, and $\Acceptor{3}$ are the acceptors and $\Proposer{4}$ and $\Proposer{5}$ are the proposers.
$\Proposer{5}$ is elected to be the leader.
In steps $\Paren{1}$ to $\Paren{5}$, $\Proposer{5}$ completes the Paxos algorithm with $\Acceptor{2}$ and $\Acceptor{3}$ and terminates.

At this point $\Acceptor{2}$ has promised not to accept any proposal numbered less than $10$ and has accepted the value $\ABC$.
So, when $\Proposer{4}$ tries to use $5$ as its proposal number $\Paren{6}$, it receives $\Nack{10}$ from $\Acceptor{2}$ $\Paren{8}$ and has to restart the algorithm $\Paren{9}$.

$\Proposer{4}$ then runs through the Paxos algorithm with $\Acceptor{1}$ and $\Acceptor{2}$ starting with a new prepare request $\Paren{10}$ with a higher proposal number.
In step $\Paren{12}$ $\Proposer{4}$ learns that value $\ABC$ with proposal number $10$ has already been accepted by $\Acceptor{2}$.
Later, in step $\Paren{14}$, $\Proposer{4}$ issues a proposal with the value of the highest-numbered proposal that it receives as a response to its prepare request.
In this case there is only one such proposal, which is $\ProposalC{10}{\ABC}$.

In the end all $3$ acceptors have accepted the value $\ABC$.
$\Acceptor{1}$ and $\Acceptor{2}$ have accepted $\ProposalC{15}{\ABC}$ and $\Acceptor{3}$ has accepted $\ProposalC{10}{\ABC}$.

\subsection{Formulae}
We set $\AcceptorCount = 3$, $\ProposerCount = 2$,
$\Value=\Curly{\ABC, \operatorname{def}, \dots, \operatorname{vwx}, \operatorname{yz}}$.
$\AQ_4 = \genAq{4}{3}{2} = \Curly{1,2}$ will be the quorum for $\Proposer{4}$ and $\AQ_5 = \genAq{5}{3}{2} = \Curly{2,3}$ will be the quorum for $\Proposer{5}$.

\subsubsection{System Initialization}
After inserting $\AcceptorCount$ and $\ProposerCount$ and applying $\RInit$ once for shared channel $a$ we have:

\begin{align*}
&\Sys{\AcceptorCount}{\ProposerCount} = \Sys{3}{2} =\\
&\SessionAccept{\OuterSharedPoint}{1}{\OuterSessionChannel}.\ParallelFor{3 < k < 5} \PpInit{4}{\genAq{k}{3}{2}}{k}{k}{\EmptyList}\\
&\Or \SessionRequest{\OuterSharedPoint}{2}{\OuterSessionChannel}.\PpInit{4}{\genAq{5}{3}{2}}{5}{5}{\EmptyList}\\
&\Or \ParallelFor{1 \le \AcceptorIndex \le 3} \PaInit{\AcceptorIndex}{4}{3}{2}{n_{\AcceptorIndex}}{pr_{\AcceptorIndex}}
\\\\
&\mapstostar \Nu{\OuterSessionChannel}\big (
\SessionRequest{\SharedPoint{4}}{4}{s}.\Pp{} \comment{= \Proposer{4}}\\
&\Or \SessionRequest{\SharedPoint{5}}{4}{r}.\Pp{} \comment{= \Proposer{5}}\\
&\Or \Paren{\SessionAccept{\SharedPoint{4}}{1}{s}.\PaOne \Or \SessionAccept{\SharedPoint{5}}{1}{r}.\PaOne} \comment{= \Acceptor{1}}\\
&\Or \Paren{\SessionAccept{\SharedPoint{4}}{2}{s}.\PaOne \Or \SessionAccept{\SharedPoint{5}}{2}{r}.\PaOne} \comment{= \Acceptor{2}}\\
&\Or \Paren{\SessionAccept{\SharedPoint{4}}{3}{s}.\PaOne \Or \SessionAccept{\SharedPoint{5}}{3}{r}.\PaOne} \comment{= \Acceptor{3}}\\
&\Or \OuterSessionQueues
\big )
\end{align*}

Note that the outer session created via shared channel $\OuterSharedPoint$ is not strictly necessary in the model.
We apply $\RInit$ once for shared channel $\SharedPoint{4}$ and once again for shared channel $\SharedPoint{5}$ to obtain:

\begin{align*}
&\mapstostar \NuChannels\big (\\
&\Mu{\RecursionVariable} \update{\NumberRegister}{5} . \DotForall{\AcceptorIndex\in \{1,2\}}{\SendUnreliableP{s}{4}{\AcceptorIndex}{\LOneA}{\proposalNumber{\NumberRegister}{4}}}\dots \comment{= \Proposer{4}}\\
&\Or \Mu{\RecursionVariable} \update{\NumberRegister}{6} . \DotForall{\AcceptorIndex\in \{2,3\}}{\SendUnreliableP{r}{4}{\AcceptorIndex}{\LOneA}{\proposalNumber{\NumberRegister}{5}}}\dots \comment{= \Proposer{5}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{1}{\LOneA}{\bot}{n'}.\If{\dots}
    \Or \Mu{\RecursionVariable} \ReceiveUnreliableP{r}{4}{1}{\LOneA}{\bot}{n'}.\If{\dots}
} \comment{= \Acceptor{1}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{2}{\LOneA}{\bot}{n'}.\If{\dots}
    \Or \Mu{\RecursionVariable} \ReceiveUnreliableP{r}{4}{2}{\LOneA}{\bot}{n'}.\If{\dots}
} \comment{= \Acceptor{2}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{3}{\LOneA}{\bot}{n'}.\If{\dots}
    \Or \Mu{\RecursionVariable} \ReceiveUnreliableP{r}{4}{3}{\LOneA}{\bot}{n'}.\If{\dots}
} \comment{= \Acceptor{3}}\\
&\Or \InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )
\end{align*}

Note that each process is shortened to only show the next few steps instead of the entire process.

\subsubsection{The Happy Path}
After applying the updates in $\Proposer{4}$ and $\Proposer{5}$ the first inter-process communication can take place.
In this case $\Proposer{5}$ communicates with $\Acceptor{2}$ and $\Acceptor{3}$.
We apply $\RUsend$ and $\RUget$ twice to send $\proposalNumber{6}{5} = 10$ to $\Acceptor{2}$ and $\Acceptor{3}$.
% corresponds to (1)

\begin{align*}
&\mapstostar
\NuChannels \big (\\
&\Mu{\RecursionVariable} \SendUnreliableP{s}{4}{1}{\LOneA}{\proposalNumber{5}{4}}.\SendUnreliableP{s}{4}{2}{\LOneA}{\proposalNumber{5}{4}}\dots \comment{= \Proposer{4}}\\
&\Or \Mu{\RecursionVariable} \ReceiveUnreliableP{r}{2}{4}{\LOneB}{\bot}{v_2}.\ReceiveUnreliableP{r}{3}{4}{\LOneB}{\bot}{v_3}\dots \comment{= \Proposer{5}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{1}{\LOneA}{\bot}{n'}.\If{\dots}
    \Or \Mu{\RecursionVariable} \ReceiveUnreliableP{r}{4}{1}{\LOneA}{\bot}{n'}.\If{\dots}
} \comment{=\Acceptor{1}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{2}{\LOneA}{\bot}{n'}.\If{\dots}
    \Or \Mu{\RecursionVariable} \If{10 = \bot} \Then{\SendUnreliableP{s}{2}{4}{\LOneB}{\bot}.\PaTwo} \Else{\dots}
} \comment{=\Acceptor{2}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{3}{\LOneA}{\bot}{n'}.\If{\dots}
    \Or \Mu{\RecursionVariable} \If{10 = \bot} \Then{\SendUnreliableP{s}{3}{4}{\LOneB}{\bot}.\PaTwo} \Else{\dots}
} \comment{=\Acceptor{3}}\\
&\Or \InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )
\end{align*}

Since $10 \neq \bot$ both $\Acceptor{2}$ and $\Acceptor{3}$ move into their respective $\Else$ branches by applying $\RIfF$.

\begin{align*}
&\mapstostar \NuChannels \big (\\
&\Mu{\RecursionVariable} \SendUnreliableP{s}{4}{1}{\LOneA}{\proposalNumber{5}{4}}.\SendUnreliableP{s}{4}{2}{\LOneA}{\proposalNumber{5}{4}}\dots \comment{= \Proposer{4}}\\
&\Or \Mu{\RecursionVariable} \ReceiveUnreliableP{r}{2}{4}{\LOneB}{\bot}{v_2}.\ReceiveUnreliableP{r}{3}{4}{\LOneB}{\bot}{v_3}\dots \comment{= \Proposer{5}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{1}{\LOneA}{\bot}{n'}.\If{\dots}
    \Or \Mu{\RecursionVariable} \ReceiveUnreliableP{r}{4}{1}{\LOneA}{\bot}{n'}.\If{\dots}
} \comment{=\Acceptor{1}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{2}{\LOneA}{\bot}{n'}.\If{\dots}
    \Or \Mu{\RecursionVariable} \If{\greaterThan{10}{\Nothing}} \Then{\dots} \Else{\dots}
} \comment{=\Acceptor{2}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{3}{\LOneA}{\bot}{n'}.\If{\dots}
    \Or \Mu{\RecursionVariable} \If{\greaterThan{10}{\Nothing}} \Then{\dots} \Else{\dots}
} \comment{=\Acceptor{3}}\\
&\Or \InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )
\end{align*}

Because $\greaterThan{10}{\Nothing}$ returns $\True$, $\Acceptor{2}$ and $\Acceptor{3}$ move into their respective $\Then$ branches by applying $\RIfT$.
After executing $\update{\NumberRegister}{10}$ with $\RSideEffect$, $\Acceptor{2}$ and $\Acceptor{3}$ are ready to send their responses to $\Proposer{5}$.

% A1: n=Nothing, pr=Nothing
% A2: n=10, pr=Nothing
% A3: n=10, pr=Nothing
\begin{align*}
&\mapstostar \NuChannels \big (\\
&\Mu{\RecursionVariable} \SendUnreliableP{s}{4}{1}{\LOneA}{\proposalNumber{5}{4}}.\SendUnreliableP{s}{4}{2}{\LOneA}{\proposalNumber{5}{4}}\dots \comment{= \Proposer{4}}\\
&\Or \Mu{\RecursionVariable} \ReceiveUnreliableP{r}{2}{4}{\LOneB}{\bot}{v_2}.\ReceiveUnreliableP{r}{3}{4}{\LOneB}{\bot}{v_3}\dots \comment{= \Proposer{5}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{1}{\LOneA}{\bot}{n'}.\If{\dots}
    \Or \Mu{\RecursionVariable} \ReceiveUnreliableP{r}{4}{1}{\LOneA}{\bot}{n'}.\If{\dots}
} \comment{= \Acceptor{1}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{2}{\LOneA}{\bot}{n'}.\If{\dots}
    \Or \Mu{\RecursionVariable} \SendUnreliableP{r}{2}{4}{\LOneB}{\Promise{\Nothing}}.\PaTwo
} \comment{= \Acceptor{2}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{3}{\LOneA}{\bot}{n'}.\If{\dots}
    \Or \Mu{\RecursionVariable} \SendUnreliableP{r}{3}{4}{\LOneB}{\Promise{\Nothing}}.\PaTwo
} \comment{= \Acceptor{3}}\\
&\Or \InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )
\end{align*}

We apply $\RUsend$ and $\RUget$ twice to do just that.
Note that we also apply $\RUskip$, $\RIfT$, and then \RUsend to $\Acceptor{1}$ and then $\Rml$ to $\Proposer{5}$ to discard the dummy message $\bot$.
All three acceptors move into $\PaTwo$.
% corresponds to (2) - (3)

\begin{align*}
&\mapstostar \NuChannels \big (\\
&\Mu{\RecursionVariable} \SendUnreliableP{s}{4}{1}{\LOneA}{\proposalNumber{5}{4}}.\SendUnreliableP{s}{4}{2}{\LOneA}{\proposalNumber{5}{4}}\dots \comment{= \Proposer{4}}\\
&\Or \Mu{\RecursionVariable} \SendWeaklyP{r}{4}{\Curly{2,3}}{\Accept}{\SendUnreliableP{r}{4}{2}{\LTwoA}{\ProposalC{10}{\ABC}}}\dots \comment{= \Proposer{5}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \dots
    \Or \Mu{\RecursionVariable} \ReceiveWeaklyP{r}{4}{1}{\BeginPaCont}
} \comment{= \Acceptor{1}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \dots
    \Or \Mu{\RecursionVariable} \ReceiveWeaklyP{r}{4}{2}{\BeginPaCont}
} \comment{= \Acceptor{2}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \dots
    \Or \Mu{\RecursionVariable} \ReceiveWeaklyP{r}{4}{3}{\BeginPaCont}
} \comment{= \Acceptor{3}}\\
&\Or \InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )
\end{align*}

$\Proposer{5}$ broadcasts its decision $\Accept$ to $\Acceptor{2}$ and $\Acceptor{3}$.
By applying $\RWsel$ once, $\RWbran$ twice we obtain:
% corresponds to (4)

\begin{align*}
&\mapstostar \NuChannels \big (\\
&\Mu{\RecursionVariable} \SendUnreliableP{s}{4}{1}{\LOneA}{\proposalNumber{5}{4}}.\SendUnreliableP{s}{4}{2}{\LOneA}{\proposalNumber{5}{4}}\dots \comment{= \Proposer{4}}\\
&\Or \Mu{\RecursionVariable} \SendUnreliableP{r}{4}{2}{\LTwoA}{\ProposalC{10}{\ABC}}.\SendUnreliableP{r}{4}{3}{\LTwoA}{\ProposalC{10}{\ABC}}\dots \comment{= \Proposer{5}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \dots
    \Or \Mu{\RecursionVariable} \ReceiveWeaklyP{r}{4}{1}{\BeginPaCont}
} \comment{= \Acceptor{1}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \dots
    \Or \Mu{\RecursionVariable} \ReceiveUnreliableP{r}{4}{2}{\LTwoA}{\bot}{pr'}.\If{\dots}
} \comment{= \Acceptor{2}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \dots
    \Or \Mu{\RecursionVariable} \ReceiveUnreliableP{r}{4}{3}{\LTwoA}{\bot}{pr'}.\If{\dots}
} \comment{= \Acceptor{3}}\\
&\Or \InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )
\end{align*}

Now $\Proposer{5}$ can send its proposal to $\Acceptor{2}$ and $\Acceptor{3}$ and terminate.
$\Proposer{4}$ will be the new leader.
To do so we apply $\RUsend$ and $\RUget$ twice.
$\Acceptor{2}$ and $\Acceptor{3}$ accept the proposal and the respective subprocesses terminate.
Note that we apply $\RWskip$ in $\Acceptor{1}$ and terminate that subprocess as well.
% corresponds to (5)

\begin{align*}
&\mapstostar \NuChannels \big (\\
&\Mu{\RecursionVariable} \SendUnreliableP{s}{4}{1}{\LOneA}{\proposalNumber{5}{4}}.\SendUnreliableP{s}{4}{2}{\LOneA}{\proposalNumber{5}{4}}\dots \comment{= \Proposer{4}}\\
&\Or \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{1}{\LOneA}{\bot}{n'}.\If{\dots} \comment{= \Acceptor{1}}\\
&\Or \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{2}{\LOneA}{\bot}{n'}.\If{\dots} \comment{= \Acceptor{2}}\\
&\Or \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{3}{\LOneA}{\bot}{n'}.\If{\dots} \comment{= \Acceptor{3}}\\
&\Or \InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )
\end{align*}

At this point the registers of $\Acceptor{2}$ and $\Acceptor{3}$ hold $\NumberRegister = 10$ and $\ProposalRegister = \ProposalC{10}{\ABC}$.
$\Acceptor{1}$ has not updated its registers $\NumberRegister = \Nothing$ and $\ProposalRegister = \Nothing$.

\subsubsection{Restarting the Algorithm}
Next, $\Proposer{4}$ sends prepare requests with a proposal number less than 10, which is rejected by $\Acceptor{2}$.
$\Proposer{4}$ then decides to restart the algorithm.
We apply $\RUsend$ and $\RUget$ twice.
We also apply $\RUskip$ once in $\Acceptor{3}$.

\begin{align*}
&\mapstostar \NuChannels \big (\\
&\Mu{\RecursionVariable} \ReceiveUnreliableP{s}{1}{4}{\LOneB}{\bot}{v_1}.\ReceiveUnreliableP{s}{2}{4}{\LOneB}{\bot}{v_2}\dots \comment{= \Proposer{4}}\\
&\Or \Mu{\RecursionVariable} \If{5 = \bot} \Then{\PaTwo} \Else{\dots} \comment{= \Acceptor{1}}\\
&\Or \Mu{\RecursionVariable} \If{5 = \bot} \Then{\PaTwo} \Else{\dots} \comment{= \Acceptor{2}}\\
&\Or \Mu{\RecursionVariable} \If{\bot = \bot} \Then{\PaTwo} \Else{\dots} \comment{= \Acceptor{3}}\\
&\Or \InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )
\end{align*}

We can apply \RIfT to \Acceptor{3} and \RIfF to \Acceptor{1} and \Acceptor{2}.
$\Acceptor{3}$ moves directly to $\PaTwo$ whereas $\Acceptor{1}$ and $\Acceptor{2}$ send their responses to $\Proposer{4}$ before moving to $\PaTwo$.
$\Acceptor{1}$ also updates its register $\NumberRegister = 5$ via $\RSideEffect$.

% A1: n=5, pr=Nothing
% A2: n=10, pr=Proposal 10 abc
% A3: n=10, pr=Proposal 10 abc
\begin{align*}
&\mapstostar \NuChannels \big (\\
&\Mu{\RecursionVariable} \ReceiveUnreliableP{s}{1}{4}{\LOneB}{\bot}{v_1}.\ReceiveUnreliableP{s}{2}{4}{\LOneB}{\bot}{v_2}\dots \comment{= \Proposer{4}}\\
&\Or \Mu{\RecursionVariable} \SendUnreliableP{s}{1}{4}{\LOneB}{\Promise{\Nothing}}.\PaTwo \comment{= \Acceptor{1}}\\
&\Or \Mu{\RecursionVariable} \SendUnreliableP{s}{2}{4}{\LOneB}{\Nack{10}}.\PaTwo \comment{= \Acceptor{2}}\\
&\Or \Mu{\RecursionVariable} \ReceiveWeaklyP{r}{4}{3}{\BeginPaCont} \comment{= \Acceptor{3}}\\
&\Or \InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )
\end{align*}

Applying $\RUsend$ and $\RUget$ twice and \RIfT in $\Proposer{4}$ yields:

\begin{align*}
&\mapstostar \NuChannels \big (\\
&\Mu{\RecursionVariable} \SendWeaklyP{s}{4}{\Curly{1,2}}{\Restart}{\RecursionVariable} \comment{= \Proposer{4}}\\
&\Or \Mu{\RecursionVariable} \ReceiveWeaklyP{s}{4}{1}{\BeginPaCont} \comment{= \Acceptor{1}}\\
&\Or \Mu{\RecursionVariable} \ReceiveWeaklyP{s}{4}{1}{\BeginPaCont} \comment{= \Acceptor{2}}\\
&\Or \Mu{\RecursionVariable} \ReceiveWeaklyP{r}{4}{3}{\BeginPaCont} \comment{= \Acceptor{3}}\\
&\Or \InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )
\end{align*}

$\Proposer{4}$ sends its decision to restart the algorithm to $\Acceptor{1}$ and $\Acceptor{2}$ by applying $\RWsel$ once and $\RWbran$ twice.
$\Acceptor{3}$ terminates after applying $\RWskip$.

\begin{align*}
&\mapstostar \NuChannels \big (\\
&\Mu{\RecursionVariable} \SendUnreliableP{s}{4}{1}{\LOneA}{15}.\SendUnreliableP{s}{4}{2}{\LOneA}{15}\dots \comment{= \Proposer{4}}\\
&\Or \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{1}{\LOneA}{\bot}{n'}.\If{\dots} \comment{= \Acceptor{1}}\\
&\Or \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{2}{\LOneA}{\bot}{n'}.\If{\dots} \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )
\end{align*}

\subsubsection{The Happy Path, Again}

This time $\Proposer{4}$ uses a high enough proposal number so that $\Acceptor{1}$ and $\Acceptor{2}$ both promise not to accept any proposal numbered less than that.
By applying $\RUsend$ in the remaining proposer and $\RUget$, $\RIfF$, $\RIfT$, $\RSideEffect$ in the remaining acceptors we arrive at:

% A1: n=15, pr=Nothing
% A2: n=15, pr=Proposal 10 abc
% A3: n=10, pr=Proposal 10 abc
\begin{align*}
&\mapstostar \NuChannels \big (\\
&\Mu{\RecursionVariable} \ReceiveUnreliableP{s}{1}{4}{\LOneB}{\bot}{v_1}.\ReceiveUnreliableP{s}{2}{4}{\LOneB}{\bot}{v_2}.\If{\dots} \comment{= \Proposer{4}}\\
&\Or \Mu{\RecursionVariable} \SendUnreliableP{s}{1}{4}{\LOneB}{\Promise{\Nothing}}.\PaTwo \comment{= \Acceptor{1}}\\
&\Or \Mu{\RecursionVariable} \SendUnreliableP{s}{2}{4}{\LOneB}{\Promise{\Paren{\ProposalC{10}{abc}}}}.\PaTwo \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )
\end{align*}

Note that, at this point, $\Acceptor{1}$ and $\Acceptor{2}$ have updated their respective registers $\NumberRegister$ to $15$.

Because $\Acceptor{2}$ has already accepted a proposal, it responds to $\Proposer{4}$'s prepare request with that proposal.
Twice more we apply $\RUsend$, $\RUget$, and $\RIfF$ in $\Proposer{4}$ to obtain:

% A1: n=15, pr=Nothing
% A2: n=15, pr=Proposal 10 abc
% A3: n=10, pr=Proposal 10 abc
\begin{align*}
&\mapstostar \NuChannels \big (\\
&\Mu{\RecursionVariable} \SendWeaklyP{s}{4}{\Curly{1,2}}{\Accept}{\dots} \comment{= \Proposer{4}}\\
&\Or \Mu{\RecursionVariable} \ReceiveWeaklyP{s}{4}{1}{\BeginPaCont} \comment{= \Acceptor{1}}\\
&\Or \Mu{\RecursionVariable} \ReceiveWeaklyP{s}{4}{1}{\BeginPaCont} \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )
\end{align*}

$\Proposer{4}$ has received enough promises to send its own proposal.
The value for that proposal is $\ABC$ because that is the value of the highest-numbered proposal $\Proposer{4}$ received as a response to its prepare request.
First, we apply $\RWsel$ and $\RWbran$.

% A1: n=15, pr=Nothing
% A2: n=15, pr=Proposal 10 abc
% A3: n=10, pr=Proposal 10 abc
\begin{align*}
&\mapstostar \NuChannels \big (\\
&\Mu{\RecursionVariable} \SendUnreliableP{s}{4}{1}{\LTwoA}{\ProposalC{15}{\ABC}}.
\SendUnreliableP{s}{4}{2}{\LTwoA}{\ProposalC{15}{\ABC}}.\End \comment{= \Proposer{4}}\\
&\Or \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{1}{\LTwoA}{\bot}{pr'}.\If{\dots}\comment{= \Acceptor{1}}\\
&\Or \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{4}{2}{\LTwoA}{\bot}{pr'}.\If{\dots}\comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )
\end{align*}

Then we apply $\RUsend$ and $\RUget$ to send the proposal from $\Proposer{4}$ to the acceptors.
$\Proposer{4}$ terminates.
We apply $\RIfF$, $\RIfT$, and $\RSideEffect$ twice to the acceptors.
With that, \Acceptor{1} and \Acceptor{2} have accepted \Proposer{4}'s proposal.

% A1: n=15, pr=Proposal 15 abc
% A2: n=15, pr=Proposal 15 abc
% A3: n=10, pr=Proposal 10 abc
\[\mapstostar
\NuChannels \big (\InnerSessionQueues{s}
\Or \InnerSessionQueues{r}
\Or \OuterSessionQueues
\big )\]

Afterwards $\Acceptor{1}$ and $\Acceptor{2}$ have $\NumberRegister =  15$ and $\ProposalRegister =  \ProposalC{15}{\ABC}$ and $\Acceptor{3}$ has $\NumberRegister =  10$ and $\ProposalRegister =  \ProposalC{10}{\ABC}$.
All acceptors have accepted the value $\ABC$.
