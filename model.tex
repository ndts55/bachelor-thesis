\chapter{Model}
First, we specify some sorts with which we can then define the global type.
Afterwards, we define the processes for the proposer and the acceptor.
Finally, we will study an example run of the model.

\section{Sorts}
Sorts are basic data types.
We assume the following sorts.

First, we have $\Bool$ which we define as a set.

\[\Bool = \Curly{\True, \False}\]

Second, we assume a set of proposable values $\Value$.
This set contains at least two elements of any kind.
For example, $\Value=\Curly{\ABC, \operatorname{def}, \ldots, \operatorname{vwx}, \operatorname{yz}}$.

Then, we have some sorts which we define using a grammar.
Each of these definitions contains a type parameter, which is a variable ranging over types.
In this case the type parameter in each definition is called $a$.

\[\Maybe{a} = \Just{a} \Or \Nothing\]

A value of type $\Maybe{a}$ can have the form $\Just{a}$ or $\Nothing$.
Some examples include $\Just{4}$ of type $\Maybe{\mathbb{N}}$, $\Just{\False}$ of type $\Maybe{\Bool}$, and $\Nothing$.
$\Nothing$ itself does not dictate an exact type because its definition does not include the type parameter $a$.
The type is underspecified and is specified manually or through the context in which $\Nothing$ is used.
It can be of type $\Maybe{\mathbb{N}}$, $\Maybe{\Bool}$, or $\Maybe{b}$ for any other type $b$.
We use $\Maybe{a}$ where optional values are needed.

\[\Proposal{a} = \ProposalC{\mathbb{N}}{a}\]

$\Proposal{a}$ only has one possible form, which is $\ProposalC{\mathbb{N}}{a}$.
A proposal contains its proposal number of type $\mathbb{N}$ and its value of type $a$.
Again, $a$ is a variable ranging over types.
An example for a value of type $\Proposal{\Bool}$ could be $\ProposalC{1}{\True}$ and an example for a value of type $\Proposal{\Paren{\Maybe{\mathbb{N}}}}$ could be $\ProposalC{1}{\Paren{\Just{1}}}$.
This sort models the proposals issued by the proposers in phase $\PTwoA$.

\[\Promise{a} = \Promise{\Paren{\Maybe{\Paren{\Proposal{a}}}}} \Or \Nack\]

$\Promise{a}$ has two possible forms.
$\Promise{\Paren{\Maybe{\Paren{\Proposal{a}}}}}$ and $\Nack$.
Possible values include $\Nack$ and $\Promise{\Paren{\Just{\Paren{\ProposalC{1}{{\False}}}}}}$ of type $\Promise{\mathbb{\Bool}}$.
The actual type of $\Nack$, much like that of $\Nothing$, is underspecified.
Again, we have to specify the exact type manually or through context.

In phase $\POneB$ the acceptors respond to the proposers prepare request with a value of type $\Promise{\Value}$.
The prepare request contains a number $n$.
The acceptors may respond to the prepare request with a promise to not accept any proposal numbered less than $n$ or with a rejection.
In the first case the acceptor's response optionally includes the last proposal it accepted, if available, and is of the form $\Promise{\Paren{\Maybe{\Paren{\Proposal{a}}}}}$.
In the second case it is of the form $\Nack$.

\section{Global Type}
Since each proposer initiates its own session the global type can be defined for one proposer $\ProcessIndexK$ and a corresponding quorum $\AQ_{\ProcessIndexK}$.
Let $\ProposerRole = |\AQ_{\ProcessIndexK}| + 1$ and $\QRoles = \Curly{1,\ldots,|\AQ_{\ProcessIndexK}|}$.

The last phase of Paxos contains no inter-process communication, so it is not modeled in the global type.

We observe that the proposer of a session always uses the highest role $\ProposerRole$ in its session and communicates with all roles from $1$ to $\ProposerRole - 1$.

\begin{align*}
    \IndexedGlobalType{\ProcessIndexK} =&
        \Mu{\RecursionVariableType}
        \DotForall{
            \AcceptorRole \in \QRoles
        }{
            \SendUnreliableG{\ProposerRole}{\AcceptorRole}{\LOneA}{\mathbb{N}}
        } .
        \DotForall{
            \AcceptorRole \in \QRoles
        }{
            \SendUnreliableG{\AcceptorRole}{\ProposerRole}{\LOneB}{\Promise{\Value}}
        } .\\
    &
        \SendWeaklyG{\ProposerRole}{\QRoles}{
            \Accept.
                \DotForall{
                    \AcceptorRole \in \QRoles
                }{
                    \SendUnreliableG{\ProposerRole}{\AcceptorRole}{\LTwoA}{\Proposal{\Value}}
                }.
                \End
            \oplus \Restart.
                \RecursionVariableType
            \oplus \Abort.
                \End
        }
\end{align*}

We can distinguish the individual phases of the Paxos algorithm by the labels $\LOneA$, $\LOneB$, and $\LTwoA$.

In the first two steps, $\POneA$ and $\POneB$, the proposer sends its proposal number to each acceptor in $\AQ_{\ProposerRole}$ and listens for their responses.
In step $\PTwoA$ the proposer decides whether to send an $\Accept$ or $\Restart$ message to restart the algorithm.
This decision is broadcast to all acceptors in $\AQ_{\ProposerRole}$.
Should the proposer crash the algorithm ends for this particular proposer and the subprocesses of the acceptors in its quorum.

\section{Functions}
We define some functions which we use in the next section to define the processes.

\[\proposalNumberName : \mathbb{N} \times \mathbb{N} \to \mathbb{N}\]

$\proposalNumber{\NumberRegister}{p}$ returns a proposal number for proposer $p$ when given a natural number $n$.
It is used to pick a number for the prepare request in phase $\POneA$, which is also used in phase $\PTwoA$ in the actual proposal.
We have two requirements for this function.

Let $\SetOfProposers$ be the set of proposers.

\[\forall p,q \in \SetOfProposers . \forall n,m \in \mathbb{N}: p \neq q \to \proposalNumber{\NumberRegister}{p} \neq \proposalNumber{m}{q}\]

Different proposers pick their proposal numbers from disjoint sets of numbers.
This way different proposers never issue a proposal with the same proposal number.

\[\forall p \in \SetOfProposers . \forall n,m \in \mathbb{N}: n > m \to \proposalNumber{\NumberRegister}{p} > \proposalNumber{m}{p}\]

We require $\proposalNumber{\NumberRegister}{p}$ to be strictly increasing for each proposer $p$ so every proposer uses a higher proposal number than any it has already used.

\[\promiseValueName : \List{\Promise{a}} \to a\]

$\promiseValue{ps}$ returns a fresh value if none of the promises in $ps$ contain a value.
Otherwise, the best value is returned. Usually, that is the value with the highest associated proposal number.
A promise contains a value $v$ if it is of the form $\Promise{\Just{v}}$.
With this function we can model the picking of a value for a proposal in phase $\PTwoA$.

\begin{align*}
&\anyNackName : \List{\Promise{a}} \to \Bool\\
&\anyNack{\EmptyList} = \False\\
&\anyNack{\ListPattern{\Nack}{\Wildcard}} = \True\\
&\anyNack{\ListPattern{\Promise{\Wildcard}}{xs}} = \anyNack{xs}
\end{align*}

$\anyNack{ps}$ returns $\True$ if the list contains at least one promise of the form $\Nack$.
Otherwise, it returns $\False$.

\begin{align*}
&\promiseCountName : \List{\Promise{a}} \to \mathbb{N}\\
&\promiseCount{\EmptyList} = 0\\
&\promiseCount{\ListPattern{\Promise{\Wildcard}}{xs}} = 1 + \promiseCount{xs}\\
&\promiseCount{\ListPattern{\Nack}{xs}} = \promiseCount{xs}
\end{align*}

$\promiseCount{ps}$ takes a list of promises $ps$ and counts the number of promises that have the form $\Promise{m}$.

$\anyNack{ps}$ and $\promiseCount{ps}$ are used in the proposer to decide which branch to take in phase $\PTwoA$.

\begin{align*}    
&\greaterThanName : a \times \Maybe{a} \to \Bool\\
&\greaterThan{\Wildcard}{\Nothing} = \True\\
&\greaterThan{a}{\Just{b}} = a > b
\end{align*}

\begin{align*}
&\greaterEqualName : a \times \Maybe{a} \to \Bool\\
&\greaterEqual{\Wildcard}{\Nothing} = \True\\
&\greaterEqual{a}{\Just{b}} = a \ge b
\end{align*}

\begin{align*}    
&\nFromProposalName : \Proposal{a} \to \mathbb{N}\\
&\nFromProposal{\ProposalC{n}{\Wildcard}} = n
\end{align*}

$\nFromProposal{p}$ retrieves the proposal number $n$ inside proposal $p$, which has the form $\ProposalC{n}{pr}$.

$\nFromProposal{p}$, $\greaterThan{a}{ma}$, and $\greaterEqual{a}{ma}$ are used to extract and compare proposal numbers in phase $\PTwoB$ of the acceptor.

\[\genAqName : \mathbb{N} \times \mathbb{N} \times \mathbb{N} \to \List{\mathbb{N}}\]

$\genAq{\ProposerRole}{\AcceptorCount}{\ProposerCount}$ returns a randomly selected set $\AQ$ with $\AQ \subseteq A = \Curly{1, \ldots, \AcceptorCount}$ and $|\AQ| > \frac{|A|}{2}$ as a sorted list.
$\AQ$ consists of any majority of acceptors.
In Paxos a majority of acceptors forms a quorum, \ie an accepting set with which a value can be chosen \cite{Lamport06}.
We use this function when initiating the proposers to give them a quorum with which they communicate.

\begin{align*}
&\positionHelperName : \mathbb{N} \times \mathbb{N} \times \List{\mathbb{N}} \to \mathbb{N}\\
&\positionHelper{n}{c}{\ListPattern{n}{\Wildcard}} = c + 1\\
&\positionHelper{n}{c}{\ListPattern{x}{xs}} = \positionHelper{n}{c + 1}{xs}\\
&\positionHelper{\Wildcard}{\Wildcard}{\EmptyList} = 0
\end{align*}

\begin{align*}
&\positionName : \mathbb{N} \times \List{\mathbb{N}} \to \mathbb{N}\\
&\position{n}{xs} = \positionHelper{n}{0}{xs}
\end{align*}

$\position{n}{xs}$ calculates the position of the first occurrence of $n$ in $xs$.
It uses $\positionHelper{n}{c}{xs}$, which recursively checks each element of the list.
$\positionHelper{n}{c}{xs}$ and thus $\position{n}{xs}$ return $0$ in cases where $n$ is not an element of $xs$.
We observe that $1 \leq \position{n}{xs} \leq |xs|$ for every list $xs$ and $n \in xs$.

\section{Processes}
\subsection{System Initialization}
Let $\AcceptorCount$ and $\ProposerCount$ be the number of acceptors and proposers respectively.
We require that $\AcceptorCount > 0$ and $\ProposerCount > 0$.
Let $\AQ_{\ProcessIndexK} = \genAq{\ProcessIndexK}{\AcceptorCount}{\ProposerCount}$ be the quorum and $\NumberRegister_{\ProcessIndexK}$ a register for proposer with process index $\ProcessIndexK$ where $\AcceptorCount + 1 \leq \ProcessIndexK \leq \AcceptorCount + \ProposerCount$.
Finally, let $\NumberRegister_{\ProcessIndexJ}$ and $\ProposalRegister_{\ProcessIndexJ}$ be registers for an acceptor with process index $\ProcessIndexJ$ where $1 \leq \ProcessIndexJ \leq \AcceptorCount$.

Acceptors are initialized using process indices from 1 to $\AcceptorCount$ and proposers are initialized using process indices from $\AcceptorCount + 1$ to $\AcceptorCount + \ProposerCount$.

Each proposer consists of one process, starts their own session and communicates with its corresponding quorum.
The quorum contains the process indices of selected acceptors.

Each Acceptor consists of multiple subprocesses.
One subprocess of every acceptor in a proposer's quorum participates in that proposer's session.
Thus, a session has one proposer and multiple acceptor subprocesses.

The role of each participant in a session is given by the position of its process index in a sorted list.
The process with the smallest index has role 1, the second-smallest index has role 2, and so on.
Per definition proposers have a higher process index than any acceptor and obtain the highest role in the session.
That role is always one more than the number of acceptors in its quorum.

For example, let $\AcceptorCount = 3$ and $\ProposerCount = 2$, $\Acceptor{1}$, $\Acceptor{2}$, and $\Acceptor{3}$ are acceptors and $\Proposer{4}$ and $\Proposer{5}$ are proposers.
Let $\Proposer{5}$'s quorum be $\AQ_5 = \Bracket{2, 3}$.
$\Acceptor{2}$, $\Acceptor{3}$, and $\Proposer{5}$ participate in $\Proposer{5}$'s session.
$\Acceptor{2}$'s role is 1, because its process index 2 is the first element in $\AQ_5$.
$\Acceptor{3}$'s role is 2, because its process index 3 is the second element in $\AQ_5$.
$\Proposer{5}$'s role is $|\AQ_5| + 1 = 2 + 1 = 3$.

\begin{align*}
\Sys{\AcceptorCount}{\ProposerCount} =
&
    \SessionRequest{\OuterSharedPoint}{2}{\OuterSessionChannel}.
    \PpInit{
        \AcceptorCount + \ProposerCount,
        |\AQ_{\AcceptorCount + \ProposerCount}| + 1,
        \Curly{1,\ldots,|\AQ_{\AcceptorCount + \ProposerCount}|},
        \AcceptorCount,
        \NumberRegister_{\AcceptorCount + \ProposerCount},
        \EmptyList
    }\\
&\Or
    \SessionAccept{\OuterSharedPoint}{1}{\OuterSessionChannel}.
    \ParallelFor{\AcceptorCount + 1 \leq \ProcessIndexK < \AcceptorCount + \ProposerCount} \PpInit{
        \ProcessIndexK,
        |\AQ_{\ProcessIndexK}| + 1,
        \Curly{1,\ldots,|\AQ_{\ProcessIndexK}|},
        \AcceptorCount,
        \NumberRegister_{\ProcessIndexK},
        \EmptyList
    }\\
&\Or
    \ParallelFor{1 \leq \ProcessIndexJ \leq \AcceptorCount}
    \PaInit{
        \ProcessIndexJ,
        \AcceptorCount,
        \ProposerCount,
        \NumberRegister_{\ProcessIndexJ},
        \ProposalRegister_{\ProcessIndexJ}
    }
\\\\
\PpInit{
    \ProcessIndexK,
    \ProposerRole,
    \QRoles,
    \AcceptorCount,
    \NumberRegister_{\ProcessIndexK},
    \VectorV
} =
&
    \SessionRequest{\SharedPoint{\ProcessIndexK}}{\ProposerRole}{\SessionChannel} .
    \PpOne{
        \SessionChannel,
        \ProcessIndexK,
        \ProposerRole,
        \QRoles,
        \AcceptorCount,
        \NumberRegister_{\ProcessIndexK},
        \VectorV
    }
\\\\
\PaInit{
    \ProcessIndexJ,
    \AcceptorCount,
    \ProposerCount,
    \NumberRegister_{\ProcessIndexJ},
    \ProposalRegister_{\ProcessIndexJ}
} =
&
    \ParallelFor{\AcceptorCount + 1 \leq \ProcessIndexK \leq \AcceptorCount + \ProposerCount}\big(\\
&
    \If \ProcessIndexJ\notin\AQ_{\ProcessIndexK}\\
&
    \Then \End\\
&
    \Else
        \SessionAccept{\SharedPoint{\ProcessIndexK}}{\position{\ProcessIndexJ}{\AQ_{\ProcessIndexK}}}{\SessionChannel}.
        \PaOne{
            \SessionChannel,
            \position{\ProcessIndexJ}{\AQ_{\ProcessIndexK}},
            |\AQ_{\ProcessIndexK}| + 1,
            \NumberRegister_{\ProcessIndexJ},
            \ProposalRegister_{\ProcessIndexJ}
        }
\big)
\end{align*}

$\Sys{\AcceptorCount}{\ProposerCount}$, $\PpInit{
    \ProcessIndexK,
    \ProposerRole,
    \QRoles,
    \AcceptorCount,
    \NumberRegister_{\ProcessIndexK},
    \VectorV
}$, and $\PaInit{
    \ProcessIndexJ,
    \AcceptorCount,
    \ProposerCount,
    \NumberRegister_{\ProcessIndexJ},
    \ProposalRegister_{\ProcessIndexJ}
}$ describe the system initialization.

An outer session is created through shared channel $\OuterSharedPoint$ and the acceptors and proposers are initialized.

$\PpInit{
    \ProcessIndexK,
    \ProposerRole,
    \QRoles,
    \AcceptorCount,
    \NumberRegister_{\ProcessIndexK},
    \VectorV
}$ is initialized with the proposer's process index $\ProcessIndexK$, the proposer's role $\ProposerRole$ in its session, a set of roles $\QRoles$,the number of acceptors $\AcceptorCount$, register $\NumberRegister_{\ProcessIndexK}$, and a vector $\VectorV$.
$\ProcessIndexK$ uniquely identifies a proposer when calling $\proposalNumberName$.
The proposer's role $\ProposerRole$ is initialized with $|\AQ_{\ProcessIndexK}| + 1$.
The set of roles $\QRoles$ contains the roles the acceptors in $\AQ_{\ProcessIndexK}$ will use in the proposer's session.
Register $\NumberRegister_{\ProcessIndexK}$ is implemented as stable storage, which is preserved during failures.
It is used as a counter to make sure every run of the Paxos algorithm uses a higher proposal number.
$\VectorV$ is used in the proposer to collect and evaluate the responses from the acceptors.
It is always initialized with an empty list $\EmptyList$.
Shared channel $\SharedPoint{\ProcessIndexK}$ is used to initiate a session.
Afterwards, the process behaves like $\PpOne{
    \SessionChannel,
    \ProcessIndexK,
    \ProposerRole,
    \QRoles,
    \AcceptorCount,
    \NumberRegister_{\ProcessIndexK},
    \VectorV
}$.
We assume a mechanism for electing a distinguished proposer, which acts as the leader \cite{Lamport01}.
The leader is the only proposer that can try issuing proposers.
A new leader is elected via the same mechanism when the previous leader terminates or crashes.

$\PaInit{
    \ProcessIndexJ,
    \AcceptorCount,
    \ProposerCount,
    \NumberRegister_{\ProcessIndexJ},
    \ProposalRegister_{\ProcessIndexJ}
}$ is initialized with the acceptor's process index $\ProcessIndexJ$, the number of acceptors $\AcceptorCount$, the number of proposers $\ProposerCount$, initial knowledge for the highest promised proposal number in register $\NumberRegister_{\ProcessIndexJ}$, if available, and initial knowledge for the most recently accepted proposal in register $\ProposalRegister_{\ProcessIndexJ}$, if available.
$\NumberRegister_{\ProcessIndexJ}$ holds a value of type $\Maybe{\mathbb{N}}$ and $\ProposalRegister_{\ProcessIndexJ}$ holds a value of type $\Maybe{\Paren{\Proposal{\Value}}}$ thus both can contain $\Nothing$.
We assume both registers are implemented via stable storage, which is preserved during failures.
The proposers' session requests are accepted in separate subprocesses.
These subprocesses run parallel to each other but still access the same registers $\NumberRegister_{\ProcessIndexJ}$ and $\ProposalRegister_{\ProcessIndexJ}$.
We observe that each subprocess in an acceptor accesses a different channel $\SessionChannel$, since it is generated by the proposer when its session request is accepted.
Note that the role of an acceptor's subprocess is the position of the acceptor's process index in the corresponding proposer's quorum.
Afterwards, each subprocess behaves like $\PaOne{
    \SessionChannel,
    \AcceptorRole,
    \ProposerRole,
    \NumberRegister_{\ProcessIndexJ},
    \ProposalRegister_{\ProcessIndexJ}
}$.

\subsection{Proposer}
To define the proposer and the acceptor we introduce a function $\update{r}{v}$ which replaces the value inside register $r$ with $v$.
We use this function to update the registers of the processes.

\begin{align*}
\PpOne{
    \SessionChannel,
    \ProcessIndexK,
    \ProposerRole,
    \QRoles,
    \AcceptorCount,
    \NumberRegister_{\ProcessIndexK},
    \VectorV
} =
&
    \Mu{\RecursionVariable}
    \update{\NumberRegister_{\ProcessIndexK}}{\NumberRegister_{\ProcessIndexK} + 1} .\\
&
    \DotForall{
       \AcceptorRole \in \QRoles
    }{
        \SendUnreliableP{\SessionChannel}{\ProposerRole}{\AcceptorRole}{\LOneA}{\proposalNumber{\NumberRegister_{\ProcessIndexK}}{\ProcessIndexK}}
    }.\\
&
    \DotForall{
        \AcceptorRole \in \QRoles
    }{
        \ReceiveUnreliableP{\SessionChannel}{\ProposerRole}{\AcceptorRole}{\LOneB}{\bot}{v_{\AcceptorRole}}
    } .\\
&
    \If 
        \anyNack{\VectorV}
        \tOr
        \Paren{\promiseCount{\VectorV} < \ceil{\frac{\AcceptorCount + 1}{2}}}
    \\
&
    \Then \SendWeaklyP{\SessionChannel}{\ProposerRole}{\QRoles}{\Restart}.
    \RecursionVariable\\
&
    \Else\\
&\Indent{1}
    \SendWeaklyP{\SessionChannel}{\ProposerRole}{\QRoles}{\Accept}.\\
&\Indent{1}
    \DotForall{\AcceptorRole \in \QRoles}{
        \SendUnreliableP{\SessionChannel}{\ProposerRole}{\AcceptorRole}{\LTwoA}{
            \ProposalC{
                \Paren{\proposalNumber{\NumberRegister_{\ProcessIndexK}}{\ProcessIndexK}}
            }{
                \Paren{\promiseValue{\VectorV}}
            }
        }
    }
    .\End
\end{align*}

At the start of the recursion the value in $\NumberRegister$ is incremented to make sure every run of the recursion uses a higher proposal number.
The proposal number is sent to every acceptor in $\AQ$ and their replies are gathered in $\VectorV$ through $v_{\AcceptorRole}$.
The minimum number of acceptors needed to form a majority is $\ceil{\frac{\AcceptorCount + 1}{2}}$.
If any $\Nack$ was received or the number of $\Promise{y}$ received is less than that needed for the majority the proposer restarts the algorithm.
Otherwise, the proposer sends its proposal to the acceptors and terminates.

\subsection{Acceptor}
\begin{align*}
\PaOne{
    \SessionChannel,
    \AcceptorRole,
    \ProposerRole,
    \NumberRegister_{\ProcessIndexJ},
    \ProposalRegister_{\ProcessIndexJ}
} =
&
    \Mu{\RecursionVariable}
    \ReceiveUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneA}{\bot}{n'}.
    \\
&
    \If n' = \bot
    \\
&
    \Then
        \SendUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneB}{\bot}.
        \PaTwo{
            \SessionChannel,
            \AcceptorRole,
            \ProposerRole,
            \NumberRegister_{\ProcessIndexJ},
            \ProposalRegister_{\ProcessIndexJ}
        }
    \\
&
    \Else \big(\\
&\Indent{1}
    \If \greaterThan{n'}{\NumberRegister_{\ProcessIndexJ}}
    \\
&\Indent{1}
    \Then
        \update{\NumberRegister_{\ProcessIndexJ}}{\Just{n'}}.
        \SendUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneB}{\Promise{\ProposalRegister}}.
        \PaTwo{
            \SessionChannel,
            \AcceptorRole,
            \ProposerRole,
            \NumberRegister_{\ProcessIndexJ},
            \ProposalRegister_{\ProcessIndexJ}
        }
        \\
&\Indent{1}
    \Else
        \SendUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneB}{\Nack}.
        \PaTwo{
            \SessionChannel,
            \AcceptorRole,
            \ProposerRole,
            \NumberRegister_{\ProcessIndexJ},
            \ProposalRegister_{\ProcessIndexJ}
        }
\big )
\end{align*}

\begin{align*}
\PaTwo{
    \SessionChannel,
    \AcceptorRole,
    \ProposerRole,
    \NumberRegister_{\ProcessIndexJ},
    \ProposalRegister_{\ProcessIndexJ}
} =
    \ReceiveWeaklyP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{
    \Accept.
        \PaThree{
            \SessionChannel,
            \AcceptorRole,
            \ProposerRole,
            \NumberRegister_{\ProcessIndexJ},
            \ProposalRegister_{\ProcessIndexJ}
        }
    \oplus \Restart.\RecursionVariable
    \oplus \Abort.\End
}
\end{align*}
% TODO Convert this into just one align* to align on =? Only if PaTwo and PaThree are on one page.
\begin{align*}
\PaThree{
    \SessionChannel,
    \AcceptorRole,
    \ProposerRole,
    \NumberRegister_{\ProcessIndexJ},
    \ProposalRegister_{\ProcessIndexJ}
} =
&
    \ReceiveUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LTwoA}{\bot}{pr'}.\\
&
    \If pr' = \bot \;\Then \End\\
&
    \Else
\big(
    \\
&\Indent{1}
    \If \greaterEqual{\nFromProposal{pr'}}{\NumberRegister_{\ProcessIndexJ}}\\
&\Indent{1}
    \Then
        \update{\ProposalRegister_{\ProcessIndexJ}}{\Just{pr'}}.
        \update{\NumberRegister_{\ProcessIndexJ}}{\Just{\Paren{\nFromProposal{pr'}}}}.
        \End\\
&\Indent{1}
    \Else \End
\big)
\end{align*}

An acceptor $\AcceptorRole$ has a corresponding subprocess for each proposer $\ProposerRole$ with quorum $\AQ_{\ProposerRole}$ where $\AcceptorRole\in\AQ_{\ProposerRole}$.
These subprocesses behave like $\PaOne{
    \SessionChannel,
    \AcceptorRole,
    \ProposerRole,
    \NumberRegister,
    \ProposalRegister
}$ and access the same registers $\NumberRegister_{\ProcessIndexJ}$ and $\ProposalRegister_{\ProcessIndexJ}$.
Updating these registers with $\update{r}{v}$ updates them for all subprocesses of an acceptor.

Each subprocess can communicate with one proposer.
Thus, if that proposer can not communicate with a particular subprocess of an acceptor there is no need for that subprocess.

Each subprocess begins by potentially receiving a proposal number $n'$ from the corresponding proposer.
If the acceptor does receive a proposal number $n'$ it responds with either $\Promise{\ProposalRegister_{\ProcessIndexJ}}$ or $\Nack$, depending on the values of $n'$ and $\NumberRegister_{\ProcessIndexJ}$.
If the acceptor does not receive a proposal number then it sends $\bot$ to the proposer.
Sending $\bot$ to the proposer is necessary to maintain the global type.
In either case the subprocess moves on to receive the proposer's decision in phase $\PTwoA$.

% Abort -> end
Since the proposer's decision broadcast is weakly reliable the acceptor receives no decision only if the proposer crashed.
In that case this particular subprocess of the acceptor is no longer needed, because each subprocess of the acceptor exclusively communicates with one proposer.
Thus, the subprocess terminates in the default branch $\Abort$.

% Restart -> recurse
In the $\Restart$ branch this particular subprocess of the acceptor restarts the algorithm to match the corresponding proposer.

% Accept -> receive pr', update, end because proposer ends
In the $\Accept$ branch the acceptor potentially receives a proposal $pr'$ from the corresponding proposer.
The acceptor updates $\NumberRegister_{\ProcessIndexJ}$ and $\ProposalRegister_{\ProcessIndexJ}$ if the proposal number in $pr'$ is greater or equal to the value in $\NumberRegister_{\ProcessIndexJ}$.
Then the subprocess terminates.
If the acceptor does not receive a proposal or the proposal number of $pr'$ is less than the value in $\NumberRegister_{\ProcessIndexJ}$ the subprocess terminates without updating $\NumberRegister_{\ProcessIndexJ}$ or $\ProposalRegister_{\ProcessIndexJ}$.

\section{Failure Patterns}
A failure detector is a subsystem that detects process failures and crashes.
Chandra and Toueg introduce a class of failure detectors $\FailureDetectorClass$ called \emph{eventually strong} in \cite{ChandraToueg96}.
Failure detectors in $\FailureDetectorClass$ satisfy the following properties: (1) eventually every process that crashes is permanently suspected by every correct process and (2) eventually some correct process is never suspected by any correct process.

% uskip and ml:
% false for l2a, eventually strong otherwise for proposers and acceptors
In phase $\POneA$ with label $\LOneA$ the acceptors may suspect some proposers and in phase $\POneB$ with label $\LOneB$ the proposers may suspect some acceptors.
Accordingly, $\FPuskip$ and $\FPml$ are implemented with a failure detector in $\FailureDetectorClass$ for phases $\POneA$ and $\POneB$.
For phase $\PTwoA$ with label $\LTwoA$ both $\FPuskip$ and $\FPml$ return $\False$ to ensure the proposal sent by the proposer to the members of its quorum is not lost.
Thus, the unreliable communication is treated like the weakly reliable broadcast before it.

% wskip: true <=> corresponding proposer is not alive
% leave undefined for proposers because they don't receive a broadcast
For the weakly reliable broadcast in phase $\PTwoA$, the failure pattern $\FPwskip$ eventually returns $\True$ for subprocesses of acceptors if the corresponding proposer crashed.

% crash:
% we need at least one proposer
% true if every correct proposers quorum is still a quorum without that acceptor, otherwise false
We require that every correct proposer is able to communicate with a quorum for Paxos to work.
Therefore, $\FPcrash$ eventually returns $\True$ for a subprocess of an acceptor $\AcceptorRole$ only if the corresponding proposer with quorum $\AQ$ either crashed or still has access to a quorum without that particular acceptor, \ie $\AQ\setminus\Curly{\AcceptorRole}$ is still a quorum.
% implies that acceptors as a whole may crash if proposers are either correct and can still communicate with a quorum without that acceptor or crashed
% what about the requirement that we need at least one proposer?

In Paxos there is no need to reject outdated messages so $\FPuget$ is implemented with a constant $\True$.

These failure patterns satisfy the Conditions~\ref{cond:all}.\ref{cond:crash}--\ref{cond:all}.\ref{cond:fpWskip}.

\section{Example}
In this section we will study an example run of the model with $3$ acceptors and $2$ proposers.
First, we will take a look at the example scenario.
Then we will examine the scenario using reduction rules starting at system initialization.

\begin{figure}
\begin{center}
\begin{tikzpicture}[node distance=2.5cm, >=stealth', arrt/.style={above, font=\footnotesize}, arr/.style={->, thick}, lifeline/.style={dashed, black!35}]
    \def\InitialOffset{0.4}
    \def\StepSize{0.7}
    \newcommand{\Step}[1]{\InitialOffset + #1 * \StepSize}
    \def\MaxSteps{14}
    \def\FullHeight{\Step{\MaxSteps} + 0.66 * \StepSize}

    \node (a1) {$\Acceptor{1}$};
    \node[right = of a1] (a2) {$\Acceptor{2}$};
    \node[right = of a2] (a3) {$\Acceptor{3}$};
    \node[right = of a3] (p4) {$\Proposer{4}$};
    \node[right = of p4] (p5) {$\Proposer{5}$};
    \node[left = of a1] (notes) {};

    \draw[lifeline] (a1) -- ($(a1) - (0, \FullHeight)$);
    \draw[lifeline] (a2) -- ($(a2) - (0, \FullHeight)$);
    \draw[lifeline] (a3) -- ($(a3) - (0, \FullHeight)$);
    \draw[lifeline] (p4) -- ($(p4) - (0, \Step{14.5})$);
    \draw[lifeline] (p5) -- ($(p5) - (0, \Step{5.5})$);
    
    \draw[arr] ($(p5) - (0, \Step{1})$) -- node[arrt] {$\proposalNumber{1}{5} = 10$} ($(a2) - (0, \Step{1})$);
    \draw[arr] ($(p5) - (0, \Step{1})$) -- ($(a3) - (0, \Step{1})$);

    \draw[arr] ($(a2) - (0, \Step{2})$) -- node[arrt] {$\Promise{\Nothing}$} ($(p5) - (0, \Step{2})$);

    \draw[arr] ($(a3) - (0, \Step{3})$) -- node[arrt] {$\Promise{\Nothing}$} ($(p5) - (0, \Step{3})$);

    \draw[arr] ($(p5) - (0, \Step{4})$) -- node[arrt] {$\Accept$} ($(a2) - (0, \Step{4})$);
    \draw[arr] ($(p5) - (0, \Step{4})$) -- ($(a3) - (0, \Step{4})$);

    \draw[arr] ($(p5) - (0, \Step{5})$) -- node[arrt] {$\ProposalC{10}{\ABC}$} ($(a2) - (0, \Step{5})$);
    \draw[arr] ($(p5) - (0, \Step{5})$) -- ($(a3) - (0, \Step{5})$);

    \draw[arr] ($(p4) - (0, \Step{6})$) -- node[arrt] {$\proposalNumber{1}{4} = 5$} ($(a1) - (0, \Step{6})$);
    \draw[arr] ($(p4) - (0, \Step{6})$) -- ($(a2) - (0, \Step{6})$);

    \draw[arr] ($(a1) - (0, \Step{7})$) -- node[arrt] {$\Promise{\Nothing}$} ($(p4) - (0, \Step{7})$);

    \draw[arr] ($(a2) - (0, \Step{8})$) -- node[arrt] {$\Nack$} ($(p4) - (0, \Step{8})$);

    \draw[arr] ($(p4) - (0, \Step{9})$) -- node[arrt] {$\Restart$} ($(a1) - (0, \Step{9})$);
    \draw[arr] ($(p4) - (0, \Step{9})$) -- ($(a2) - (0, \Step{9})$);

    \draw[arr] ($(p4) - (0, \Step{10})$) -- node[arrt] {$\proposalNumber{2}{4} = 15$} ($(a1) - (0, \Step{10})$);
    \draw[arr] ($(p4) - (0, \Step{10})$) -- ($(a2) - (0, \Step{10})$);

    \draw[arr] ($(a1) - (0, \Step{11})$) -- node[arrt] {$\Promise{\Nothing}$} ($(p4) - (0, \Step{11})$);
    
    \draw[arr] ($(a2) - (0, \Step{12})$) -- node[arrt] {$\Promise{\Paren{\ProposalC{10}{\ABC}}}$} ($(p4) - (0, \Step{12})$);

    \draw[arr] ($(p4) - (0, \Step{13})$) -- node[arrt] {$\Accept$} ($(a1) - (0, \Step{13})$);
    \draw[arr] ($(p4) - (0, \Step{13})$) -- ($(a2) - (0, \Step{13})$);

    \draw[arr] ($(p4) - (0, \Step{14})$) -- node[arrt] {$\ProposalC{15}{\ABC}$} ($(a1) - (0, \Step{14})$);
    \draw[arr] ($(p4) - (0, \Step{14})$) -- ($(a2) - (0, \Step{14})$);

    \foreach \r in {1,...,\MaxSteps} {
        \node[font=\footnotesize] at ($(notes) - (0, \Step{\r})$) {$(\r)$};
    }
\end{tikzpicture}
\end{center}
\caption{Example scenario with $3$ acceptors and $2$ proposers.}
\label{fig:scenario}
\end{figure}

\subsection{Scenario}
Figure \ref{fig:scenario} provides an overview where $\Acceptor{1}$, $\Acceptor{2}$, and $\Acceptor{3}$ are the acceptors and $\Proposer{4}$ and $\Proposer{5}$ are the proposers.
$\Proposer{5}$ is elected to be the leader.
In steps $\Paren{1}$ to $\Paren{5}$, $\Proposer{5}$ completes the Paxos algorithm with $\Acceptor{2}$ and $\Acceptor{3}$ and terminates.

At this point $\Acceptor{2}$ has promised not to accept any proposal numbered less than $10$ and has accepted the value $\ABC$.
So, when $\Proposer{4}$ tries to use $5$ as its proposal number $\Paren{6}$, it receives $\Nack$ from $\Acceptor{2}$ $\Paren{8}$ and has to restart the algorithm $\Paren{9}$.

$\Proposer{4}$ then runs through the Paxos algorithm with $\Acceptor{1}$ and $\Acceptor{2}$ starting with a new prepare request $\Paren{10}$ with a higher proposal number.
In step $\Paren{12}$ $\Proposer{4}$ learns that value $\ABC$ with proposal number $10$ has already been accepted by $\Acceptor{2}$.
Later, in step $\Paren{14}$, $\Proposer{4}$ issues a proposal with the value of the highest-numbered proposal that it receives as a response to its prepare request.
In this case there is only one such proposal, which is $\ProposalC{10}{\ABC}$.

In the end all $3$ acceptors have accepted the value $\ABC$.
$\Acceptor{1}$ and $\Acceptor{2}$ have accepted $\ProposalC{15}{\ABC}$ and $\Acceptor{3}$ has accepted $\ProposalC{10}{\ABC}$.

\subsection{Formulae}
We set $\AcceptorCount = 3$, $\ProposerCount = 2$,
$\Value=\Curly{\ABC, \operatorname{def}, \ldots, \operatorname{vwx}, \operatorname{yz}}$.
$\AQ_4 = \genAq{4}{3}{2} = \Bracket{1,2}$ will be the quorum for $\Proposer{4}$ and $\AQ_5 = \genAq{5}{3}{2} = \Bracket{2,3}$ will be the quorum for $\Proposer{5}$.

Let $\NumberRegister_1$, $\NumberRegister_2$, $\NumberRegister_3$, $\NumberRegister_4$, $\NumberRegister_5$, $\ProposalRegister_1$, $\ProposalRegister_2$, and $\ProposalRegister_3$ be registers.
$\NumberRegister_1$, $\NumberRegister_2$, and $\NumberRegister_3$ hold a value of type $\Maybe{\mathbb{N}}$.
$\NumberRegister_4$ and $\NumberRegister_5$ hold a value of type $\mathbb{N}$.
$\ProposalRegister_1$, $\ProposalRegister_2$, and $\ProposalRegister_3$ hold a value of type $\Maybe{\Paren{\Proposal{\Value}}}$.
$\NumberRegister_{\ProcessIndexJ}$ and $\ProposalRegister_{\ProcessIndexJ}$ correspond to acceptor $\Acceptor{\ProcessIndexJ}$ for $\ProcessIndexJ \in \Curly{1, 2, 3}$.
$\NumberRegister_{\ProcessIndexK}$ corresponds to proposer $\Proposer{\ProcessIndexK}$ for $\ProcessIndexK \in \Curly{4, 5}$.
We set the following initial values.

\RegisterContent{$\Nothing$}{$\Nothing$}{$\Nothing$}{$0$}{$0$}{$\Nothing$}{$\Nothing$}{$\Nothing$}

\subsubsection{System Initialization}
\begin{align*}
\Sys{3}{2} =
&
    \SessionRequest{\OuterSharedPoint}{2}{\OuterSessionChannel}.
    \PpInit{5, 3, \Curly{1, 2}, 3, \NumberRegister_5, \EmptyList}
    \\
&\Or
    \SessionAccept{\OuterSharedPoint}{1}{\OuterSessionChannel}.
    \ParallelFor{3 < k < 5}
    \PpInit{\ProcessIndexK, 3, \Curly{1, 2}, 3, \NumberRegister_{\ProcessIndexK}, \EmptyList}
    \\
&\Or
    \ParallelFor{1 \le \ProcessIndexJ \le 3}
    \PaInit{\ProcessIndexJ, 3, 2, \NumberRegister_{\ProcessIndexJ}, \ProposalRegister_{\ProcessIndexJ}}
\end{align*}

After inserting $\AcceptorCount$ and $\ProposerCount$ and applying $\RInit$ once for shared channel $\OuterSharedPoint$ we have:

\begin{align*}
\mapstostar& \Nu{\OuterSessionChannel}\big (\\
&\SessionRequest{\SharedPoint{5}}{3}{\ChannelR}.\PpOne{\ChannelR, 5, 3, \Curly{1, 2}, 3, \NumberRegister_5, \EmptyList} \comment{= \Proposer{5}}\\
&\Or \SessionRequest{\SharedPoint{4}}{3}{\ChannelS}.\PpOne{\ChannelS, 4, 3, \Curly{1, 2}, 3, \NumberRegister_4, \EmptyList} \comment{= \Proposer{4}}\\
&\Or \Paren{
    \If 1 \notin \Curly{1, 2}
    \;\Then \End
    \;\Else \SessionAccept{\SharedPoint{4}}{1}{\ChannelS}\ldots
    \Or
    \If 1 \notin \Curly{2, 3}
    \;\Then \End
    \Else \ldots
} \comment{= \Acceptor{1}}\\
&\Or \Paren{
    \If 2 \notin \Curly{1, 2}
    \;\Then \End
    \;\Else \SessionAccept{\SharedPoint{4}}{2}{\ChannelS}\ldots
    \Or
    \If 2 \notin \Curly{2, 3}
    \;\Then \End
    \;\Else \SessionAccept{\SharedPoint{5}}{1}{\ChannelR}\ldots
} \comment{= \Acceptor{2}}\\
&\Or \Paren{
    \If 3 \notin \Curly{1, 2}
    \;\Then \End
    \;\Else \ldots
    \Or
    \If 3 \notin \Curly{2, 3}
    \;\Then \End
    \;\Else \SessionAccept{\SharedPoint{5}}{2}{\ChannelR}\ldots
} \comment{= \Acceptor{3}}\\
&\Or \OuterSessionQueues
\big )
\end{align*}

We apply $\RIfT$ to the left subprocess of $\Acceptor{3}$ and the right subprocess of $\Acceptor{1}$ and terminate them.
All other acceptor subprocesses advance by applying $\RIfF$.
Note that each process is shortened to only show the next few steps instead of the entire process.

\begin{align*}
\mapstostar& \NuChannels \big (\\
&\SessionRequest{\SharedPoint{5}}{3}{\ChannelR}.\PpOne{\ChannelR, 5, 3, \Curly{1, 2}, 3, \NumberRegister_5, \EmptyList} \comment{= \Proposer{5}}\\
&\Or \SessionRequest{\SharedPoint{4}}{3}{\ChannelS}.\PpOne{\ChannelS, 4, 3, \Curly{1, 2}, 3, \NumberRegister_4, \EmptyList} \comment{= \Proposer{4}}\\
&\Or \SessionAccept{\SharedPoint{4}}{1}{\ChannelS} . \PaOne{\ChannelS, 1, 3, \NumberRegister_1, \ProposalRegister_1} \comment{= \Acceptor{1}}\\
&\Or \Paren{
    \SessionAccept{\SharedPoint{4}}{2}{\ChannelS} . \PaOne{\ChannelS, 2, 3, \NumberRegister_2, \ProposalRegister_2}
    \Or
    \SessionAccept{\SharedPoint{5}}{1}{\ChannelR} . \PaOne{\ChannelR, 1, 3, \NumberRegister_2, \ProposalRegister_2}
} \comment{= \Acceptor{2}}\\
&\Or \SessionAccept{\SharedPoint{5}}{2}{\ChannelR} . \PaOne{\ChannelR, 2, 3, \NumberRegister_3, \ProposalRegister_3} \comment{= \Acceptor{3}}\\
&\Or \OuterSessionQueues
\big )
\end{align*}

We apply $\RInit$ for each shared channel $\SharedPoint{4}$ and $\SharedPoint{5}$ and unfold the calls to $\PpOne{\ChannelS, \ProcessIndexK, \ProposerRole, \QRoles, \AcceptorCount, \NumberRegister, \VectorV}$ and $\PaOne{\ChannelS, \AcceptorRole, \ProposerRole, \NumberRegister, \ProposalRegister}$ to obtain:

\begin{align*}
\mapstostar& \NuChannels\big (\\
&\Mu{\RecursionVariable} \update{\NumberRegister_5}{0 + 1} . \DotForall{\AcceptorRole\in \Curly{1, 2}}{\SendUnreliableP{\ChannelR}{3}{\AcceptorRole}{\LOneA}{\proposalNumber{\NumberRegister_5}{5}}}\ldots \comment{= \Proposer{5}}\\
&\Or \Mu{\RecursionVariable} \update{\NumberRegister_4}{0 + 1} . \DotForall{\AcceptorRole\in \Curly{1, 2}}{\SendUnreliableP{\ChannelS}{3}{\AcceptorRole}{\LOneA}{\proposalNumber{\NumberRegister_4}{4}}}\ldots \comment{= \Proposer{4}}\\
&\Or
    \Mu{\RecursionVariable}
    \ReceiveUnreliableP{\ChannelS}{1}{3}{\LOneA}{\bot}{n'}.
    \If \ldots \comment{= \Acceptor{1}}\\
&\Or \Paren{
    \Mu{\RecursionVariable} \ReceiveUnreliableP{\ChannelS}{2}{3}{\LOneA}{\bot}{n'}.\If \ldots
    \Or \Mu{\RecursionVariable} \ReceiveUnreliableP{\ChannelR}{1}{3}{\LOneA}{\bot}{n'}.\If \ldots
} \comment{= \Acceptor{2}}\\
&\Or \Mu{\RecursionVariable} \ReceiveUnreliableP{\ChannelR}{2}{3}{\LOneA}{\bot}{n'}.\If \ldots \comment{= \Acceptor{3}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \InnerSessionQueues{\ChannelR}
\Or \OuterSessionQueues
\big )
\end{align*}

\subsubsection{The Happy Path}
We apply $\RRec$ to every process and $\RSideEffect$ to both proposers.
Now, the first inter-process communication can take place.
In this case $\Proposer{5}$ communicates with $\Acceptor{2}$ and $\Acceptor{3}$.
We apply $\RUsend$ and $\RUget$ twice to send $\proposalNumber{1}{5} = 10$ to $\Acceptor{2}$ and $\Acceptor{3}$.
% corresponds to (1)

\begin{align*}
&\mapstostar
\NuChannels \big (\\
&\ReceiveUnreliableP{\ChannelR}{3}{1}{\LOneB}{\bot}{v_1}.\ReceiveUnreliableP{\ChannelR}{3}{2}{\LOneB}{\bot}{v_2}\ldots \comment{= \Proposer{5}}\\
&\Or  \SendUnreliableP{\ChannelS}{3}{1}{\LOneA}{\proposalNumber{1}{4}}.\SendUnreliableP{\ChannelS}{3}{2}{\LOneA}{\proposalNumber{1}{4}}\ldots \comment{= \Proposer{4}}\\
&\Or  \ReceiveUnreliableP{\ChannelS}{1}{3}{\LOneA}{\bot}{n'}.\If \ldots \comment{=\Acceptor{1}}\\
&\Or
    \Paren{
        \ReceiveUnreliableP{\ChannelS}{2}{3}{\LOneA}{\bot}{n'}.\If \ldots
        \Or
            \If 10 = \bot
            \;\Then \ldots
            \;\Else \Paren{
                \If \greaterThan{10}{\NumberRegister_2} \ldots
                }
    } \comment{=\Acceptor{2}}\\
&\Or \If 10 = \bot
        \;\Then \ldots
        \;\Else \Paren{
            \If \greaterThan{n'}{\NumberRegister_3}
            \;\Then \update{\NumberRegister_3}{n'}\ldots
            \;\Else \ldots
        } \comment{=\Acceptor{3}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \InnerSessionQueues{\ChannelR}
\Or \OuterSessionQueues
\big )
\end{align*}

Since $10 \neq \bot$ both $\Acceptor{2}$ and $\Acceptor{3}$ move into their respective $\ElseName$ branches by applying $\RIfF$.

\begin{align*}
\mapstostar& \NuChannels \big (\\
&\ReceiveUnreliableP{\ChannelR}{3}{1}{\LOneB}{\bot}{v_1}.\ReceiveUnreliableP{\ChannelR}{3}{2}{\LOneB}{\bot}{v_2}\ldots \comment{= \Proposer{5}}\\
&\Or \SendUnreliableP{\ChannelS}{3}{1}{\LOneA}{\proposalNumber{1}{4}}.\SendUnreliableP{\ChannelS}{3}{2}{\LOneA}{\proposalNumber{1}{4}}\ldots \comment{= \Proposer{4}}\\
&\Or \ReceiveUnreliableP{\ChannelS}{1}{3}{\LOneA}{\bot}{n'}.\If \ldots \comment{=\Acceptor{1}}\\
&\Or \Paren{
    \ReceiveUnreliableP{\ChannelS}{2}{3}{\LOneA}{\bot}{n'}.\If \ldots
    \Or
    \If \greaterThan{10}{\Nothing}
    \;\Then \ldots
    \;\Else \ldots
} \comment{=\Acceptor{2}}\\
&\Or
    \If \greaterThan{10}{\Nothing}
    \;\Then
        \update{\NumberRegister_3}{\Just{n'}}.
        \SendUnreliableP{\ChannelR}{2}{3}{\LOneB}{\Promise{\ProposalRegister_3}}\ldots
    \;\Else \ldots
    \comment{=\Acceptor{3}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \InnerSessionQueues{\ChannelR}
\Or \OuterSessionQueues
\big )
\end{align*}

Because $\greaterThan{10}{\Nothing}$ returns $\True$, $\Acceptor{2}$ and $\Acceptor{3}$ move into their respective $\ThenName$ branches by applying $\RIfT$.
After executing $\update{\NumberRegister_2}{\Just{10}}$ and $\update{\NumberRegister_3}{\Just{10}}$ with $\RSideEffect$, $\Acceptor{2}$ and $\Acceptor{3}$ are ready to send their responses to $\Proposer{5}$.

% A1: n=Nothing, pr=Nothing
% A2: n=10, pr=Nothing
% A3: n=10, pr=Nothing
%  P^A_2 (s, a, p, n, pr)
\begin{align*}
\mapstostar& \NuChannels \big (\\
&
    \ReceiveUnreliableP{\ChannelR}{3}{1}{\LOneB}{\bot}{v_1}.
    \ReceiveUnreliableP{\ChannelR}{3}{2}{\LOneB}{\bot}{v_2}.
    \If \anyNack{\VectorV} \tOr \promiseCount{\VectorV} < 2\ldots
    \comment{= \Proposer{5}}\\
&\Or \SendUnreliableP{\ChannelS}{3}{1}{\LOneA}{\proposalNumber{1}{4}}.\SendUnreliableP{\ChannelS}{3}{2}{\LOneA}{\proposalNumber{1}{4}}\ldots \comment{= \Proposer{4}}\\
&\Or \ReceiveUnreliableP{\ChannelS}{1}{3}{\LOneA}{\bot}{n'}.\If \ldots \comment{= \Acceptor{1}}\\
&\Or \Paren{
    \ReceiveUnreliableP{\ChannelS}{2}{3}{\LOneA}{\bot}{n'}.\If \ldots
    \Or \SendUnreliableP{\ChannelR}{1}{3}{\LOneB}{\Promise{\Nothing}}.
        \PaTwo{\ChannelR, 1, 3, \NumberRegister_2, \ProposalRegister_2}
} \comment{= \Acceptor{2}}\\
&\Or
    \SendUnreliableP{\ChannelR}{2}{3}{\LOneB}{\Promise{\Nothing}}.
    \PaTwo{\ChannelR, 2, 3, \NumberRegister_3, \ProposalRegister_3}
    \comment{= \Acceptor{3}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \InnerSessionQueues{\ChannelR}
\Or \OuterSessionQueues
\big )
\end{align*}

We apply $\RUsend$ and $\RUget$ twice to do just that.
$\Acceptor{3}$ and one subprocess of $\Acceptor{2}$ move into $\PaTwo{\SessionChannel, \AcceptorRole, \ProposerRole, \NumberRegister, \ProposalRegister}$.

$\Proposer{5}$ has $\VectorV = \Bracket{\Promise{\Nothing}, \Promise{\Nothing}}$.
$\anyNack{\VectorV}$ returns $\False$ and $\promiseCount{\VectorV}$ returns $2$.
Thus, $\anyNack{\VectorV} \tOr \promiseCount{\VectorV} < 2$ evaluates to $\False$.
By applying $\RIfF$ $\Proposer{5}$ advances to its $\ElseName$ branch.
% corresponds to (2) - (3)

\begin{align*}
\mapstostar& \NuChannels \big (\\
&
    \SendWeaklyP{\ChannelR}{3}{\Curly{1, 2}}{\Accept}.
    \SendUnreliableP{\ChannelR}{3}{1}{\LTwoA}{\ProposalC{10}{\ABC}}\ldots
    \comment{= \Proposer{5}}\\
&\Or \SendUnreliableP{\ChannelS}{3}{1}{\LOneA}{\proposalNumber{1}{4}}.\SendUnreliableP{\ChannelS}{3}{2}{\LOneA}{\proposalNumber{1}{4}}\ldots \comment{= \Proposer{4}}\\
&\Or \ReceiveUnreliableP{\ChannelS}{1}{3}{\LOneA}{\bot}{n'}.\If \ldots \comment{= \Acceptor{1}}\\
&\Or \Paren{
    \ReceiveUnreliableP{\ChannelS}{2}{3}{\LOneA}{\bot}{n'}.\If \ldots
    \Or \ReceiveWeaklyP{\ChannelR}{1}{3}{\BeginPaCont}
} \comment{= \Acceptor{2}}\\
&\Or
    \ReceiveWeaklyP{\ChannelR}{2}{3}{
        \Accept. \PaThree{\ChannelR, 2, 3, \NumberRegister_3, \ProposalRegister_3} \oplus \Restart. \RecursionVariable \oplus \Abort . \End
    }
    \comment{= \Acceptor{3}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \InnerSessionQueues{\ChannelR}
\Or \OuterSessionQueues
\big )
\end{align*}

$\Proposer{5}$ broadcasts its decision $\Accept$ to $\Acceptor{2}$ and $\Acceptor{3}$.
By applying $\RWsel$ once, $\RWbran$ twice we obtain:
% corresponds to (4)

\begin{align*}
\mapstostar& \NuChannels \big (\\
&
    \SendUnreliableP{\ChannelR}{3}{1}{\LTwoA}{\ProposalC{10}{\ABC}}.
    \SendUnreliableP{\ChannelR}{3}{2}{\LTwoA}{\ProposalC{10}{\ABC}}.
    \End
    \comment{= \Proposer{5}}\\
&\Or
    \SendUnreliableP{\ChannelS}{3}{1}{\LOneA}{\proposalNumber{1}{4}}.
    \SendUnreliableP{\ChannelS}{3}{2}{\LOneA}{\proposalNumber{1}{4}}\ldots
    \comment{= \Proposer{4}}\\
&\Or \ReceiveUnreliableP{\ChannelS}{1}{3}{\LOneA}{\bot}{n'}.\If \ldots \comment{= \Acceptor{1}}\\
&\Or \Paren{
    \ReceiveUnreliableP{\ChannelS}{2}{3}{\LOneA}{\bot}{n'}.\If \ldots
    \Or \ReceiveUnreliableP{\ChannelR}{1}{3}{\LTwoA}{\bot}{pr'}.\If \ldots
} \comment{= \Acceptor{2}}\\
&\Or
    \ReceiveUnreliableP{\ChannelR}{2}{3}{\LTwoA}{\bot}{pr'}.
    \If pr' = \bot
    \;\Then \End
    \;\Else \Paren{\If \ldots}
    \comment{= \Acceptor{3}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \InnerSessionQueues{\ChannelR}
\Or \OuterSessionQueues
\big )
\end{align*}

Now $\Proposer{5}$ can send its proposal to $\Acceptor{2}$ and $\Acceptor{3}$ and terminate.
To do so we apply $\RUsend$ and $\RUget$ twice.

\begin{align*}
&\mapstostar\NuChannels\big (\\
&\Or
\SendUnreliableP{\ChannelS}{3}{1}{\LOneA}{\proposalNumber{1}{4}}.
\SendUnreliableP{\ChannelS}{3}{2}{\LOneA}{\proposalNumber{1}{4}}\ldots
\comment{= \Proposer{4}}\\
&\Or \ReceiveUnreliableP{\ChannelS}{1}{3}{\LOneA}{\bot}{n'}.\If \ldots \comment{= \Acceptor{1}}\\
&\Or
    \Paren{
        \ReceiveUnreliableP{\ChannelS}{2}{3}{\LOneA}{\bot}{n'}.\If \ldots
        \Or
        \If \Paren{\ProposalC{10}{\ABC}} = \bot
        \;\Then \End
        \;\Else \Paren{\If \ldots}
    } \comment{= \Acceptor{2}}\\
&\Or
    \If \Paren{\ProposalC{10}{\ABC}} = \bot
    \;\Then \End
    \;\Else \Paren{
        \If \greaterEqual{10}{\NumberRegister_3}
        \;\Then \update{\ProposalRegister_3}{\Just{pr'}}\ldots
        \;\Else \End
    }
    \comment{= \Acceptor{3}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \InnerSessionQueues{\ChannelR}
\Or \OuterSessionQueues
\big )
\end{align*}

Because $\Paren{\ProposalC{10}{\ABC}} = \bot$ evaluates to $\False$ we can apply $\RIfF$ to $\Acceptor{2}$ and $\Acceptor{3}$.
Then, we can apply $\RIfT$ to $\Acceptor{2}$ and $\Acceptor{3}$ because $\greaterEqual{10}{\Just{10}}$ returns $\True$.

\begin{align*}
&\mapstostar\NuChannels\big (\\
&\Or
\SendUnreliableP{\ChannelS}{3}{1}{\LOneA}{\proposalNumber{1}{4}}.
\SendUnreliableP{\ChannelS}{3}{2}{\LOneA}{\proposalNumber{1}{4}}\ldots
\comment{= \Proposer{4}}\\
&\Or \ReceiveUnreliableP{\ChannelS}{1}{3}{\LOneA}{\bot}{n'}.\If \ldots \comment{= \Acceptor{1}}\\
&\Or
    \Paren{
        \ReceiveUnreliableP{\ChannelS}{2}{3}{\LOneA}{\bot}{n'}.\If \ldots
        \Or
            \update{\ProposalRegister_2}{\Just{\Paren{\ProposalC{10}{\ABC}}}}.
            \update{\NumberRegister_2}{\Just{10}}.
            \End
    } \comment{= \Acceptor{2}}\\
&\Or
    \update{\ProposalRegister_3}{\Just{\Paren{\ProposalC{10}{\ABC}}}}.
    \update{\NumberRegister_3}{\Just{10}}.
    \End
    \comment{= \Acceptor{3}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \InnerSessionQueues{\ChannelR}
\Or \OuterSessionQueues
\big )
\end{align*}

$\Acceptor{2}$ and $\Acceptor{3}$ terminate after applying $\RSideEffect$ twice and updating their registers.
They have accepted the proposal.
$\Proposer{4}$ is the new leader.
% corresponds to (5)

\begin{align*}
&\mapstostar\NuChannels\big (\\
&\Or
\SendUnreliableP{\ChannelS}{3}{1}{\LOneA}{5}.
\SendUnreliableP{\ChannelS}{3}{2}{\LOneA}{5}\ldots
\comment{= \Proposer{4}}\\
&\Or
    \ReceiveUnreliableP{\ChannelS}{1}{3}{\LOneA}{\bot}{n'}.
    \If n' = \bot
    \;\Then \ldots
    \;\Else \Paren{
        \If \greaterThan{n'}{\NumberRegister_1}
        \ldots
    }
    \comment{= \Acceptor{1}}\\
&\Or
    \ReceiveUnreliableP{\ChannelS}{2}{3}{\LOneA}{\bot}{n'}.
    \If n' = \bot
    \;\Then \ldots
    \;\Else \Paren{
        \If \greaterThan{n'}{\NumberRegister_2}
        \ldots
    }
    \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \OuterSessionQueues
\big )
\end{align*}

At this point the registers hold the following values.

\RegisterContent{$\Nothing$}{$\Just{10}$}{$\Just{10}$}{$1$}{$1$}{$\Nothing$}{$\Just{\Paren{\ProposalC{10}{\ABC}}}$}{$\Just{\Paren{\ProposalC{10}{\ABC}}}$}

\subsubsection{Restarting The Algorithm}
Next, $\Proposer{4}$ sends prepare requests with a proposal number less than $10$, which $\Acceptor{2}$ rejects.
$\Proposer{4}$ then decides to restart the algorithm.
We apply $\RUsend$ and $\RUget$ twice.

\begin{align*}
&\mapstostar\NuChannels\big (\\
&\Or
    \ReceiveUnreliableP{\ChannelS}{3}{1}{\LOneB}{\bot}{v_1}.
    \ReceiveUnreliableP{\ChannelS}{3}{2}{\LOneB}{\bot}{v_2}.
    \ldots
    \comment{= \Proposer{4}}\\
&\Or
    \If 5 = \bot
    \;\Then \ldots
    \;\Else \Paren{
        \If \greaterThan{5}{\NumberRegister_1}
        \;\Then \update{\NumberRegister_1}{\Just{5}}\ldots
        \;\Else \ldots
    }
    \comment{= \Acceptor{1}}\\
&\Or
    \If 5 = \bot
    \;\Then \ldots
    \;\Else \Paren{
        \If \greaterThan{5}{\NumberRegister_2}
        \;\Then \ldots
        \;\Else
            \SendUnreliableP{\ChannelS}{2}{3}{\LOneB}{\Nack}.
            \PaTwo{\ChannelS, 2, 3, \NumberRegister_2, \ProposalRegister_2}
    }
    \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \OuterSessionQueues
\big )
\end{align*}

Because $5 = \bot$ evaluates to $\False$ we apply $\RIfF$ to $\Acceptor{1}$ and $\Acceptor{2}$.
We apply $\RIfF$ to $\Acceptor{2}$ again because $\greaterThan{5}{\Just{10}}$ returns $\False$.
$\greaterThan{5}{\Nothing}$ returns $\True$, so we advance $\Acceptor{1}$ to its $\ThenName$ branch by applying $\RIfT$.

\begin{align*}
&\mapstostar\NuChannels\big (\\
&\Or
    \ReceiveUnreliableP{\ChannelS}{3}{1}{\LOneB}{\bot}{v_1}.
    \ReceiveUnreliableP{\ChannelS}{3}{2}{\LOneB}{\bot}{v_2}.
    \ldots
    \comment{= \Proposer{4}}\\
&\Or
    \update{\NumberRegister_1}{\Just{5}}.
    \SendUnreliableP{\ChannelS}{1}{3}{\LOneB}{\Promise{\Nothing}}.
    \PaTwo{\ChannelS, 1, 3, \NumberRegister_1, \ProposalRegister_1}
    \comment{= \Acceptor{1}}\\
&\Or
    \SendUnreliableP{\ChannelS}{2}{3}{\LOneB}{\Nack}.
    \PaTwo{\ChannelS, 2, 3, \NumberRegister_2, \ProposalRegister_2}
    \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \OuterSessionQueues
\big )
\end{align*}

We apply $\RSideEffect$ to $\Acceptor{1}$ to update its register $\NumberRegister_1$.
Applying $\RUsend$ and $\RUget$ twice then yields:

\begin{align*}
&\mapstostar\NuChannels\big (\\
&\Or
    \If \anyNack{\VectorV} \tOr \promiseCount{\VectorV} < 2
    \;\Then \SendWeaklyP{\ChannelS}{3}{\Curly{1, 2}}{\Restart}. \RecursionVariable
    \;\Else \ldots
    \comment{= \Proposer{4}}\\
&\Or
    \ReceiveWeaklyP{\ChannelS}{1}{3}{
        \Accept. \PaThree{\ChannelS, 1, 3, \NumberRegister_1, \ProposalRegister_1} \oplus \Restart. \RecursionVariable \oplus \Abort . \End
    }
    \comment{= \Acceptor{1}}\\
&\Or
    \ReceiveWeaklyP{\ChannelS}{2}{3}{
        \Accept. \PaThree{\ChannelS, 2, 3, \NumberRegister_2, \ProposalRegister_2} \oplus \Restart. \RecursionVariable \oplus \Abort . \End
    }
    \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \OuterSessionQueues
\big )
\end{align*}

$\Proposer{4}$ has $\VectorV = \Bracket{\Promise{\Nothing}, \Nack}$.
$\anyNack{\VectorV}$ returns $\True$ and $\promiseCount{\VectorV}$ returns 1.
Thus, $\anyNack{\VectorV} \tOr \promiseCount{\VectorV} < 2$ evaluates to $\True$.
We apply $\RIfT$ to $\Proposer{4}$.

\begin{align*}
\mapstostar& \NuChannels \big (\\
&
    \SendWeaklyP{\ChannelS}{3}{\Curly{1,2}}{\Restart}.
    \Mu{\RecursionVariable}
    \update{\NumberRegister_4}{\NumberRegister_4 + 1}.
    \SendUnreliableP{\ChannelS}{3}{1}{\LOneA}{\proposalNumber{\NumberRegister_4}{4}}\ldots
    \comment{= \Proposer{4}}\\
&\Or
    \ReceiveWeaklyP{\ChannelS}{1}{3}{
        \Accept \ldots
        \oplus
            \Restart .
            \Mu{\RecursionVariable} \ReceiveUnreliableP{\ChannelS}{1}{3}{\LOneA}{\bot}{n'}\ldots
        \oplus \Abort . \End
    } \comment{= \Acceptor{1}}\\
&\Or
    \ReceiveWeaklyP{\ChannelS}{2}{3}{
        \Accept \ldots
        \oplus
            \Restart .
            \Mu{\RecursionVariable} \ReceiveUnreliableP{\ChannelS}{2}{3}{\LOneA}{\bot}{n'}\ldots
        \oplus \Abort . \End
    } \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \OuterSessionQueues
\big )
\end{align*}

$\Proposer{4}$ sends its decision to restart the algorithm to $\Acceptor{1}$ and $\Acceptor{2}$ by applying $\RWsel$ once and $\RWbran$ twice.

\begin{align*}
\mapstostar& \NuChannels \big (\\
&
    \Mu{\RecursionVariable}
    \update{\NumberRegister_4}{2}.
    \SendUnreliableP{\ChannelS}{3}{1}{\LOneA}{15}.
    \SendUnreliableP{\ChannelS}{3}{2}{\LOneA}{15}.
    \ReceiveUnreliableP{\ChannelS}{3}{1}{\LOneB}{\bot}{v_1}\ldots
    \comment{= \Proposer{4}}\\
&\Or
    \Mu{\RecursionVariable}
    \ReceiveUnreliableP{\ChannelS}{1}{3}{\LOneA}{\bot}{n'}.
    \If n' = \bot
    \;\Then \ldots
    \;\Else
        \Paren{
            \If \greaterThan{n'}{\NumberRegister_1}
            \ldots
        }
    \comment{= \Acceptor{1}}\\
&\Or
    \Mu{\RecursionVariable}
    \ReceiveUnreliableP{\ChannelS}{2}{3}{\LOneA}{\bot}{n'}.
    \If n' = \bot
    \;\Then \ldots
    \;\Else
        \Paren{
            \If \greaterThan{n'}{\NumberRegister_2}
            \ldots
        }
    \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \OuterSessionQueues
\big )
\end{align*}

At this point the registers hold the following values.

\RegisterContent{$\Just{5}$}{$\Just{10}$}{$\Just{10}$}{$1$}{$1$}{$\Nothing$}{$\Just{\Paren{\ProposalC{10}{\ABC}}}$}{$\Just{\Paren{\ProposalC{10}{\ABC}}}$}

\subsubsection{The Happy Path, Again}

First, we apply $\RRec$ to each process and then $\RSideEffect$ to $\Proposer{4}$.

\begin{align*}
\mapstostar& \NuChannels \big (\\
&
    \SendUnreliableP{\ChannelS}{3}{1}{\LOneA}{15}.
    \SendUnreliableP{\ChannelS}{3}{2}{\LOneA}{15}.
    \ReceiveUnreliableP{\ChannelS}{3}{1}{\LOneB}{\bot}{v_1}\ldots
    \comment{= \Proposer{4}}\\
&\Or
    \ReceiveUnreliableP{\ChannelS}{1}{3}{\LOneA}{\bot}{n'}.
    \If n' = \bot
    \;\Then \ldots
    \;\Else \Paren{
            \If \greaterThan{n'}{\NumberRegister_1}
            \ldots
        }
    \comment{= \Acceptor{1}}\\
&\Or
    \ReceiveUnreliableP{\ChannelS}{2}{3}{\LOneA}{\bot}{n'}.
    \If n' = \bot
    \;\Then \ldots
    \;\Else \Paren{
        \If \greaterThan{n'}{\NumberRegister_2}
        \ldots
    }
    \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \OuterSessionQueues
\big )
\end{align*}

This time $\Proposer{4}$ uses a high enough proposal number so that $\Acceptor{1}$ and $\Acceptor{2}$ both promise not to accept any proposal numbered less than that.
$15 = \bot$ evaluates to $\False$ and $\greaterThan{15}{\Just{10}}$ and $\greaterThan{15}{\Just{5}}$ return $\True$.
By applying $\RUsend$ twice in the remaining proposer and $\RUget$, $\RIfF$, and $\RIfT$ in the remaining acceptors we arrive at:

% A1: n=15, pr=Nothing
% A2: n=15, pr=Proposal 10 abc
% A3: n=10, pr=Proposal 10 abc
\begin{align*}
\mapstostar& \NuChannels \big (\\
&
    \ReceiveUnreliableP{\ChannelS}{3}{1}{\LOneB}{\bot}{v_1}.
    \ReceiveUnreliableP{\ChannelS}{3}{2}{\LOneB}{\bot}{v_2}.
    \If \ldots
    \comment{= \Proposer{4}}\\
&\Or
    \update{\NumberRegister_1}{\Just{15}}.
    \SendUnreliableP{\ChannelS}{1}{3}{\LOneB}{\Promise{\Nothing}}.
    \PaTwo{\ChannelS, 1, 3, \NumberRegister_1, \ProposalRegister_1}
    \comment{= \Acceptor{1}}\\
&\Or
    \update{\NumberRegister_2}{\Just{15}}.
    \SendUnreliableP{\ChannelS}{2}{3}{\LOneB}{\Promise{\Paren{\ProposalC{10}{abc}}}}.
    \PaTwo{\ChannelS, 2, 3, \NumberRegister_2, \ProposalRegister_2} \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \OuterSessionQueues
\big )
\end{align*}

$\Acceptor{1}$ and $\Acceptor{2}$ update their respective registers $\NumberRegister$ to $\Just{15}$ by applying $\RSideEffect$.
Because $\Acceptor{2}$ has already accepted a proposal, it responds to $\Proposer{4}$'s prepare request with that proposal.
Twice more we apply $\RUsend$ and $\RUget$ to obtain:

% A1: n=15, pr=Nothing
% A2: n=15, pr=Proposal 10 abc
% A3: n=10, pr=Proposal 10 abc
\begin{align*}
\mapstostar& \NuChannels \big (\\
&
    \If \anyNack{\VectorV} \tOr \promiseCount{\VectorV} < 2
    \;\Then \ldots
    \;\Else
        \SendWeaklyP{\ChannelS}{3}{\Curly{1,2}}{\Accept}
        \ldots
    \comment{= \Proposer{4}}\\
&\Or
    \ReceiveWeaklyP{\ChannelS}{1}{3}{
        \Accept . \PaThree{\ChannelS, 1, 3 \NumberRegister_1, \ProposalRegister_1}
        \oplus \Restart. \RecursionVariable
        \oplus \Abort . \End
    }
    \comment{= \Acceptor{1}}\\
&\Or
    \ReceiveWeaklyP{\ChannelS}{2}{3}{
        \Accept . \PaThree{\ChannelS, 2, 3, \NumberRegister_2, \ProposalRegister_2}
        \oplus \Restart. \RecursionVariable
        \oplus \Abort . \End
    }
    \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \OuterSessionQueues
\big )
\end{align*}

$\Proposer{4}$ has $\VectorV = \Bracket{\Promise{\Nothing}, \Promise{\Paren{\Just{\Paren{\ProposalC{10}{\ABC}}}}}}$.
$\anyNack{\VectorV} \tOr \promiseCount{\VectorV} < 2$ evaluates to $\False$ and we can apply $\RIfF$.

\begin{align*}
\mapstostar& \NuChannels \big (\\
&
    \SendWeaklyP{\ChannelS}{3}{\Curly{1,2}}{\Accept}.
    \SendUnreliableP{\ChannelS}{3}{1}{\LTwoA}{\ProposalC{15}{\ABC}}.
    \SendUnreliableP{\ChannelS}{3}{2}{\LTwoA}{\ProposalC{15}{\ABC}}.
    \End
    \comment{= \Proposer{4}}\\
&\Or
    \ReceiveWeaklyP{\ChannelS}{1}{3}{
        \Accept . \PaThree{\ChannelS, 1, 3 \NumberRegister_1, \ProposalRegister_1}
        \oplus \Restart. \RecursionVariable
        \oplus \Abort . \End
    }
    \comment{= \Acceptor{1}}\\
&\Or
    \ReceiveWeaklyP{\ChannelS}{2}{3}{
        \Accept . \PaThree{\ChannelS, 2, 3, \NumberRegister_2, \ProposalRegister_2}
        \oplus \Restart. \RecursionVariable
        \oplus \Abort . \End
    }
    \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \OuterSessionQueues
\big )
\end{align*}

$\Proposer{4}$ has received enough promises to send its own proposal.
The value for that proposal is $\ABC$ because that is the value of the highest-numbered proposal $\Proposer{4}$ received as a response to its prepare request.
First, we apply $\RWsel$ and $\RWbran$.

% A1: n=15, pr=Nothing
% A2: n=15, pr=Proposal 10 abc
% A3: n=10, pr=Proposal 10 abc
\begin{align*}
\mapstostar& \NuChannels \big (\\
&
    \SendUnreliableP{\ChannelS}{3}{1}{\LTwoA}{\ProposalC{15}{\ABC}}.
    \SendUnreliableP{\ChannelS}{3}{2}{\LTwoA}{\ProposalC{15}{\ABC}}.
    \End
    \comment{= \Proposer{4}}\\
&\Or
    \ReceiveUnreliableP{\ChannelS}{1}{3}{\LTwoA}{\bot}{pr'}.
    \If pr' = \bot
    \;\Then \End
    \;\Else \Paren{
        \If \greaterEqual{\nFromProposal{pr'}}{\NumberRegister_1}
        \ldots
    }
    \comment{= \Acceptor{1}}\\
&\Or
    \ReceiveUnreliableP{\ChannelS}{2}{3}{\LTwoA}{\bot}{pr'}.
    \If pr' = \bot
    \;\Then \End
    \;\Else \Paren{
        \If \greaterEqual{\nFromProposal{pr'}}{\NumberRegister_2}
        \ldots
    }
    \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \OuterSessionQueues
\big )
\end{align*}

Then we apply $\RUsend$ and $\RUget$ to send the proposal from $\Proposer{4}$ to the acceptors.
$\Proposer{4}$ terminates.

\begin{align*}
\mapstostar& \NuChannels \big (\\
&
    \If \Paren{\ProposalC{15}{\ABC}} = \bot
    \;\Then \End
    \;\Else \Paren{
        \If \greaterEqual{15}{\NumberRegister_1}
        \;\Then \update{\ProposalRegister_1}{\Just{pr'}}\ldots
        \;\Else \End
    }
    \comment{= \Acceptor{1}}\\
&\Or
    \If \Paren{\ProposalC{15}{\ABC}} = \bot
    \;\Then \End
    \;\Else \Paren{
        \If \greaterEqual{15}{\NumberRegister_2}
        \;\Then \update{\ProposalRegister_2}{\Just{pr'}}\ldots
        \;\Else \End
    }
    \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \OuterSessionQueues
\big )
\end{align*}

$\Paren{\ProposalC{15}{\ABC}} = \bot$ evaluates to $\False$ and $\greaterEqual{15}{\Just{15}}$ returns $\True$.
So, we apply $\RIfF$ and then $\RIfT$ to the acceptors.

\begin{align*}
\mapstostar& \NuChannels \big (\\
&
    \update{\ProposalRegister_1}{\Just{pr'}}.
    \update{\NumberRegister_1}{\Just{\Paren{\nFromProposal{pr'}}}}.
    \End
    \comment{= \Acceptor{1}}\\
&\Or
    \update{\ProposalRegister_2}{\Just{pr'}}.
    \update{\NumberRegister_2}{\Just{\Paren{\nFromProposal{pr'}}}}.
    \End
    \comment{= \Acceptor{2}}\\
&\Or \InnerSessionQueues{\ChannelS}
\Or \OuterSessionQueues
\big )
\end{align*}

Finally, we apply $\RSideEffect$ twice to each acceptor.
With that, \Acceptor{1} and \Acceptor{2} have accepted \Proposer{4}'s proposal.

% A1: n=15, pr=Proposal 15 abc
% A2: n=15, pr=Proposal 15 abc
% A3: n=10, pr=Proposal 10 abc
\[\mapstostar \NuChannels \End\]

The final values the registers contain are as follows.

\RegisterContent{$\Just{15}$}{$\Just{15}$}{$\Just{10}$}{$2$}{$2$}{$\Just{\Paren{\ProposalC{15}{\ABC}}}$}{$\Just{\Paren{\ProposalC{15}{\ABC}}}$}{$\Just{\Paren{\ProposalC{10}{\ABC}}}$}

All acceptors have accepted the value $\ABC$.
