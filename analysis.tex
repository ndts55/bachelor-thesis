\chapter{Analysis}
\label{chapter:analysis}
We take the model from the previous chapter, type check it, and use the type check to prove agreement, validity, and termination for our model of the Paxos algorithm.
To execute the type check we project the global type to local types and use the typing rules given in \cite{PetersEtal21}.

\section{Local Types}
Because no communication occurs in the outer session, the  outer session's global type is $\OuterGlobalType = \End$.
The projection of $\OuterGlobalType$ to a local type is $\OuterGlobalTypeProjection{k} = \End$ for every $k$.

We assume a proposer $\ProcessIndexK$ where $\AcceptorCount + 1 \leq \ProcessIndexK \leq \AcceptorCount + \ProposerCount$ and a corresponding quorum $\AQ_{\ProcessIndexK}\subseteq\Curly{1,\ldots,\AcceptorCount}$.
Let $\ProposerRole = |\AQ_{\ProcessIndexK}| + 1$, $\QRoles = \Curly{1,\ldots,|\AQ_{\ProcessIndexK}|}$, $\AcceptorRole \in \QRoles$, and $\UnusedRole \in \mathbb{N}\setminus\Paren{\QRoles \cup \Curly{\ProposerRole}}$.
We project the global type $\IndexedGlobalType{\ProcessIndexK}$ to the local types $\IndexedGlobalTypeProjection{\ProcessIndexK}{\ProposerRole}$, $\IndexedGlobalTypeProjection{\ProcessIndexK}{\AcceptorRole}$, and $\IndexedGlobalTypeProjection{\ProcessIndexK}{\UnusedRole}$.

\begin{align*}
\IndexedGlobalTypeProjection{\ProcessIndexK}{\ProposerRole} =
&
    \Mu{\RecursionVariableType}
    \DotForall{
        \AcceptorRole\in\QRoles
    }{
        \SendUnreliableL{\AcceptorRole}{\LOneA}{\mathbb{N}}
    } .
    \DotForall{
        \AcceptorRole\in\QRoles
    }{
        \ReceiveUnreliableL{\AcceptorRole}{\LOneB}{\Promise{\Value}}
    } .\\
&
    \SendWeaklyL{\QRoles}{
        \Accept .
            \DotForall{
                \AcceptorRole\in\QRoles
            }{
                \SendUnreliableL{\AcceptorRole}{\LTwoA}{\Proposal{\Value}}}.
                \End ,
        \Restart .
            \RecursionVariableType ,
        \Abort .
            \End
    }
\end{align*}

$\IndexedGlobalTypeProjection{\ProcessIndexK}{\ProposerRole}$ defines the local type for proposers.
First, the proposer sends a proposal number to all acceptors in its quorum in phase $\POneA$.
It receives their responses in phase $\POneB$ and then branches in phase $\PTwoA$.
We can see that the proposer communicates with all acceptors in its quorum in every phase.

\begin{align*}
\IndexedGlobalTypeProjection{\ProcessIndexK}{\AcceptorRole} =
&
    \Mu{\RecursionVariableType}
    \ReceiveUnreliableL{\ProposerRole}{\LOneA}{\mathbb{N}} .
    \SendUnreliableL{\ProposerRole}{\LOneB}{\Promise{\Value}} .
    \\
&
    \ReceiveWeaklyL{\ProposerRole}{
        \Accept .
            \ReceiveUnreliableL{\ProposerRole}{\LTwoA}{\Proposal{\Value}}.
            \End
        ,\Restart .
            \RecursionVariableType
        ,\Abort .
            \End
    }{\Abort}\\\\
\IndexedGlobalTypeProjection{\ProcessIndexK}{\UnusedRole} =&\; \End
\end{align*}

$\IndexedGlobalTypeProjection{\ProcessIndexK}{\AcceptorRole}$ defines the local type for acceptors contained in the proposer's quorum $\AQ_{\ProposerRole}$.
Since Paxos defines two types of agents that communicate with each other, their local types complement each other.
An acceptor first receives a proposal number, then it responds with a $\Promise{\Value}$.
Finally, it receives the proposer's branching choice.

$\IndexedGlobalTypeProjection{\ProcessIndexK}{\UnusedRole}$ is empty because $\UnusedRole$ is not a role that participates in the global type.

\section{Type Check}
Let $\AcceptorCount,\ProposerCount\in\mathbb{N}$ and $\AQ_{\ProcessIndexK} = \genAq{\ProcessIndexK}{\AcceptorCount}{\ProposerCount}$ for $\AcceptorCount + 1 \leq \ProcessIndexK \leq \AcceptorCount + \ProposerCount$.

\begin{align*}
\Gamma =
    &\left(
    \GEnvEntry{\OuterSharedPoint}{\OuterGlobalType}
    \cdot \GEnvEntry{\SharedPoint{\AcceptorCount+1}}{\IndexedGlobalType{\AcceptorCount+1}} \cdot \ldots
    \cdot \GEnvEntry{\SharedPoint{\AcceptorCount+\ProposerCount}}{\IndexedGlobalType{\AcceptorCount+\ProposerCount}}
    \right)\\
&\cdot
    \left(
    \GEnvEntry{1}{\mathbb{N}}
    \cdot \ldots
    \cdot \GEnvEntry{\AcceptorCount}{\mathbb{N}}
    \cdot \GEnvEntry{\AcceptorCount + 1}{\mathbb{N}}
    \cdot \ldots
    \cdot \GEnvEntry{\AcceptorCount + \ProposerCount}{\mathbb{N}}
    \right)
\end{align*}

$\Gamma$ contains the type for our shared channels $\OuterSharedPoint$, $\SharedPoint{\ProcessIndexK}$ where $\AcceptorCount + 1 \leq \ProcessIndexK \leq \AcceptorCount + \ProposerCount$, and all numbers between $1$ and $\AcceptorCount + \ProposerCount$.

Note that $0 < \ProposerCount < \AcceptorCount + \ProposerCount$ because $\AcceptorCount > 0 \land \ProposerCount > 0$.
Thus, $\GEnvEntry{\ProposerCount}{\mathbb{N}}\in\Gamma$.

We start the type check with the global environment $\Gamma$ and the entry point of the model $\Sys{\AcceptorCount}{\ProposerCount}$.
Then, we apply the typing rules in \cite{PetersEtal21} in a proof tree and show that the processes can be derived from the axioms $\RVar$ and $\REnd$.

\subsection{System Initialization}
% (S0)
\begin{prooftree}
    \AxiomC{$\SysProof{1}$}
    \noLine
    \UnaryInfC{$\Gamma\vdash \SessionRequest{\OuterSharedPoint}{2}{\OuterSessionChannel}\ldots \vartriangleright \emptyset$}

    \AxiomC{$\SysProof{2}$}
    \noLine
    \UnaryInfC{$\Gamma\vdash \SessionAccept{\OuterSharedPoint}{1}{\OuterSessionChannel} \ldots \vartriangleright \emptyset$}

    \AxiomC{$\SysProof{3}$}
    \noLine
    \UnaryInfC{$\Gamma\vdash \ParallelFor{1 \leq \ProcessIndexJ \leq \AcceptorCount} \PaInit{\ldots} \vartriangleright \emptyset$}

    \RightLabel{$\RPar$}
    \BinaryInfC{$\Gamma\vdash \SessionAccept{\OuterSharedPoint}{1}{\OuterSessionChannel} \ldots \Or \ParallelFor{1 \leq \ProcessIndexJ \leq \AcceptorCount} \PaInit{\ldots} \vartriangleright \emptyset$}

    \RightLabel{$\RPar$}
    \BinaryInfC{$\Gamma\vdash \SessionRequest{\OuterSharedPoint}{2}{\OuterSessionChannel}.\PpInit{\ldots} \Or \SessionAccept{\OuterSharedPoint}{1}{\OuterSessionChannel} \ldots \Or \ParallelFor{1 \leq \ProcessIndexJ \leq \AcceptorCount} \PaInit{\ldots} \vartriangleright \emptyset$}
\end{prooftree}
We apply $\RPar$ twice and split off into the proof trees $\SysProof{1}$, $\SysProof{2}$, and $\SysProof{3}$.

% (S1)
\begin{prooftree}
    \AxiomC{$\ProposerProof{}$}
    \noLine
    \UnaryInfC{$\Gamma\vdash
    \SessionRequest{\SharedPoint{\AcceptorCount+\ProposerCount}}{\ProposerRole}{\SessionChannel}.
    \PpOne{
        \SessionChannel,
        \ProcessIndexK,
        \ProposerRole,
        \QRoles,
        \AcceptorCount,
        \NumberRegister_{\AcceptorCount + \ProposerCount},
        \EmptyList
    }
    \vartriangleright \SEnvEntry{\OuterSessionChannel}{2}{\OuterGlobalTypeProjection{2}}$}

    \LeftLabel{$\SysProof{1} =$}
    \RightLabel{$\RReq$}
    \UnaryInfC{$\Gamma\vdash \SessionRequest{\OuterSharedPoint}{2}{\OuterSessionChannel}.
        \PpInit{
            \AcceptorCount + \ProposerCount,
            |\AQ_{\AcceptorCount + \ProposerCount}| + 1,
            \Curly{1,\ldots,|\AQ_{\AcceptorCount + \ProposerCount}|},
            \AcceptorCount,
            \NumberRegister_{\AcceptorCount + \ProposerCount},
            \EmptyList
        }\vartriangleright \emptyset$}
\end{prooftree}
In $\SysProof{1}$ we apply $\RReq$ once.
The rest of the proof tree is in $\ProposerProof{}$.
Note that, since $\OuterGlobalTypeProjection{2} = \End$, $\SEnvEntry{\OuterSessionChannel}{2}{\OuterGlobalTypeProjection{2}} = \emptyset$.
This is relevant later when continuing $\ProposerProof{}$.

% (S2)
\begin{prooftree}
    \AxiomC{$\ProposerProof{}$}
    \noLine
    \UnaryInfC{$\Gamma\vdash \SessionRequest{\SharedPoint{\AcceptorCount+1}}{\ProposerRole}{\SessionChannel}.\PpOne{\ldots} \vartriangleright \emptyset$}

    \AxiomC{$\ldots$}

    \AxiomC{$\ProposerProof{}$}
    \noLine
    \UnaryInfC{$\Gamma\vdash \SessionRequest{\SharedPoint{\AcceptorCount+\ProposerCount-1}}{\ProposerRole}{\SessionChannel}.\PpOne{\ldots} \vartriangleright \emptyset$}

    \RightLabel{$\RPar^{\ProposerCount - 1}$}
    \TrinaryInfC{$\Gamma\vdash
    \ParallelFor{
        \AcceptorCount + 1 \leq \ProcessIndexK < \AcceptorCount + \ProposerCount
    }
    \PpInit{
        \ProcessIndexK,
        |\AQ_{\ProcessIndexK}| + 1,
        \Curly{1,\ldots,|\AQ_{\ProcessIndexK}|},
        \AcceptorCount,
        \NumberRegister_{\ProcessIndexK},
        \EmptyList
    } \vartriangleright \SEnvEntry{\OuterSessionChannel}{1}{G\upharpoonright_1}$}

    \LeftLabel{$\SysProof{2} =$}
    \RightLabel{$\RAcc$}
    \UnaryInfC{$\Gamma\vdash
    \SessionAccept{\OuterSharedPoint}{1}{\OuterSessionChannel}.
    \ParallelFor{\AcceptorCount + 1 \leq \ProcessIndexK < \AcceptorCount+\ProposerCount}
    \PpInit{\ldots}
    \vartriangleright \emptyset$}
\end{prooftree}
Applying $\RAcc$ in $\SysProof{2}$ requires that $\GEnvEntry{\OuterSharedPoint}{\OuterGlobalType} \in \Gamma$.
$\RPar$ is applied $\ProposerCount - 1$ times to separate all the proposer processes.
Each individual proposer can be type checked with the same proof tree $\ProposerProof{}$.
Because $\OuterGlobalTypeProjection{1} = \End$, $\SEnvEntry{\OuterSessionChannel}{1}{\OuterGlobalTypeProjection{1}} = \emptyset$.
The session environment $\Delta$ in $\ProposerProof{}$ is empty for every proposer.

% (S3)
\begin{prooftree}
    \AxiomC{}
    \RightLabel{$\REnd$}
    \UnaryInfC{$\Gamma\vdash\End\vartriangleright\emptyset$}

    \AxiomC{$\SysProof{4}$}
    \noLine
    \UnaryInfC{$
    \Gamma\vdash
        \SessionAccept{\SharedPoint{\ProcessIndexK}}{\position{\ProcessIndexJ}{\AQ_{\ProcessIndexK}}}{\SessionChannel}.
        \PaOne{\ldots}
        \vartriangleright\emptyset
    $}

    \RightLabel{$\RIf$}
    \BinaryInfC{$
    \Gamma\vdash
        \If \ProcessIndexJ\notin\AQ_{\ProcessIndexK}
        \;\Then \End
        \;\Else
            \SessionAccept{\SharedPoint{\ProcessIndexK}}{\position{\ProcessIndexJ}{\AQ_{\ProcessIndexK}}}{\SessionChannel}.
            \PaOne{\ldots}
    \vartriangleright\emptyset
    $}
    
    \AxiomC{$\ldots$}
    
    \RightLabel{$\RPar^{\ProposerCount}$}
    \BinaryInfC{$\Gamma\vdash
        \ParallelFor{
            \AcceptorCount + 1 \leq \ProcessIndexK \leq \AcceptorCount + \ProposerCount
        }
        \Paren{
            \If \ProcessIndexJ\notin\AQ_{\ProcessIndexK}
            \;\Then \End
            \;\Else
                \SessionAccept{\SharedPoint{\ProcessIndexK}}{\position{\ProcessIndexJ}{\AQ_{\ProcessIndexK}}}{\SessionChannel}.
                \ldots
        }
        \vartriangleright\emptyset$}
    \AxiomC{$\ldots$}

    \LeftLabel{$\SysProof{3} =$}
    \RightLabel{$\RPar^{\AcceptorCount}$}
    \BinaryInfC{$\Gamma\vdash
        \ParallelFor{1 \leq \ProcessIndexJ \leq \AcceptorCount}
        \PaInit{
            \ProcessIndexJ,
            \AcceptorCount,
            \ProposerCount,
            \NumberRegister_{\ProcessIndexJ},
            \ProposalRegister_{\ProcessIndexJ}
        }
        \vartriangleright \emptyset
    $}
\end{prooftree}
$\RPar$ is applied $\AcceptorCount$ times to separate the individual acceptors and then $\ProposerCount$ times for each acceptor to separate the individual subprocesses.
We apply $\RIf$ and split the proof tree.
Then, we finish the left proof tree by applying $\REnd$.
The right proof tree is in $\SysProof{4}$.
Let $\AcceptorRole = \position{\ProcessIndexJ}{\AQ_{\ProcessIndexK}}$.
Note that $\AcceptorRole\in\Curly{1,\ldots,|\AQ_{\ProcessIndexK}|}$ because $\ProcessIndexJ\in\AQ_{\ProcessIndexK}$.

% (S4)
\begin{prooftree}
    \AxiomC{$\AcceptorProofOne$}
    \noLine
    \UnaryInfC{$\Gamma\vdash
    \PaOne{
            \SessionChannel,
            \AcceptorRole,
            |\AQ_{\ProcessIndexK}| + 1,
            \NumberRegister_{\ProcessIndexJ},
            \ProposalRegister_{\ProcessIndexJ}
        }
    \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{
        \IndexedGlobalTypeProjection{\ProcessIndexK}{\AcceptorRole}
        }$}
    
    \LeftLabel{$\SysProof{4} =$}
    \RightLabel{$\RAcc$}
    \UnaryInfC{$
    \Gamma\vdash
        \SessionAccept{\SharedPoint{\ProcessIndexK}}{\AcceptorRole}{\SessionChannel}.
        \PaOne{
            \SessionChannel,
            \AcceptorRole,
            |\AQ_{\ProcessIndexK}| + 1,
            \NumberRegister_{\ProcessIndexJ},
            \ProposalRegister_{\ProcessIndexJ}
        }
        \vartriangleright\emptyset
    $}
\end{prooftree}

Applying $\RAcc$ to every subprocess of every acceptor requires that every shared channel $\SharedPoint{\ProcessIndexK}$ where $\AcceptorCount + 1 \leq \ProcessIndexK \leq \AcceptorCount + \ProposerCount$ is assigned the type $\IndexedGlobalType{\ProcessIndexK}$ in $\Gamma$.

\[\forall k\in\mathbb{N}: \left(\AcceptorCount + 1 \leq k \land k \leq \AcceptorCount + \ProposerCount \right) \to \GEnvEntry{\SharedPoint{k}}{\IndexedGlobalType{\ProcessIndexK}} \in \Gamma\]

Note that only one acceptor and one of its subprocesses is shown in $\SysProof{3}$ and $\SysProof{4}$.
The other subprocesses and acceptors only differ in their values for the iteration variables $k$ and $j$.
The rest has been left out to improve readability.

\subsection{Proposer}
To abbreviate the proposer's local type in the following proof trees we define the following sub-formulae.

\begin{align*}
&\TpAccept = \DotForall{\AcceptorRole\in\QRoles}{\SendUnreliableL{\AcceptorRole}{\LTwoA}{\Proposal{\Value}}}.\End\\
&\TpBranch = \SendWeaklyL{\QRoles}{\Accept . \TpAccept \oplus \Restart . \RecursionVariableType \oplus \Abort .\End}
\end{align*}

Note that $\IndexedGlobalTypeProjection{\ProcessIndexK}{\ProposerRole} = \Mu{\RecursionVariableType}
\DotForall{\AcceptorRole\in\QRoles}{\SendUnreliableL{\AcceptorRole}{\LOneA}{\mathbb{N}}} .
\DotForall{\AcceptorRole\in\QRoles}{\ReceiveUnreliableL{\AcceptorRole}{\LOneB}{\Promise{\Value}}} . \TpBranch$.

In order to shorten the proposer's process we define some variables.

\begin{align*}
&e = \anyNack{\VectorV} \tOr \Paren{\promiseCount{\VectorV} < \ceil{\frac{\AcceptorCount + 1}{2}}}\\
&pn = \proposalNumber{\NumberRegister_{\ProcessIndexK}}{\ProcessIndexK}\\
&prop = \ProposalC{\Big ( pn \Big )}{\Paren{\promiseValue{\VectorV}}}
\end{align*}

We observe that $\GammaSatisfiesType{e}{\Bool}$, $\GammaSatisfiesType{pn}{\mathbb{N}}$, and $\GammaSatisfiesType{prop}{\Proposal{\Value}}$.

To further abbreviate the terms in the proof trees we define two global environments $\GammaX$ and $\GammaXV$.

\[\GammaX=\Gamma\cdot\GEnvEntry{\RecursionVariable}{\RecursionVariableType}\]

$\GammaX$ contains $\Gamma$ and a type for the recursion variable $\RecursionVariable$.

\[\GammaXV = \GammaX \cdot \GEnvEntry{v_{1}}{\Promise{\Value}}\cdot\ldots\cdot\GEnvEntry{v_{|\AQ_{\ProcessIndexK}|}}{\Promise{\Value}}\]

$\GammaXV$ contains $\GammaX$ and types for the entries of $\VectorV$.
These are added to the global environment when applying $\RUget$ in phase $\POneB$.

% (P)
\begin{prooftree}
\AxiomC{$\ProposerProofTrue$}
\noLine
\UnaryInfC{$\GammaXV \vdash \SendWeaklyP{\SessionChannel}{\ProposerRole}{\QRoles}{\Restart}. \RecursionVariable \vartriangleright \SEnvEntry{\SessionChannel}{\ProposerRole}{\TpBranch}$}

\AxiomC{$\ProposerProofFalse$}
\noLine
\UnaryInfC{$\GammaXV \vdash \SendWeaklyP{\SessionChannel}{\ProposerRole}{\QRoles}{\Accept} \ldots
\vartriangleright \SEnvEntry{\SessionChannel}{\ProposerRole}{\TpBranch}$}

\RightLabel{$\RIf$}
\BinaryInfC{$\GammaXV \vdash
    \If e
    \;\Then \SendWeaklyP{\SessionChannel}{\ProposerRole}{\QRoles}{\Restart}. \RecursionVariable
    \;\Else \SendWeaklyP{\SessionChannel}{\ProposerRole}{\QRoles}{\Accept} \ldots
    \vartriangleright \SEnvEntry{\SessionChannel}{\ProposerRole}{\TpBranch}$}

\RightLabel{$\RUget^{|\QRoles|}$}
\UnaryInfC{$\GammaX \vdash \DotForall{\AcceptorRole\in\QRoles}{\ReceiveUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneB}{\bot}{v_{\AcceptorRole}}} \ldots \vartriangleright \SEnvEntry{\SessionChannel}{\ProposerRole}{\DotForall{\AcceptorRole\in\QRoles}{\ReceiveUnreliableL{\AcceptorRole}{\LOneB}{\Promise{\Value}}}}$}

\RightLabel{$\RUsend^{|\QRoles|}$}
\UnaryInfC{$\GammaX \vdash \DotForall{\AcceptorRole\in\QRoles}{\SendUnreliableP{\SessionChannel}{\ProposerRole}{\AcceptorRole}{\LOneA}{pn}} \ldots \vartriangleright \SEnvEntry{\SessionChannel}{\ProposerRole}{\DotForall{\AcceptorRole\in\QRoles}{\SendUnreliableL{\AcceptorRole}{\LOneA}{\mathbb{N}}}\ldots}$}

\RightLabel{$\RSideEffect$}
\UnaryInfC{$\GammaX \vdash \update{\NumberRegister_{\ProcessIndexK}}{\NumberRegister_{\ProcessIndexK} + 1} \ldots \vartriangleright \SEnvEntry{\SessionChannel}{\ProposerRole}{\DotForall{\AcceptorRole\in\QRoles}{\SendUnreliableL{\AcceptorRole}{\LOneA}{\mathbb{N}}}\ldots}$}

\RightLabel{$\RRec$}
\UnaryInfC{$\Gamma\vdash
    \Mu{\RecursionVariable}
    \update{\NumberRegister_{\ProcessIndexK}}{\NumberRegister_{\ProcessIndexK} + 1}
    \ldots
    \vartriangleright
    \SEnvEntry{\SessionChannel}{\ProposerRole}{
        \Mu{\RecursionVariableType}
        \DotForall{\AcceptorRole\in\QRoles}{
            \SendUnreliableL{\AcceptorRole}{\LOneA}{\mathbb{N}}}\ldots}$}

\LeftLabel{$\ProposerProof{} = $}
\RightLabel{$\RReq$}
\UnaryInfC{$\Gamma\vdash \SessionRequest{\SharedPoint{\ProcessIndexK}}{\ProposerRole}{\SessionChannel}.\PpOne{
    \SessionChannel,
    \ProcessIndexK,
    \ProposerRole,
    \QRoles,
    \AcceptorCount,
    \NumberRegister_{\ProcessIndexK},
    \VectorV
} \vartriangleright \emptyset$}
\end{prooftree}
$\ProposerProof{}$ is the continuation of $\SysProof{1}$ and $\SysProof{2}$.
In both proof trees the session environment $\Delta$ was empty.
Here, we apply $\RReq$ and add $\SEnvEntry{\SessionChannel}{\ProposerRole}{\IndexedGlobalTypeProjection{\ProcessIndexK}{\ProposerRole}}$ to the session environment.
Applying $\RRec$ changes the global environment from $\Gamma$ to $\GammaX$.
$\RSideEffect$ advances the process.
First $\RUsend$ and then $\RUget$ is applied for every acceptor role in $\QRoles$.
$\RUget$ expands the session environment to $\GammaXV$.
$\RIf$ splits the proof tree into $\ProposerProofTrue$ and $\ProposerProofFalse$.

% (P_t)
\begin{prooftree}
\AxiomC{}
\RightLabel{$\RVar$}
\UnaryInfC{$\GammaXV\vdash \RecursionVariable \vartriangleright \SEnvEntry{\SessionChannel}{\ProposerRole}{\RecursionVariableType}$}
\LeftLabel{$\ProposerProofTrue =$}
\RightLabel{$\RWsel$}
\UnaryInfC{$\GammaXV\vdash \SendWeaklyP{\SessionChannel}{\ProposerRole}{\QRoles}{\Restart}. \RecursionVariable \vartriangleright \SEnvEntry{\SessionChannel}{\ProposerRole}{\SendWeaklyL{\QRoles}{\Accept . \TpAccept \oplus \Restart . \RecursionVariableType \oplus \Abort .\End}}$}
\end{prooftree}
We apply $\RWsel$ and then $\RVar$ to finish $\ProposerProofTrue$.

% (P_f)
\begin{prooftree}
\AxiomC{}
\RightLabel{$\REnd$}
\UnaryInfC{$\GammaXV\vdash \End \vartriangleright \SEnvEntry{\SessionChannel}{\ProposerRole}{\End}$}
\RightLabel{$\RUsend^{|\QRoles|}$}
\UnaryInfC{$\GammaXV\vdash
    \DotForall{\AcceptorRole\in\QRoles}{
        \SendUnreliableP{\SessionChannel}{\ProposerRole}{\AcceptorRole}{\LTwoA}{prop}}.
        \End
    \vartriangleright
    \SEnvEntry{\SessionChannel}{\ProposerRole}{\DotForall{\AcceptorRole\in\QRoles}{\SendUnreliableL{\AcceptorRole}{\LTwoA}{\Proposal{\Value}}}.\End}$}

\LeftLabel{$\ProposerProofFalse =$}
\RightLabel{$\RWsel$}
\UnaryInfC{$\GammaXV\vdash \SendWeaklyP{\SessionChannel}{\ProposerRole}{\AQ}{\Accept}\ldots \vartriangleright \SEnvEntry{\SessionChannel}{\ProposerRole}{\SendWeaklyL{\AQ}{\Accept . \TpAccept \oplus \Restart . \RecursionVariableType \oplus \Abort .\End}}$}
\end{prooftree}
After applying $\RUsend$ we can apply $\RUsend$ once for every acceptor in $\AQ$.
Finally, we can finish $\ProposerProofFalse$ — and with it $\ProposerProof{}$ — by applying $\REnd$.

\subsection{Acceptor}
To improve readability of the proof trees we break down the acceptor's process and local type.

\begin{align*}
\Pa{t}{
    \SessionChannel,
    \AcceptorRole,
    \ProposerRole,
    \NumberRegister_{\ProcessIndexJ},
    \ProposalRegister_{\ProcessIndexJ}
} =
& \update{\NumberRegister_{\ProcessIndexK}}{n'}.\SendUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneB}{\Promise{\ProposalRegister_{\ProcessIndexK}}}.\PaTwo{
    \SessionChannel,
    \AcceptorRole,
    \ProposerRole,
    \NumberRegister_{\ProcessIndexJ},
    \ProposalRegister_{\ProcessIndexJ}
}
\\
\Pa{f}{
    \SessionChannel,
    \AcceptorRole,
    \ProposerRole,
    \NumberRegister_{\ProcessIndexJ},
    \ProposalRegister_{\ProcessIndexJ}
} =
&
    \SendUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneB}{\Nack}.
    \PaTwo{
        \SessionChannel,
        \AcceptorRole,
        \ProposerRole,
        \NumberRegister_{\ProcessIndexJ},
        \ProposalRegister_{\ProcessIndexJ}
    }
    \\
\Pa{gt}{
    \SessionChannel,
    \AcceptorRole,
    \ProposerRole,
    \NumberRegister_{\ProcessIndexJ},
    \ProposalRegister_{\ProcessIndexJ}
} =
&
    \If \greaterThan{n'}{\NumberRegister}
    \;\Then \Pa{t}{
        \SessionChannel,
        \AcceptorRole,
        \ProposerRole,
        \NumberRegister_{\ProcessIndexJ},
        \ProposalRegister_{\ProcessIndexJ}
    }
    \;\Else \Pa{f}{
        \SessionChannel,
        \AcceptorRole,
        \ProposerRole,
        \NumberRegister_{\ProcessIndexJ},
        \ProposalRegister_{\ProcessIndexJ}
    }
\end{align*}
With $\Pa{gt}{
    \SessionChannel,
    \AcceptorRole,
    \ProposerRole,
    \NumberRegister_{\ProcessIndexJ},
    \ProposalRegister_{\ProcessIndexJ}
}$, $\PaOne{
    \SessionChannel,
    \AcceptorRole,
    \ProposerRole,
    \NumberRegister_{\ProcessIndexJ},
    \ProposalRegister_{\ProcessIndexJ}
}$ can be rewritten.

\begin{align*}
\PaOne{
\SessionChannel,
\AcceptorRole,
\ProposerRole,
\NumberRegister_{\ProcessIndexJ},
\ProposalRegister_{\ProcessIndexJ}
} =
&
    \Mu{\RecursionVariable}
    \ReceiveUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneA}{\bot}{n'}.\\
&
    \If n'=\bot\\
&
    \Then
        \SendUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneB}{\bot}.
        \PaTwo{
            \SessionChannel,
            \AcceptorRole,
            \ProposerRole,
            \NumberRegister_{\ProcessIndexJ},
            \ProposalRegister_{\ProcessIndexJ}
        }\\
&
    \Else
        \Pa{gt}{
            \SessionChannel,
            \AcceptorRole,
            \ProposerRole,
            \NumberRegister_{\ProcessIndexJ},
            \ProposalRegister_{\ProcessIndexJ}
        }
\end{align*}

\begin{align*}    
\TaAccept =& \ReceiveUnreliableL{\ProposerRole}{\LTwoA}{\Proposal{\Value}}.\End
\\
\TaBranch =& \ReceiveWeaklyL{\ProposerRole}{\Accept . \TaAccept , \Restart . \RecursionVariableType , \Abort .\End}{\Abort}
\\
\TaOneB =& \SendUnreliableL{\ProposerRole}{\LOneB}{\Promise{\Value}} . \TaBranch
\end{align*}

The acceptor's local type $\IndexedGlobalTypeProjection{\ProcessIndexK}{\AcceptorRole}$ can be written as $\IndexedGlobalTypeProjection{\ProcessIndexK}{\AcceptorRole} = \Mu{\RecursionVariableType}\ReceiveUnreliableL{\ProposerRole}{\LOneA}{\mathbb{N}}.\TaOneB$.

Finally, we define the global environments $\GammaX$, $\GammaXN$, and $\GammaXNP$.

\begin{align*}
&\GammaX = \Gamma \cdot \GEnvEntry{\RecursionVariable}{\RecursionVariableType}\\
&\GammaXN = \GammaX \cdot \GEnvEntry{n'}{\mathbb{N}}\\
&\GammaXNP = \GammaXN \cdot \GEnvEntry{pr'}{\Proposal{\Value}}
\end{align*}

$\GammaX$ contains $\Gamma$ and assigns the type $\RecursionVariableType$ to $\RecursionVariable$.
$\GammaXN$ additionally maps $n'$ to type $\mathbb{N}$.
$\GammaXNP$ adds type $\Proposal{\Value}$ for $pr'$.

% (A_1)
\begin{prooftree}
\AxiomC{$\AcceptorProofTwo$}
\noLine
\UnaryInfC{$\GammaXN\vdash \PaTwo{\ldots} \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\TaBranch}$}
\RightLabel{$\RUsend$}
\UnaryInfC{$\GammaXN\vdash \SendUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneB}{\bot}.\PaTwo{\ldots} \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\TaOneB}$}

\AxiomC{$\AcceptorProof{gt}$}
\noLine
\UnaryInfC{$\GammaXN\vdash \Pa{gt}{\ldots} \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\TaOneB}$}

\RightLabel{$\RIf$}
\BinaryInfC{$\GammaXN\vdash
    \If n'=\bot
    \;\Then \SendUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneB}{\bot}.\PaTwo{\ldots}
    \;\Else \If \greaterThan{n'}{\NumberRegister_{\ProcessIndexJ}} \ldots
    \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\TaOneB}$}

\RightLabel{$\RUget$}
\UnaryInfC{$\GammaX \vdash
    \ReceiveUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneA}{\bot}{n'}.
    \If n'=\bot \ldots
    \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\ReceiveUnreliableL{\ProposerRole}{\LOneA}{\mathbb{N}}.\TaOneB}$}

\LeftLabel{$\AcceptorProofOne =$}
\RightLabel{$\RRec$}
\UnaryInfC{$\Gamma\vdash \Mu{\RecursionVariable} \ReceiveUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneA}{\bot}{n'}.\ldots \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\Mu{\RecursionVariableType}\ReceiveUnreliableL{\ProposerRole}{\LOneA}{\mathbb{N}}.\ldots}$}
\end{prooftree}
After applying $\RAcc$ in $\SysProof{3}$ the session environment contains the acceptor's local type $\IndexedGlobalTypeProjection{\ProcessIndexK}{\AcceptorRole}$.
We apply $\RRec$ and $\RUget$ and the split the proof tree with $\RIf$.
By applying $\RRec$ and $\RUget$ the global environment expands from $\Gamma$ to $\GammaX$ to $\GammaXN$.
On the left branch we apply $\RUsend$ and continue in $\AcceptorProofTwo$.
The right branch continues in $\AcceptorProof{gt}$.

We examine $\AcceptorProof{gt}$ first, because it contains the proof tree of the left branch $\AcceptorProofTwo$.

% (A_gt)
\begin{prooftree}
\AxiomC{$\AcceptorProofTrue$}
\noLine
\UnaryInfC{$\GammaXN\vdash \Pa{t}{\SessionChannel, \AcceptorRole, \ProposerRole, \NumberRegister_{\ProcessIndexJ}, \ProposalRegister_{\ProcessIndexJ}} \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\TaOneB}$}

\AxiomC{$\AcceptorProofFalse$}
\noLine
\UnaryInfC{$\GammaXN\vdash \Pa{f}{\SessionChannel, \AcceptorRole, \ProposerRole, \NumberRegister_{\ProcessIndexJ}, \ProposalRegister_{\ProcessIndexJ}} \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\TaOneB}$}

\LeftLabel{$\AcceptorProof{gt} =$}
\RightLabel{$\RIf$}
\BinaryInfC{$\GammaXN\vdash
    \If \greaterThan{n'}{\NumberRegister_{\ProcessIndexJ}}
    \;\Then \Pa{t}{\SessionChannel, \AcceptorRole, \ProposerRole, \NumberRegister_{\ProcessIndexJ}, \ProposalRegister_{\ProcessIndexJ}}
    \;\Else \Pa{f}{\SessionChannel, \AcceptorRole, \ProposerRole, \NumberRegister_{\ProcessIndexJ}, \ProposalRegister_{\ProcessIndexJ}}
    \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\TaOneB}$}
\end{prooftree}
First, we split the proof tree with $\RIf$.
We continue the resulting branches in separate proof trees $\AcceptorProofTrue$ and $\AcceptorProofFalse$.

% (A_t)
\begin{prooftree}
\AxiomC{$\AcceptorProofTwo$}
\noLine
\UnaryInfC{$\GammaXN\vdash \PaTwo{\SessionChannel, \AcceptorRole, \ProposerRole, \NumberRegister_{\ProcessIndexJ}, \ProposalRegister_{\ProcessIndexJ}} \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\TaBranch}$}
\LeftLabel{$\AcceptorProofTrue =$}
\RightLabel{$\RUsend$}
\UnaryInfC{$\GammaXN\vdash \SendUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneB}{\Nack}.\PaTwo{\ldots} \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\SendUnreliableL{\ProposerRole}{\LOneB}{\Promise{\Value}} . \TaBranch}$}
\end{prooftree}

% (A_f)
\begin{prooftree}
\AxiomC{$\AcceptorProofTwo$}
\noLine
\UnaryInfC{$\GammaXN\vdash \PaTwo{\SessionChannel, \AcceptorRole, \ProposerRole, \NumberRegister_{\ProcessIndexJ}, \ProposalRegister_{\ProcessIndexJ}} \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\TaBranch}$}
\LeftLabel{$\AcceptorProofFalse =$}
\RightLabel{$\RUsend$}
\UnaryInfC{$\GammaXN\vdash \SendUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LOneB}{\Nack}.\PaTwo{\ldots} \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\SendUnreliableL{\ProposerRole}{\LOneB}{\Promise{\Value}}.\TaBranch}$}
\end{prooftree}

In both, $\AcceptorProofTrue$ and $\AcceptorProofFalse$, we apply $\RUsend$.
We continue with $\AcceptorProofTwo$, which is the proof tree for $\PaTwo{\SessionChannel, \AcceptorRole, \ProposerRole, \NumberRegister_{\ProcessIndexJ}, \ProposalRegister_{\ProcessIndexJ}}$.

% (A_2)
\begin{prooftree}
\AxiomC{$\AcceptorProofAccept$}
\noLine
\UnaryInfC{$\GammaXN\vdash \PaAccept{\ldots} \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\TaAccept}$}

\AxiomC{}
\RightLabel{$\RVar$}
\UnaryInfC{$\GammaXN\vdash \RecursionVariable \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\RecursionVariableType}$}

\AxiomC{}
\RightLabel{$\REnd$}
\UnaryInfC{$\GammaXN\vdash \End \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\End}$}

\LeftLabel{$\AcceptorProofTwo =$}
\RightLabel{$\RWbran$}
\TrinaryInfC{$\GammaXN\vdash \ReceiveWeaklyP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{
    \Accept.
        \PaThree{
            \SessionChannel,
            \AcceptorRole,
            \ProposerRole,
            \NumberRegister_{\ProcessIndexJ},
            \ProposalRegister_{\ProcessIndexJ}
        }
    \oplus \Restart.\RecursionVariable
    \oplus \Abort.\End
} \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\TaBranch}$}
\end{prooftree}
By applying $\RWbran$ we separate the three branches.
From left to right we get an $\Accept$, a $\Restart$, and an $\Abort$ branch.
The proof tree for the $\Accept$ branch is in $\AcceptorProofAccept$.
The $\Restart$ branch can be finished by applying $\RVar$ and the $\Abort$ branch by applying $\REnd$.

% (A_accept)
\begin{prooftree}
\AxiomC{}
\RightLabel{$\REnd$}
\UnaryInfC{$\GammaXNP\vdash \End \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\End}$}

\AxiomC{$\AcceptorProof{update}$}
\noLine
\UnaryInfC{$\GammaXNP\vdash\update{\ProposalRegister_{\ProcessIndexJ}}{pr'}.\ldots \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\End}$}

\AxiomC{}
\RightLabel{$\REnd$}
\UnaryInfC{$\GammaXNP\vdash \End \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\End}$}

\RightLabel{$\RIf$}
\BinaryInfC{$\GammaXNP\vdash
    \If \greaterEqual{\nFromProposal{pr'}}{\NumberRegister_{\ProcessIndexJ}}
    \;\Then \ldots
    \;\Else \End
    \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\End}$}

\RightLabel{$\RIf$}
\BinaryInfC{$\GammaXNP\vdash
    \If pr'=\bot
    \;\Then \End
    \;\Else \ldots
    \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\End}$}
\LeftLabel{$\AcceptorProofAccept =$}
\RightLabel{$\RUget$}
\UnaryInfC{$\GammaXN\vdash
    \ReceiveUnreliableP{\SessionChannel}{\AcceptorRole}{\ProposerRole}{\LTwoA}{\bot}{pr'}.
    \ldots
    \vartriangleright
    \SEnvEntry{\SessionChannel}{\AcceptorRole}{\ReceiveUnreliableL{\ProposerRole}{\LTwoA}{\Proposal{\Value}}.
    \End}$}
\end{prooftree}
We apply $\RUget$ and expand the global session to $\GammaXNP$.
The proof tree is split twice by applying $\RIf$ twice.
The proof trees on the left and on the right are finished by applying $\REnd$.
To keep this proof tree readable we continue the proof of the remaining branch in $\AcceptorProof{update}$.

% (A_update)
\begin{prooftree}
\AxiomC{}
\RightLabel{$\REnd$}
\UnaryInfC{$\GammaXNP\vdash \End \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\End}$}
\RightLabel{$\RSideEffect$}
\UnaryInfC{$\GammaXNP\vdash \update{\NumberRegister_{\ProcessIndexJ}}{\Just{\nFromProposal{pr'}}}.\End \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\End}$}
\LeftLabel{$\AcceptorProof{update} =$}
\RightLabel{$\RSideEffect$}
\UnaryInfC{$\GammaXNP\vdash\update{\ProposalRegister_{\ProcessIndexJ}}{pr'}.\ldots \vartriangleright \SEnvEntry{\SessionChannel}{\AcceptorRole}{\End}$}
\end{prooftree}
Finally, we apply $\RSideEffect$ twice and $\REnd$ once.
This concludes the type check and proves that the model is well-typed.
\qed

\section{Validity, Agreement, and Termination}
% Validity
%% Only a value that has been proposed may be chosen,
% Agreement
%% Only a single value is chosen, and
% Termination
%% If a value has been proposed and sufficient processes remain non-faulty, then eventually some value is chosen (compare to \cite{Lamport05}).
Finally, we can prove \textbf{Validity}: only a value that has been proposed may be chosen \cite{Lamport01}, \textbf{Agreement}: only a single value is chosen \cite{Lamport01}, and \textbf{Termination}: if a value has been proposed and sufficient processes remain non-faulty, then eventually some value is chosen (compare to \cite{Lamport05}).

\subsection{Validity}
%%%%%
% Only a value that has been proposed may be chosen
%%%%%
To prove that only a value that has been proposed may be chosen we examine the communication structure and the origins of the accepted values in our model.
% global type + well-typedness = communication structure is as specfied
Because the model is well-typed we know the communication structure is as specified in global type $\IndexedGlobalType{\ProcessIndexK}$.
Session fidelity ensures there are no communication mismatches \cite{PetersEtal21}.
From \cite{PetersEtal21} we know that validity then holds globally if it holds for each local process.

% labels over which values are sent: l1b, l2a
Labels $\LOneB$ and $\LTwoA$ are used to send values that can be accepted.

% l1b
Label $\LOneB$ is used to send messages of sort $\Promise{\Value}$.
% % acceptors send their previous knowledge to proposer, if available
These messages are sent from the acceptors to a proposer and may contain the acceptors' accepted proposal.
Should an acceptor previously have accepted a proposal, that proposal then contains the accepted value.
$\ProposalRegister_{\ProcessIndexJ}$ contains a proposal that was proposed by a proposer either in the most recent or a previous run of the algorithm and the data it holds is sent over $\LOneB$ without alteration.
The proposer receiving these messages stores them in $\VectorV$ without changing their values.

% l2a
Proposers send a message of sort $\Proposal{\Value}$ to their quorum of acceptors over label $\LTwoA$.
% % promiseValue returns value from input list (which contains either initial or proposed values; received in l1b) or a fresh value, that is then proposed
To do so, proposers pick the best value from a proposal in $\VectorV$, if any is available, with $\promiseValueName$.
An entry in $\VectorV$ contains a proposal $prop$ if it is of the form $\Promise{\Paren{\Just{prop}}}$.
These proposals are either some acceptor's initial accepted proposal or a proposal proposed by a proposer.
Not all entries in $\VectorV$ contain a proposal but if at least one does, $\promiseValueName$ returns the value of one of them.
If no entry in $\VectorV$ contains a proposal a fresh value is chosen and returned.
% % the return value of promiseValue is not altered before proposing
In both cases the return value of $\promiseValueName$ is not altered before being sent over label $\LTwoA$, which constitutes proposing that value.
% % acceptors update their accepted value without alteration
Acceptors that receive and accept this proposal store it without alteration.

% l1a is not used to transmit choosable values
Since label $\LOneA$ is not used to transmit values that can be accepted, we conclude that validity holds for each local process and thus globally.

\subsection{Agreement}
%%%%%
% Only a single value is chosen
%%%%%
% FPcrash => every correct proposer has a quorum to communicate with
% proposal sent via weakly reliable broadcast and then "weakly reliable" message
% FPwskip and FPuskip (for l2a) => disallow suspecting sending proposer that is not crashed at this stage
% acceptors accept proposal
% due to overlapping quorums (majorities) the next proposer knows about the accepted value
% due to the definition of promiseValue that proposer proposes the value that was already accepted.
% all correct acceptors accept the same value
We examine the flow of accepted values through the network to prove that only a single value is chosen.
$\FPcrash$ guarantees that the set of correct acceptors in the quorum of any correct proposer $\ProcessIndexK$ is itself a quorum, \ie an accepting set that can choose a value \cite{Lamport06}.
Should message loss occur in labels $\LOneA$ or $\LOneB$, $\ProcessIndexK$ broadcasts its decision to restart the algorithm.
This broadcast is weakly reliable and thus only fails if $\ProcessIndexK$ crashes because $\FPwskip$ disallows suspicion of correct proposers by acceptors.
Given the definition of $\promiseValueName$, $\ProcessIndexK$ will only propose a fresh value if it has not received any accepted proposals from an acceptor.

In Paxos a quorum is a majority of acceptors.
For any two majorities of acceptors there exists at least one that is contained in both majorities.
So, at least one acceptor in every other proposer's quorum is contained in $\ProcessIndexK$'s quorum.
Thus, if a majority of acceptors accept $\ProcessIndexK$'s proposal it is sent to every other proposer when they reach phase $\POneB$.
These proposers then propagate the accepted value by proposing it again, but with a higher proposal number.
This way all correct acceptors accept the same value.

\subsection{Termination}
%%%%%
% If a value has been proposed and sufficient processes remain non-faulty, then eventually some value is chosen
%%%%%
% global type + well-typedness = absence of deadlocks
% processes either loop forever or terminate
% eventually we get a set of processes where:
% - a quorum-sized number of acceptors
%   - because FPcrash disallows more to crash
% - at least one correct proposer
%   - we haven't actually written this but we do need at least one proposer...
%   - it doesn't matter: If we have no more proposers then no value can be proposed and termination is satisfied. The case where we have at least one proposer is more interesting.
% - every proposer has access to a quorum
%   - because of FPcrash, which disallows any more acceptors to crash
% - one proposer is the distinguished proposer
%   - because of leader election, which we assumed in the model, similar to Lamport01
% with such a set of processes we can simply run the algorithm
% weakly reliable broadcast can't be lost
% message on l2a can't be lost either
% enough acceptors receive and accept the proposal and a value has been chosen

We want to prove that if a value has been proposed and sufficient processes remain non-faulty, then eventually some value is chosen.

Well-typedness ensures that the processes follow the communication structure in $\IndexedGlobalType{\ProcessIndexK}$ and session fidelity ensures the absence of deadlocks \cite{PetersEtal21}.
Thus, processes either loop forever or terminate.
We only need to prove that the implementation eventually exits the loop given our system requirements.
Assuming a failure detector in $\FailureDetectorClass$, eventually any correct proposer is not suspected by any correct acceptor and does not suspect any correct acceptor.
$\FPcrash$ guarantees that all correct proposers can communicate with a set of correct acceptors that forms a quorum.

If all proposers crashed, then no value can be proposed and no value will be chosen.
Termination as defined above is satisfied in this case.

If at least one proposer is correct, there exists a distinguished proposer because our model assumes a mechanism for electing such a proposer.
The distinguished proposer executes the algorithm, communicating with its quorum.
Eventually, it will choose a high enough proposal number and receive enough promises to send a proposal.
The decision to send a proposal as well as the proposal itself are received by enough correct acceptors to form a quorum.
These messages can not be lost due to the weakly reliable branching and our implementation of $\FPml$ for label $\LTwoA$.
The proposal is accepted by a majority of acceptors and thus, a value is chosen.
The distinguished proposer and the corresponding subprocesses of the acceptors in its quorum terminate.
The process repeats with the next distinguished proposer, if any.
Every subprocess of an acceptor corresponding to a crashed proposer can skip the weakly reliable broadcast and terminate.

\subsection{Result}
The preceding proofs show that our model satisfies validity, agreement, and termination.
Regarding validity and termination, the type check assures the absence of communication mismatches.
To prove validity, we only need to examine the data flow of the accepted values to finish the proof.
For termination, we show that the implementation eventually exits the loop, given our system requirements, \ie the failure detectors and implementations of the failure patterns.
Agreement follows from the data flow of accepted values, overlapping quorums, and the way a proposer chooses a proposal value.
