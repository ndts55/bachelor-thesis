\chapter{Analysis}
We take the model from the previous chapter, type check it, and discuss what the type check means for agreement, validity, and termination of the Paxos algorithm.
To execute the type check we project the global type to local types and use the typing rules given in \cite{PetersEtal21}.

\section{Local Types}
Because no communication occurs in the outer session, the  outer session's type is $\OuterGlobalType = \End$.
The projection of $\OuterGlobalType$ to a local type is $\OuterGlobalTypeProjection{k} = \End$ for every $k$.

For $1 \leq \AcceptorIndex \leq \AcceptorCount$ and $\AcceptorCount + 1 \leq \ProposerIndex \leq \AcceptorCount + \ProposerCount$ we project the global type $\GlobalType$ to local types $\GlobalTypeProjection{\ProposerIndex}$ and $\GlobalTypeProjection{\AcceptorIndex}$.

\begin{align*}
&\GlobalTypeProjection{\ProposerIndex} = \Mu{\RecursionVariableType}
\DotForall{\AcceptorIndex\in\AQ}{\SendUnreliableL{\AcceptorIndex}{\LOneA}{\mathbb{N}}} .
\DotForall{\AcceptorIndex\in\AQ}{\ReceiveUnreliableL{\AcceptorIndex}{\LOneB}{\Promise{\Value}}} .\\
&\Indent{1}\SendWeaklyL{\AQ}{\Accept . \DotForall{\AcceptorIndex\in\AQ}{\SendUnreliableL{\AcceptorIndex}{\LTwoA}{\Proposal{\Value}}}.\End , \Restart . \RecursionVariableType , \Abort .\End}
\end{align*}

$\GlobalTypeProjection{\ProposerIndex}$ defines the local type for proposers.
First, the proposer sends a proposal number to all acceptors in its quorum in phase $\POneA$.
It receives their responses in phase $\POneB$ and then branches in phase $\PTwoA$.
We can see that the proposer communicates with all acceptors in its quorum in every phase.

\begin{align*}
&\GlobalTypeProjection{\AcceptorIndex} = \Mu{\RecursionVariableType}
\ReceiveUnreliableL{\ProposerIndex}{\LOneA}{\mathbb{N}} .
\SendUnreliableL{\ProposerIndex}{\LOneB}{\Promise{\Value}} .\\
&\Indent{1}\ReceiveWeaklyL{\ProposerIndex}{\Accept . \ReceiveUnreliableL{\ProposerIndex}{\LTwoA}{\Proposal{\Value}}.\End , \Restart . \RecursionVariableType , \Abort .\End}{\Abort}
\end{align*}

$\GlobalTypeProjection{\AcceptorIndex}$ defines the local type for acceptors, assuming a proposer $\ProposerIndex$.
Since Paxos defines two roles that communicate with each other, their local types complement each other.
An acceptor first receives a proposal number, then it responds with a $\Promise{\Value}$.
Finally, it receives the proposer's branching choice.

\section{Type Check}
\[
\Gamma =
\left(
\GEnvEntry{\OuterSharedPoint}{\OuterGlobalType}
\cdot \GEnvEntry{\SharedPoint{\AcceptorCount+1}}{\GlobalType} \cdot \ldots
\cdot \GEnvEntry{\SharedPoint{\AcceptorCount+\ProposerCount}}{\GlobalType}
\right)
\cdot
\left(
\GEnvEntry{1}{\mathbb{N}}
\cdot \ldots
\cdot \GEnvEntry{\AcceptorCount}{\mathbb{N}}
\cdot \GEnvEntry{\AcceptorCount + 1}{\mathbb{N}}
\cdot \ldots
\cdot \GEnvEntry{\AcceptorCount + \ProposerCount}{\mathbb{N}}
\cdot \GEnvEntry{\ProposerCount}{\mathbb{N}}
\right)
\]

$\Gamma$ contains the type for our shared channels $\OuterSharedPoint$ and $\SharedPoint{n}$ where $\AcceptorCount + 1 \leq n \leq \AcceptorCount + \ProposerCount$.

We start the type check with the global environment $\Gamma$ and the entry point of the model $\Sys{\AcceptorCount}{\ProposerCount}$.
Then, we apply the typing rules in \cite{PetersEtal21} in a proof tree and show that the model can be derived from the axioms $\RVar$ and $\REnd$.

\subsection{System Initialization}
% (S0)
\begin{prooftree}
\AxiomC{$\SysProof{1}$}
\noLine
\UnaryInfC{$\Gamma\vdash \SessionRequest{\OuterSharedPoint}{2}{\OuterSessionChannel}\ldots \vartriangleright \emptyset$}

\AxiomC{$\SysProof{2}$}
\noLine
\UnaryInfC{$\Gamma\vdash \SessionAccept{\OuterSharedPoint}{1}{\OuterSessionChannel} \ldots \vartriangleright \emptyset$}

\AxiomC{$\SysProof{3}$}
\noLine
\UnaryInfC{$\Gamma\vdash \ParallelFor{1 \leq \AcceptorIndex \leq \AcceptorCount} \PaInitShort \vartriangleright \emptyset$}

\RightLabel{$\RPar$}
\BinaryInfC{$\Gamma\vdash \SessionAccept{\OuterSharedPoint}{1}{\OuterSessionChannel} \ldots \Or \ParallelFor{1 \leq \AcceptorIndex \leq \AcceptorCount} \PaInitShort \vartriangleright \emptyset$}

\RightLabel{$\RPar$}
\BinaryInfC{$\Gamma\vdash \SessionRequest{\OuterSharedPoint}{2}{\OuterSessionChannel}.\PpInitShort \Or \SessionAccept{\OuterSharedPoint}{1}{\OuterSessionChannel} \ldots \Or \ParallelFor{1 \leq \AcceptorIndex \leq \AcceptorCount} \PaInitShort \vartriangleright \emptyset$}
\end{prooftree}
We apply $\RPar$ twice and split off into the proof trees $\SysProof{1}$, $\SysProof{2}$, and $\SysProof{3}$.

% (S1)
\begin{prooftree}
\AxiomC{$\ProposerProof{}$}
\noLine
\UnaryInfC{$\Gamma\vdash \SessionRequest{\SharedPoint{\AcceptorCount+\ProposerCount}}{\AcceptorCount+1}{s}.\Pp{} \vartriangleright \SEnvEntry{\OuterSessionChannel}{2}{\OuterGlobalTypeProjection{2}}$}

\LeftLabel{$\SysProof{1} =$}
\RightLabel{$\RRec$}
\UnaryInfC{$\Gamma\vdash \SessionRequest{\OuterSharedPoint}{2}{\OuterSessionChannel}.\PpInit{\AcceptorCount+1}{\genAq{\AcceptorCount+\ProposerCount}{\AcceptorCount}{\ProposerCount}}{\AcceptorCount+\ProposerCount}{\AcceptorCount+\ProposerCount}{\EmptyList} \vartriangleright \emptyset$}
\end{prooftree}
In $\SysProof{1}$ we apply $\RRec$ once.
The rest of the proof tree is in $\ProposerProof{}$.
Note that, since $\OuterGlobalTypeProjection{2} = \End$, $\SEnvEntry{\OuterSessionChannel}{2}{\OuterGlobalTypeProjection{2}} = \emptyset$.
This is relevant later when continuing $\ProposerProof{}$.

% (S2)
\begin{prooftree}
\AxiomC{$\ProposerProof{}$}
\noLine
\UnaryInfC{$\Gamma\vdash \SessionRequest{\SharedPoint{\AcceptorCount+1}}{\AcceptorCount+1}{s}.\Pp{} \vartriangleright \emptyset$}

\AxiomC{$\ldots$}

\AxiomC{$\ProposerProof{}$}
\noLine
\UnaryInfC{$\Gamma\vdash \SessionRequest{\SharedPoint{\AcceptorCount+\ProposerCount-1}}{\AcceptorCount+1}{s}.\Pp{} \vartriangleright \emptyset$}

\RightLabel{$\RPar^{\ProposerCount - 1}$}
\TrinaryInfC{$\Gamma\vdash \ParallelFor{\AcceptorCount < k < \AcceptorCount+\ProposerCount} \PpInit{\AcceptorCount+1}{\genAq{k}{\AcceptorCount}{\ProposerCount}}{k}{k}{\EmptyList} \vartriangleright \SEnvEntry{\OuterSessionChannel}{1}{G\upharpoonright_1}$}

\LeftLabel{$\SysProof{2} =$}
\RightLabel{$\RAcc$}
\UnaryInfC{$\Gamma\vdash \SessionAccept{\OuterSharedPoint}{1}{\OuterSessionChannel} . \ParallelFor{\AcceptorCount < k < \AcceptorCount+\ProposerCount} \PpInitShort \vartriangleright \emptyset$}
\end{prooftree}
Applying $\RAcc$ in $\SysProof{2}$ requires that $\GEnvEntry{\OuterSharedPoint}{\OuterGlobalType} \in \Gamma$.
$\RPar$ is applied $\ProposerCount - 1$ times to separate all the proposer processes.
Each individual proposer can be type checked with the same proof tree $\ProposerProof{}$.
Because $\OuterGlobalTypeProjection{1} = \End$, $\SEnvEntry{\OuterSessionChannel}{1}{\OuterGlobalTypeProjection{1}} = \emptyset$.
The session environment $\Delta$ in $\ProposerProof{}$ is empty for every proposer.

% (S3)
\begin{prooftree}
\AxiomC{$\AcceptorProofOne$}
\noLine
\UnaryInfC{$\Gamma\vdash \PaOne \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\GlobalTypeProjection{\AcceptorIndex}}$}
\RightLabel{$\RAcc$}
\UnaryInfC{$\Gamma\vdash\SessionAccept{\SharedPoint{k}}{\AcceptorIndex}{s}.\PaOne\vartriangleright\emptyset$}
\AxiomC{$\ldots$}
\RightLabel{$\RPar^{\ProposerCount}$}
\BinaryInfC{$\Gamma\vdash\ParallelFor{\AcceptorCount < k \le \AcceptorCount + \ProposerCount} \SessionAccept{\SharedPoint{k}}{\AcceptorCount}{s} . \PaOne\vartriangleright\emptyset$}
\AxiomC{$\ldots$}

\LeftLabel{$\SysProof{3} =$}
\RightLabel{$\RPar^{\AcceptorCount}$}
\BinaryInfC{$\Gamma\vdash\ParallelFor{1 \leq j \leq \AcceptorCount} \left(\ParallelFor{\AcceptorCount < k \le \AcceptorCount + \ProposerCount} \SessionAccept{\SharedPoint{k}}{j}{s} . \PaOne\right) \vartriangleright\emptyset$}
\end{prooftree}
$\RPar$ is applied $\AcceptorCount$ times to separate the individual acceptors and then $\ProposerCount$ times for each acceptor to separate the individual subprocesses.
Since every subprocess of every acceptor behaves like $\PaOne$ and has the same local type, the same proof tree $\AcceptorProofOne$ can be applied.
Applying $\RAcc$ to every subprocess of every acceptor requires $\forall k\in\mathbb{N}: \left(\AcceptorCount + 1 \leq k \land k \leq \AcceptorCount + \ProposerCount \right) \to \GEnvEntry{\SharedPoint{k}}{\GlobalType} \in \Gamma$.

Note that only one acceptor and one of its subprocesses is shown in $\SysProof{3}$.
The other subprocesses and acceptors only differ in their values for the iteration variables $k$ and $j$.
The rest has been left out to improve readability.


\subsection{Proposer}
Let $\ProposerIndex = \AcceptorCount + 1, \AQ = \genAq{k}{\AcceptorCount}{\ProposerCount}, n = k, m = k, \VectorV = \EmptyList$ where $\AcceptorCount < k \leq \AcceptorCount + \ProposerCount$.
This gives us the values for the arguments of $\PpInitName$.
We observe that $\GammaSatisfiesType{p}{\mathbb{N}}$, $\GammaSatisfiesType{k}{\mathbb{N}}$, $\GammaSatisfiesType{n}{\mathbb{N}}$, $\GammaSatisfiesType{m}{\mathbb{N}}$, and $\GammaSatisfiesType{\AQ}{\List{\mathbb{N}}}$.
$p$, $k$, $n$, and $m$ are natural numbers and $\AQ$ is a list of natural numbers under global environment $\Gamma$.

To abbreviate the proposer's local type in the following proof trees we define the following sub-formulae.

\begin{align*}
&\TpAccept = \DotForall{\AcceptorIndex\in\AQ}{\SendUnreliableL{\AcceptorIndex}{\LTwoA}{\Proposal{\Value}}}.\End\\
&\TpBranch = \SendWeaklyL{\AQ}{\Accept . \TpAccept \oplus \Restart . \RecursionVariableType \oplus \Abort .\End}
\end{align*}

Note that $\GlobalTypeProjection{\ProposerIndex} = \Mu{\RecursionVariableType}
\DotForall{\AcceptorIndex\in\AQ}{\SendUnreliableL{\AcceptorIndex}{\LOneA}{\mathbb{N}}} .
\DotForall{\AcceptorIndex\in\AQ}{\ReceiveUnreliableL{\AcceptorIndex}{\LOneB}{\Promise{\Value}}} . \TpBranch$.

In order to shorten the proposer's process we define some variables.

\begin{align*}
&e = \anyNack{\VectorV} \tOr \Paren{\promiseCount{\VectorV} < \ceil{\frac{\ProposerIndex}{2}}}\\
&pn = \proposalNumber{n}{m}\\
&prop = \ProposalC{\Big ( \proposalNumber{n}{m} \Big )}{\Paren{\promiseValue{\VectorV}}}
\end{align*}

The actual values of $e$, $pn$, and $prop$ are not relevant for the type check.
We observe that $\GammaSatisfiesType{e}{\Bool}$, $\GammaSatisfiesType{pn}{\mathbb{N}}$, and $\GammaSatisfiesType{prop}{\Proposal{\Value}}$.

To further abbreviate the terms in the proof trees we define two global environments $\GammaX$ and $\GammaXV$.

\[\GammaX=\Gamma\cdot\GEnvEntry{\RecursionVariable}{\RecursionVariableType}\]

$\GammaX$ contains $\Gamma$ and a type for the recursion variable $\RecursionVariable$.

\[\GammaXV = \GammaX \cdot \GEnvEntry{v_{\AcceptorIndex}}{\Promise{\Value}},\forall\AcceptorIndex\in\AQ\]

$\GammaXV$ contains $\GammaX$ and types for the entries of $\VectorV$.
These are added to the global environment when applying $\RUget$ in phase $\POneB$.

% (P)
\begin{prooftree}
\AxiomC{$\ProposerProofTrue$}
\noLine
\UnaryInfC{$\GammaXV \vdash \SendWeaklyP{s}{\ProposerIndex}{\AQ}{\Restart}{\RecursionVariable} \vartriangleright \SEnvEntry{s}{\ProposerIndex}{\TpBranch}$}

\AxiomC{$\ProposerProofFalse$}
\noLine
\UnaryInfC{$\GammaXV \vdash \SendWeaklyP{s}{\ProposerIndex}{\AQ}{\Accept}{\ldots} \vartriangleright \SEnvEntry{s}{\ProposerIndex}{\TpBranch}$}

\RightLabel{$\RIf$}
\BinaryInfC{$\GammaXV \vdash \If{e} \Then{\SendWeaklyP{s}{\ProposerIndex}{\AQ}{\Restart}{\RecursionVariable}} \Else{\SendWeaklyP{s}{\ProposerIndex}{\AQ}{\Accept}{\ldots}} \vartriangleright \SEnvEntry{s}{\ProposerIndex}{\TpBranch}$}

\RightLabel{$\RUget^{|\AQ|}$}
\UnaryInfC{$\GammaX \vdash \DotForall{\AcceptorIndex\in\AQ}{\ReceiveUnreliableP{s}{\AcceptorIndex}{\ProposerIndex}{\LOneB}{\bot}{v_{\AcceptorIndex}}} \ldots \vartriangleright \SEnvEntry{s}{\ProposerIndex}{\DotForall{\AcceptorIndex\in\AQ}{\ReceiveUnreliableL{\AcceptorIndex}{\LOneB}{\Promise{\Value}}}}$}

\RightLabel{$\RUsend^{|\AQ|}$}
\UnaryInfC{$\GammaX \vdash \DotForall{\AcceptorIndex\in\AQ}{\SendUnreliableP{s}{\ProposerIndex}{\AcceptorIndex}{\LOneA}{pn}} \ldots \vartriangleright \SEnvEntry{s}{\ProposerIndex}{\DotForall{\AcceptorIndex\in\AQ}{\SendUnreliableL{\AcceptorIndex}{\LOneA}{\mathbb{N}}}\ldots}$}

\RightLabel{$\RSideEffect$}
\UnaryInfC{$\GammaX \vdash \update{n}{n+1} \ldots \vartriangleright \SEnvEntry{s}{\ProposerIndex}{\DotForall{\AcceptorIndex\in\AQ}{\SendUnreliableL{\AcceptorIndex}{\LOneA}{\mathbb{N}}}\ldots}$}

\RightLabel{$\RRec$}
\UnaryInfC{$\Gamma\vdash \Mu{\RecursionVariable} \update{n}{n + 1} \ldots \vartriangleright \SEnvEntry{s}{\ProposerIndex}{\Mu{\RecursionVariableType}\DotForall{\AcceptorIndex\in\AQ}{\SendUnreliableL{\AcceptorIndex}{\LOneA}{\mathbb{N}}}\ldots}$}

\LeftLabel{$\ProposerProof{} =$}
\RightLabel{$\RReq$}
\UnaryInfC{$\Gamma\vdash \SessionRequest{\SharedPoint{n}}{\ProposerIndex}{s}.\Pp{} \vartriangleright \emptyset$}
\end{prooftree}
$\ProposerProof{}$ is the continuation of $\SysProof{1}$ and $\SysProof{2}$.
In both proof trees the session environment $\Delta$ was empty.
Here, we apply $\RReq$ and add $\SEnvEntry{s}{\ProposerIndex}{\GlobalTypeProjection{\ProposerIndex}}$ to the session environment.
Applying $\RRec$ changes the global environment from $\Gamma$ to $\GammaX$.
$\RSideEffect$ advances the process.
First $\RUsend$ and then $\RUget$ is applied for every acceptor in $\AQ$.
$\RUget$ expands the session environment to $\GammaXV$.
$\RIf$ splits the proof tree into $\ProposerProofTrue$ and $\ProposerProofFalse$.

% (P_t)
\begin{prooftree}
\AxiomC{}
\RightLabel{$\RVar$}
\UnaryInfC{$\GammaXV\vdash \RecursionVariable \vartriangleright \SEnvEntry{s}{\ProposerIndex}{\RecursionVariableType}$}
\LeftLabel{$\ProposerProofTrue =$}
\RightLabel{$\RWsel$}
\UnaryInfC{$\GammaXV\vdash \SendWeaklyP{s}{\ProposerIndex}{\AQ}{\Restart}{\RecursionVariable} \vartriangleright \SEnvEntry{s}{\ProposerIndex}{\SendWeaklyL{\AQ}{\Accept . \TpAccept \oplus \Restart . \RecursionVariableType \oplus \Abort .\End}}$}
\end{prooftree}
We apply $\RWsel$ and then $\RVar$ to finish $\ProposerProofTrue$.

% (P_f)
\begin{prooftree}
\AxiomC{}
\RightLabel{$\REnd$}
\UnaryInfC{$\GammaXV\vdash \End \vartriangleright \SEnvEntry{s}{\ProposerIndex}{\End}$}
\RightLabel{$\RUsend^{|\AQ|}$}
\UnaryInfC{$\GammaXV\vdash \DotForall{\AcceptorIndex\in\AQ}{\SendUnreliableP{s}{\ProposerIndex}{\AcceptorIndex}{\LTwoA}{prop}}.\End \vartriangleright \SEnvEntry{s}{\ProposerIndex}{\DotForall{\AcceptorIndex\in\AQ}{\SendUnreliableL{\AcceptorIndex}{\LTwoA}{\Proposal{\Value}}}.\End}$}

\LeftLabel{$\ProposerProofFalse =$}
\RightLabel{$\RWsel$}
\UnaryInfC{$\GammaXV\vdash \SendWeaklyP{s}{\ProposerIndex}{\AQ}{\Accept.\ldots} \vartriangleright \SEnvEntry{s}{\ProposerIndex}{\SendWeaklyL{\AQ}{\Accept . \TpAccept \oplus \Restart . \RecursionVariableType \oplus \Abort .\End}}$}
\end{prooftree}
After applying $\RUsend$ we can apply $\RUsend$ once for every acceptor in $\AQ$.
Finally, we can finish $\ProposerProofFalse$ — and with it $\ProposerProof{}$ — by applying $\REnd$.

\subsection{Acceptor}
First, we define the arguments of $\PaInitName$ and $\PaOne$.
Let $\AcceptorIndex = j$ and $\ProposerIndex = \AcceptorCount + 1$ where $1 \leq j \leq \AcceptorCount$.
With session environment $\Gamma$ we have $\GammaSatisfiesType{a}{\mathbb{N}}$ and $\GammaSatisfiesType{p}{\mathbb{N}}$.
% TODO n_a? pr_a?

To improve readability of the proof trees we break down the acceptor's process and local type.

\begin{align*}
&\PaAccept = \ReceiveUnreliableP{s}{\ProposerIndex}{\AcceptorIndex}{\LTwoA}{\bot}{pr'} .
\If{pr' = \bot}\\
&\Indent{1}\Then{\End}\\
&\Indent{1}\Else{\If{\greaterEqual{\nFromProposal{pr'}}{n}}\\
&\Indent{2}\Then{\update{pr}{pr'} . \update{n}{\Just{\nFromProposal{pr'}}}.\End}\\
&\Indent{2}\Else{\End}}
\end{align*}
We can see that $\PaTwo$ contains $\PaAccept$ as $\PaTwo = \ReceiveWeaklyP{s}{\ProposerIndex}{\AcceptorIndex}{\Accept . \PaAccept \oplus \Restart . \RecursionVariable \oplus \Abort . \End}$.

\begin{align*}
&\Pa{t} = \update{n}{n'}.\SendUnreliableP{s}{\AcceptorIndex}{\ProposerIndex}{\LOneB}{\Promise{pr}}.\PaTwo
\\\\
&\Pa{f} = \SendUnreliableP{s}{\AcceptorIndex}{\ProposerIndex}{\LOneB}{\Nack{n}}.\PaTwo
\\\\
&\Pa{gt} = \If{\greaterThan{n'}{n}}\Then{\Pa{t}}\Else{\Pa{f}}
\end{align*}
With $\Pa{gt}$, $\PaOne$ can be written as $\PaOne = \Mu{\RecursionVariable}\ReceiveUnreliableP{s}{\ProposerIndex}{\AcceptorIndex}{\LOneA}{\bot}{n'}.\If{n'=\bot}\Then{\SendUnreliableP{s}{\AcceptorIndex}{\ProposerIndex}{\LOneB}{\bot}.\PaTwo}\Else{\Pa{gt}}$.

\begin{align*}    
&\TaAccept = \ReceiveUnreliableL{\ProposerIndex}{\LTwoA}{\Proposal{\Value}}.\End
\\\\
&\TaBranch = \ReceiveWeaklyL{\ProposerIndex}{\Accept . \TaAccept , \Restart . \RecursionVariableType , \Abort .\End}{\Abort}
\\\\
&\TaOneB = \SendUnreliableL{\ProposerIndex}{\LOneB}{\Promise{\Value}} . \TaBranch
\end{align*}

The acceptor's local type $\GlobalTypeProjection{\AcceptorIndex}$ can be written as $\GlobalTypeProjection{\AcceptorIndex} = \Mu{\RecursionVariableType}\ReceiveUnreliableL{\ProposerIndex}{\LOneA}{\mathbb{N}}.\TaOneB$.

Finally, we define the global environments $\GammaX$, $\GammaXN$, and $\GammaXNP$.

\begin{align*}
&\GammaX = \Gamma \cdot \GEnvEntry{\RecursionVariable}{\RecursionVariableType}\\
&\GammaXN = \GammaX \cdot \GEnvEntry{n'}{\mathbb{N}}\\
&\GammaXNP = \GammaXN \cdot \GEnvEntry{pr'}{\Proposal{\Value}}
\end{align*}

$\GammaX$ contains $\Gamma$ and assigns the type $\RecursionVariableType$ to $\RecursionVariable$.
$\GammaXN$ additionally maps $n'$ to type $\mathbb{N}$.
$\GammaXNP$ adds type $\Proposal{\Value}$ for $pr'$.

% (A_1)
\begin{prooftree}
\AxiomC{$\AcceptorProofTwo$}
\noLine
\UnaryInfC{$\GammaXN\vdash \PaTwo \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\TaBranch}$}
\RightLabel{$\RUsend$}
\UnaryInfC{$\GammaXN\vdash \SendUnreliableP{s}{\AcceptorIndex}{\ProposerIndex}{\LOneB}{\bot}.\PaTwo \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\TaOneB}$}

\AxiomC{$\AcceptorProof{gt}$}
\noLine
\UnaryInfC{$\GammaXN\vdash \Pa{gt} \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\TaOneB}$}

\RightLabel{$\RIf$}
\BinaryInfC{$\GammaXN\vdash \If{n'=\bot}\Then{\SendUnreliableP{s}{\AcceptorIndex}{\ProposerIndex}{\LOneB}{\bot}.\PaTwo}\Else{\If{\greaterThan{n'}{n}}\ldots} \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\TaOneB}$}

\RightLabel{$\RUget$}
\UnaryInfC{$\GammaX \vdash \ReceiveUnreliableP{s}{\ProposerIndex}{\AcceptorIndex}{\LOneA}{\bot}{n'}.\If{n'=\bot}\ldots \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\ReceiveUnreliableL{\ProposerIndex}{\LOneA}{\mathbb{N}}.\TaOneB}$}

\LeftLabel{$\AcceptorProofOne =$}
\RightLabel{$\RRec$}
\UnaryInfC{$\Gamma\vdash \Mu{\RecursionVariable} \ReceiveUnreliableP{s}{\ProposerIndex}{\AcceptorIndex}{\LOneA}{\bot}{n'}.\ldots \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\Mu{\RecursionVariableType}\ReceiveUnreliableL{\ProposerIndex}{\LOneA}{\mathbb{N}}.\ldots}$}
\end{prooftree}
After applying $\RAcc$ in $\SysProof{3}$ the session environment contains the acceptor's local type $\GlobalTypeProjection{\AcceptorIndex}$.
We apply $\RRec$ and $\RUget$ and the split the proof tree with $\RIf$.
By applying $\RRec$ and $\RUget$ the global environment expands from $\Gamma$ to $\GammaX$ to $\GammaXN$.
On the left branch we apply $\RUsend$ and continue in $\AcceptorProofTwo$.
The right branch continues in $\AcceptorProof{gt}$.

We examine $\AcceptorProof{gt}$ first, because it contains the proof tree of the left branch $\AcceptorProofTwo$.

% (A_gt)
\begin{prooftree}
\AxiomC{$\AcceptorProofTrue$}
\noLine
\UnaryInfC{$\GammaXN\vdash \Pa{t} \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\TaOneB}$}

\AxiomC{$\AcceptorProofFalse$}
\noLine
\UnaryInfC{$\GammaXN\vdash \Pa{f} \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\TaOneB}$}

\LeftLabel{$\AcceptorProof{gt} =$}
\RightLabel{$\RIf$}
\BinaryInfC{$\GammaXN\vdash \If{\greaterThan{n'}{n}}\Then{\Pa{t}}\Else{\Pa{f}} \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\TaOneB}$}
\end{prooftree}
First, we split the proof tree with $\RIf$.
We continue the resulting branches in separate proof trees $\AcceptorProofTrue$ and $\AcceptorProofFalse$.

% (A_t)
\begin{prooftree}
\AxiomC{$\AcceptorProofTwo$}
\noLine
\UnaryInfC{$\GammaXN\vdash \PaTwo \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\TaBranch}$}
\LeftLabel{$\AcceptorProofTrue =$}
\RightLabel{$\RUsend$}
\UnaryInfC{$\GammaXN\vdash \SendUnreliableP{s}{\AcceptorIndex}{\ProposerIndex}{\LOneB}{\Nack{n}}.\PaTwo \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\SendUnreliableL{\ProposerIndex}{\LOneB}{\Promise{\Value}} . \TaBranch}$}
\end{prooftree}

% (A_f)
\begin{prooftree}
\AxiomC{$\AcceptorProofTwo$}
\noLine
\UnaryInfC{$\GammaXN\vdash \PaTwo \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\TaBranch}$}
\LeftLabel{$\AcceptorProofFalse =$}
\RightLabel{$\RUsend$}
\UnaryInfC{$\GammaXN\vdash \SendUnreliableP{s}{\AcceptorIndex}{\ProposerIndex}{\LOneB}{\Nack{n}}.\PaTwo \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\SendUnreliableL{\ProposerIndex}{\LOneB}{\Promise{\Value}}.\TaBranch}$}
\end{prooftree}

In both, $\AcceptorProofTrue$ and $\AcceptorProofFalse$, we apply $\RUsend$.
Now we can examine $\AcceptorProofTwo$, which is the proof tree for $\PaTwo$.

% (A_2)
\begin{prooftree}
\AxiomC{$\AcceptorProofAccept$}
\noLine
\UnaryInfC{$\GammaXN\vdash \PaAccept \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\TaAccept}$}

\AxiomC{}
\RightLabel{$\RVar$}
\UnaryInfC{$\GammaXN\vdash \RecursionVariable \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\RecursionVariableType}$}

\AxiomC{}
\RightLabel{$\REnd$}
\UnaryInfC{$\GammaXN\vdash \End \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\End}$}

\LeftLabel{$\AcceptorProofTwo =$}
\RightLabel{$\RWbran$}
\TrinaryInfC{$\GammaXN\vdash \PaTwo \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\TaBranch}$}
\end{prooftree}
By applying $\RWbran$ we separate the three branches.
From left to right we get an $\Accept$, a $\Restart$, and an $\Abort$ branch.
The proof tree for the $\Accept$ branch is in $\AcceptorProofAccept$.
The $\Restart$ branch can be finished by applying $\RVar$ and the $\Abort$ branch by applying $\REnd$.

% (A_accept)
\begin{prooftree}
\AxiomC{}
\RightLabel{$\REnd$}
\UnaryInfC{$\GammaXNP\vdash \End \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\End}$}

\AxiomC{$\AcceptorProof{update}$}
\noLine
\UnaryInfC{$\GammaXNP\vdash\update{pr}{pr'}.\ldots \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\End}$}

\AxiomC{}
\RightLabel{$\REnd$}
\UnaryInfC{$\GammaXNP\vdash \End \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\End}$}

\RightLabel{$\RIf$}
\BinaryInfC{$\GammaXNP\vdash \If{\greaterEqual{\nFromProposal{pr'}}{n}}\Then{\ldots}\Else{\End} \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\End}$}

\RightLabel{$\RIf$}
\BinaryInfC{$\GammaXNP\vdash \If{pr'=\bot}\Then{\End}\Else{\ldots} \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\End}$}
\LeftLabel{$\AcceptorProofAccept =$}
\RightLabel{$\RUget$}
\UnaryInfC{$\GammaXN\vdash \ReceiveUnreliableP{s}{\ProposerIndex}{\AcceptorIndex}{\LTwoA}{\bot}{pr'}.\ldots \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\ReceiveUnreliableL{\ProposerIndex}{\LTwoA}{\Proposal{\Value}}.\End}$}
\end{prooftree}
We apply $\RUget$ and expand the global session to $\GammaXNP$.
The proof tree is split twice by applying $\RIf$ twice.
The proof trees on the left and on the right are finished by applying $\REnd$.
To keep this proof tree readable we continue the proof of the remaining branch in $\AcceptorProof{update}$.

% (A_update)
\begin{prooftree}
\AxiomC{}
\RightLabel{$\REnd$}
\UnaryInfC{$\GammaXNP\vdash \End \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\End}$}
\RightLabel{$\RSideEffect$}
\UnaryInfC{$\GammaXNP\vdash \update{n}{\Just{\nFromProposal{pr'}}}.\End \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\End}$}
\LeftLabel{$\AcceptorProof{update} =$}
\RightLabel{$\RSideEffect$}
\UnaryInfC{$\GammaXNP\vdash\update{pr}{pr'}.\ldots \vartriangleright \SEnvEntry{s}{\AcceptorIndex}{\End}$}
\end{prooftree}
Finally, we apply $\RSideEffect$ twice and $\REnd$ once.
This concludes the type check and proves that the model is well-typed.

\section{Termination, Agreement, Validity}
% Termination
% % Eventually, every correct process decides some value.
% Validity
% % If all the correct processes proposed the same value v, then any correct process must decide v.
% Agreement
% % Every correct process must agree on the same value.
\subsection{Termination}
The global type and well-typedness ensure the absence of deadlocks.
This means that the processes either loop forever or terminate.
Acceptors terminate if all of their subprocesses terminate.
Each subprocess of an acceptor corresponds to one proposer.
A subprocess can only terminate via the weakly reliable broadcast in $\PaTwo$, which depends on the corresponding proposer.
If that proposer crashes or its quorum does not include the acceptor, the subprocess terminates because $\FPwskip$ returns $\True$ and the default branch is $\Abort$, which terminates immediately.
The termination of a subprocess with a correct proposer requires the termination of that proposer.
Thus, we need to prove that correct proposers terminate to prove termination for our model.

If the set of acceptors in a proposer's quorum $\AQ$ that are correct is not enough to form a majority of acceptors, that proposer repeatedly restarts the algorithm.
In this case the proposer will be unable to issue a valid proposal.
Because $\FPcrash$ returns $\True$ if $\AQ\setminus\SetOfPermanentlySuspectedProcesses$, where $\SetOfPermanentlySuspectedProcesses$ is the set of processes permanently suspected by a failure detector in $\FailureDetectorClass$, is not a quorum, the proposer eventually crashes.
Proposers either complete the Paxos algorithm after phase $\PTwoA$ or crash.

In \cite{Lamport01} \citeauthor{Lamport01} describes a scenario in which two proposers loop endlessly, never having their proposals accepted:
Proposer $p$ completes phase 1 for a proposal number $n_1$. Another proposer $q$ then completes phase 1 for a proposal number $n_2 > n_1$.
Proposer $p$'s phase 2 accept requests for a proposal numbered $n_1$ are ignored because the acceptors have all promised not to accept any new proposal numbered less than $n_2$.
So, proposer $p$ then begins and completes phase 1 for a new proposal number $n_3 > n_2$, causing the second phase 2 accept requests of proposer $q$ to be ignored.
And so on.

From \cite{Lamport01} we know that this problem is solved by electing a single distinguished proposer to be the leader.
The leader eventually picks a proposal number high enough for its proposal to be accepted.
The model assumes some sort of leader selection.
A new leader is elected when the previous leader terminates.

\subsection{Agreement}
% def: every correct process must agree on the same value
Any proposer $\ProposerIndex$ requires that the set of correct acceptors in its quorum of acceptors is itself a quorum, i.e. an accepting set with which a value can be chosen \cite{Lamport06}.
Should message loss occur in labels $\LOneA$ or $\LOneB$, $\ProposerIndex$ restarts the algorithm.
This broadcast is weakly reliable and thus only fails when $\ProposerIndex$ crashes or terminates because $\FPwskip$ disallows suspicion of correct proposers by acceptors.
% TODO This is not _exactly_ right. Explain it _exactly_ right.
Given the definition of $\promiseValueName$, $\ProposerIndex$ will only propose a fresh value if none of the acceptors have accepted a proposal yet.
At least one acceptor in every other proposer's quorum is contained in $\ProposerIndex$'s quorum.
Thus, if a majority of acceptors accept $\ProposerIndex$'s proposal it is sent to every other proposer when they reach phase $\POneB$.
These proposers then propagate the accepted value by proposing it again but with a higher proposal number.
This way all correct acceptors accept the same value.

\subsection{Validity}
% The implementation satisfies validity.
To prove validity for our model we examine the communication structure and the origins of the accepted values.
% global type + well-typedness = communication structure is as specfied
Because the model is well-typed we know the communication structure is as specified in global type $\GlobalType$.
% Because of the global type and the communication protocol it ensures following session fidelity in Theorem 4—there are no communication mismatches and the received messages are of the expected sort—, then validity holds globally.
From \cite{PetersEtal21} we know that validity then holds globally if it holds for each local process.

% labels over which values are sent: l1b, l2a
Labels $\LOneB$ and $\LTwoA$ are used to send values that can be accepted.

% l1b
Label $\LOneB$ is used to send messages of sort $\Promise{\Value}$.
% % acceptors send their previous knowledge to proposer, if available
These messages are sent from the acceptors to a proposer and may contain the acceptors' accepted proposal.
Should an acceptor previously have accepted a proposal, that proposal then contains the accepted value.
% % this is either an initial accepted value or an accepted value that was proposed by a proposer
The accepted proposal $pr$ is either the acceptor's already accepted proposal $pr_{\AcceptorIndex}$ or a proposal that was previously proposed by a proposer.
$pr$ is sent over $\LOneB$ without alteration.
The proposer receiving these messages stores them in $\VectorV$ without changing their values.

% l2a
Proposers send a message of sort $\Proposal{\Value}$ to their quorum of acceptors over label $\LTwoA$.
% % promiseValue returns value from input list (which contains either initial or proposed values; received in l1b) or a fresh value, that is then proposed
To do so, proposers pick the best value from a proposal in $\VectorV$, if any is available, with $\promiseValueName$.
An entry in $\VectorV$ contains a proposal $prop$ if it is of the form $\Promise{\Just{prop}}$.
These proposals are either some acceptor's initial accepted proposal or a proposal proposed by a proposer.
Not all entries in $\VectorV$ contain a proposal but if at least one does, $\promiseValueName$ returns the value of one of them.
If no entry in $\VectorV$ contains a proposal a fresh value is chosen and returned.
% % the return value of promiseValue is not altered before proposing
In both cases the return value of $\promiseValueName$ is not altered before being sent over label $\LTwoA$, which constitutes proposing that value.
% % acceptors update their accepted value without alteration
Acceptors that receive and accept this proposal store it without alteration.

% l1a is not used to transmit choosable values
Since label $\LOneA$ is not used to transmit values that can be accepted, we conclude that validity holds for each local process and thus globally.
