@InProceedings{AguileraChenToueg97,
author="Aguilera, M.K.
and Chen, W.
and Toueg, S.",
editor="Mavronicolas, M.
and Tsigas, P.",
title="Heartbeat: A timeout-free failure detector for quiescent reliable communication",
booktitle="Distributed Algorithms",
year="1997",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="126--140",
abstract="We study the problem of achieving reliable communication with quiescent algorithms (i.e., algorithms that eventually stop sending messages) in asynchronous systems with process crashes and lossy links. We first show that it is impossible to solve this problem without failure detectors. We then show how to solve it using a new failure detector, called heartbeat. In contrast to previous failure detectors that have been used to circumvent impossibility results, the heartbeat failure detector is implementable, and its implementation does not use timeouts. These results have wide applicability: they can be used to transform many existing algorithms that tolerate only process crashes into quiescent algorithms that tolerate both process crashes and message losses. This can be applied to consensus, atomic broadcast, k-set agreement, atomic commitment, etc. The heartbeat failure detector is novel: besides being implementable without timeouts, it does not output lists of suspects as typical failure detectors do. If we restrict failure detectors to output only lists of suspects, quiescent reliable communication requires ◊P [2], which is not implementable. Combined with the results of this paper, this shows that traditional failure detectors that output only lists of suspects have fundamental limitations.",
isbn="978-3-540-69600-1"
}
@InProceedings{BettiniEtal08,
author="Bettini, L.
and Coppo, M.
and D'Antoni, L.
and De Luca, M.
and Dezani-Ciancaglini, M.
and Yoshida, N.",
editor="van Breugel, F.
and Chechik, M.",
title="Global Progress in Dynamically Interleaved Multiparty Sessions",
booktitle="CONCUR 2008 - Concurrency Theory",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="418--433",
abstract="A multiparty session forms a unit of structured interactions among many participants which follow a prescribed scenario specified as a global type signature. This paper develops, besides a more traditional communication type system, a novel static interaction type system for global progress in dynamically interleaved multiparty sessions.",
isbn="978-3-540-85361-9"
}
@InProceedings{BocciEtal10,
author="Bocchi, L.
and Honda, K.
and Tuosto, E.
and Yoshida, N.",
editor="Gastin, P.
and Laroussinie, F.",
title="A Theory of Design-by-Contract for Distributed Multiparty Interactions",
booktitle="CONCUR 2010 - Concurrency Theory",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="162--176",
abstract="Design by Contract (DbC) promotes reliable software development through elaboration of type signatures for sequential programs with logical predicates. This paper presents an assertion method, based on the $\pi$-calculus with full recursion, which generalises the notion of DbC to multiparty distributed interactions to enable effective specification and verification of distributed multiparty protocols. Centring on global assertions and their projections onto endpoint assertions, our method allows clear specifications for typed sessions, constraining the content of the exchanged messages, the choice of sub-conversations to follow, and invariants on recursions. The paper presents key theoretical foundations of this framework, including a sound and relatively complete compositional proof system for verifying processes against assertions.",
isbn="978-3-642-15375-4"
}
@article{CairesVieira10,
title = {Conversation types},
journal = {Theoretical Computer Science},
volume = {411},
number = {51},
pages = {4399-4440},
year = {2010},
note = {European Symposium on Programming 2009},
issn = {0304-3975},
doi = {https://doi.org/10.1016/j.tcs.2010.09.010},
url = {https://www.sciencedirect.com/science/article/pii/S0304397510004895},
author = {L. Caires and H.T. Vieira},
keywords = {Behavioral types, Distributed systems, Program analysis, Service-based systems, Session types},
abstract = {We present a type theory for analyzing concurrent multiparty interactions as found in service-oriented computing. Our theory introduces a novel and flexible type structure, able to uniformly describe both the internal and the interface behavior of systems, referred respectively as choreographies and contracts in web-services terminology. The notion of conversation builds on the fundamental concept of session, but generalizes it along directions up to now unexplored; in particular, conversation types discipline interactions in conversations while accounting for dynamical join and leave of an unanticipated number of participants. We prove that well-typed systems never violate the prescribed conversation constraints. We also present techniques to ensure progress of systems involving several interleaved conversations, a previously open problem.}
}
@article{ChandraToueg96,
author = {Chandra, T.D. and Toueg, S.},
title = {Unreliable Failure Detectors for Reliable Distributed Systems},
year = {1996},
issue_date = {March 1996},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {43},
number = {2},
issn = {0004-5411},
url = {https://doi.org/10.1145/226643.226647},
doi = {10.1145/226643.226647},
abstract = {We introduce the concept of unreliable failure detectors and study how they can be
used to solve Consensus in asynchronous systems with crash failures. We characterise
unreliable failure detectors in terms of two properties—completeness and accuracy.
We show that Consensus can be solved even with unreliable failure detectors that make
an infinite number of mistakes, and determine which ones can be used to solve Consensus
despite any  number of crashes, and which ones require a majority of correct processes.
We prove that Consensus and Atomic Broadcast are reducible to each other in asynchronous
systems with crash failures; thus, the above results also apply to Atomic Broadcast.
A companion paper shows that one of the failure detectors introduced here is the weakest
failure detector for solving Consensus [Chandra et al. 1992].},
journal = {J. ACM},
month = 3,
pages = {225–267},
numpages = {43},
keywords = {failure detection, asynchronous systems, fault-tolerance, atomic broadcast, message passing, commit problem, partial synchrony, consensus problem, processor failures, Byzantine Generals' problem, crash failures, agreement problem}
}
@Inbook{CoppoEtal15,
author="Coppo, M.
and Dezani-Ciancaglini, M.
and Padovani, L.
and Yoshida, N.",
editor="Bernardo, M.
and Johnsen, Einar B.",
title="A Gentle Introduction to Multiparty Asynchronous Session Types",
bookTitle="Formal Methods for Multicore Programming: 15th International School on Formal Methods for the Design of Computer, Communication, and Software Systems, SFM 2015, Bertinoro, Italy, June 15-19, 2015, Advanced Lectures",
year="2015",
publisher="Springer International Publishing",
address="Cham",
pages="146--178",
abstract="This article provides a gentle introduction to multiparty session types, a class of behavioural types specifically targeted at describing protocols in distributed systems based on asynchronous communication. The type system ensures well-typed processes to enjoy non-trivial properties, including communication safety, protocol fidelity, as well as progress. The adoption of multiparty session types can positively affect the whole software lifecycle, from design to deployment, improving software reliability and reducing its development costs.",
isbn="978-3-319-18941-3",
doi="10.1007/978-3-319-18941-3_4",
url="https://doi.org/10.1007/978-3-319-18941-3_4"
}
@book{CoulourisEtal01,
  author         = {G. Coulouris and J. Dollimore and T. Kindberg},
  title          = {Distributed Systems: Concepts and Design (3rd Edition)},
  publisher      = {Addison-Wesley},
  year           = {2001},
  pages          = {452}
}
@article{FischerLynchPaterson85,
author = {Fischer, M.J. and Lynch, N.A. and Paterson, M.S.},
title = {Impossibility of Distributed Consensus with One Faulty Process},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {32},
number = {2},
issn = {0004-5411},
url = {https://doi.org/10.1145/3149.214121},
doi = {10.1145/3149.214121},
abstract = {The consensus problem involves an asynchronous system of processes, some of which may be unreliable. The problem is for the reliable processes to agree on a binary value. In this paper, it is shown that every protocol for this problem has the possibility of nontermination, even with only one faulty process. By way of contrast, solutions are known for the synchronous case, the “Byzantine Generals” problem.},
journal = {J. ACM},
month = {4},
pages = {374-382},
numpages = {9}
}
@inproceedings{HondaYoshidaCarbone08,
author = {Honda, K. and Yoshida, N. and Carbone, M.},
title = {Multiparty Asynchronous Session Types},
year = {2008},
isbn = {9781595936899},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1328438.1328472},
doi = {10.1145/1328438.1328472},
abstract = {Communication is becoming one of the central elements in software development. As a potential typed foundation for structured communication-centred programming, session types have been studied over the last decade for a wide range of process calculi and programming languages, focussing on binary (two-party) sessions. This work extends the foregoing theories of binary session types to multiparty, asynchronous sessions, which often arise in practical communication-centred applications. Presented as a typed calculus for mobile processes, the theory introduces a new notion of types in which interactions involving multiple peers are directly abstracted as a global scenario. Global types retain a friendly type syntax of binary session types while capturing complex causal chains of multiparty asynchronous interactions. A global type plays the role of a shared agreement among communication peers, and is used as a basis of efficient type checking through its projection onto individual peers. The fundamental properties of the session type discipline such as communication safety, progress and session fidelity are established for generaln-party asynchronous interactions.},
booktitle = {Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {273–284},
numpages = {12},
keywords = {structured programming, causality, choreography, session types, mobile processes, multiparty, communications},
location = {San Francisco, California, USA},
series = {POPL '08}
}
@article{hondaYoshidaCarbone16,
author = {Honda, K. and Yoshida, N. and Carbone, M.},
title = {Multiparty Asynchronous Session Types},
year = {2016},
issue_date = {March 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {63},
number = {1},
issn = {0004-5411},
url = {https://doi.org/10.1145/2827695},
doi = {10.1145/2827695},
abstract = {Communication is a central elements in software development. As a potential typed foundation for structured communication-centered programming, session types have been studied over the past decade for a wide range of process calculi and programming languages, focusing on binary (two-party) sessions. This work extends the foregoing theories of binary session types to multiparty, asynchronous sessions, which often arise in practical communication-centered applications. Presented as a typed calculus for mobile processes, the theory introduces a new notion of types in which interactions involving multiple peers are directly abstracted as a global scenario. Global types retain the friendly type syntax of binary session types while specifying dependencies and capturing complex causal chains of multiparty asynchronous interactions. A global type plays the role of a shared agreement among communication peers and is used as a basis of efficient type-checking through its projection onto individual peers. The fundamental properties of the session type discipline, such as communication safety, progress, and session fidelity, are established for general n-party asynchronous interactions.},
journal = {J. ACM},
month = {3},
articleno = {9},
numpages = {67},
keywords = {progress, the pi-calculus, Session types, global protocols, projection, global types}
}
@article{Lamport01,
author = {Lamport, L.},
title = {Paxos Made Simple},
year = {2001},
month = {12},
abstract = {At the PODC 2001 conference, I got tired of everyone saying how difficult it was to understand the Paxos algorithm, published in [122]. Although people got so hung up in the pseudo-Greek names that they found the paper hard to understand, the algorithm itself is very simple. So, I cornered a couple of people at the conference and explained the algorithm to them orally, with no paper. When I got home, I wrote down the explanation as a short note, which I later revised based on comments from Fred Schneider and Butler Lampson. The current version is 13 pages long, and contains no formula more complicated than n1 &gt; n2.},
url = {https://www.microsoft.com/en-us/research/publication/paxos-made-simple/},
pages = {51-58},
journal = {ACM SIGACT News (Distributed Computing Column) 32, 4 (Whole Number 121, December 2001)},
edition = {ACM SIGACT News (Distributed Computing Column) 32, 4 (Whole Number 121, December 2001)},
}
@techreport{Lamport05,
author = {Lamport, Leslie},
title = {Generalized Consensus and Paxos},
year = {2005},
month = {March},
abstract = {In [153], I proved lower bounds for the number of message delays required to reach consensus. I showed that the best algorithms can reach consensus in the normal case in 2 message delays. This result in turn led me to a new version of the Paxos algorithm of [122] called Fast Paxos, described in [158], that achieves this bound. However, Fast Paxos can take 3 message delays in the event of conflict, when two values are proposed concurrently. I showed in [153] that this was unavoidable in a general algorithm, so this seemed to be the last word.

It then occurred to me that, in the state-machine approach (introduced in [27]), such conflicting proposals arise because two different commands are issued concurrently by two clients, and both are proposed as command number i. This conflict is necessary only if the two proposed commands do not commute. If they do, then there is no need to order them. This led me to a new kind of agreement problem that requires dynamically changing agreement on a growing partially ordered set of commands. I realized that generalizing from partially ordered sets of commands to a new mathematical structure I call a c-struct leads to a generalized consensus problem that covers both ordinary consensus and this new dynamic agreement problem. I also realized that Fast Paxos can be generalized to solve this new problem. I wrote up these results in March 2004. However, I was in the embarrassing position of having written a paper generalizing Fast Paxos without having written a paper about Fast Paxos. So, I just let the paper sit on my disk.

I was invited to give a keynote address at the 2004 DSN conference, and I decided to talk about fast and generalized Paxos. Fernando Pedone came up after my talk and introduced himself. He said that he and André Schiper had already published a paper with the same generalization from the command sequences of the state-machine approach to partially ordered sets of commands, together with an algorithm that achieved the same optimal number of message delays in the absence of conflict. It turns out that their algorithm is different from the generalized Paxos algorithm. There are cases in which generalized Paxos takes only 2 message delays while their algorithm takes 3. But the difference in efficiency between the two algorithms is insignificant. The important difference is that generalized Paxos is more elegant.

I've been sitting on this paper for so long because it doesn't seem right to publish a paper on a generalization of Fast Paxos before publishing something about Fast Paxos itself. Since generalized Paxos is a generalization, this paper also explains Fast Paxos. But people's minds don't work that way. They need to understand Fast Paxos before they can really understand its generalization. So, I figured I would turn this paper into the second part of a long paper or monograph whose first part explains Fast Paxos. However, in recent years I've been discovering new Paxonian results faster than I can write them up. It therefore seems silly not to release a paper that I've already written about one of those results. So, I added a brief discussion of the Pedone-Schiper result and a citation to [153] and am posting the paper here. Now that I have written the Fast Paxos paper and submitted it for publication, I may rewrite this paper as part two of that one.},
url = {https://www.microsoft.com/en-us/research/publication/generalized-consensus-and-paxos/},
pages = {60},
number = {MSR-TR-2005-33},
}
@article{Lamport06,
author = {Lamport, L.},
title = {Lower Bounds for Asynchronous Consensus},
year = {2006},
issue_date = {October   2006},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
volume = {19},
number = {2},
issn = {0178-2770},
url = {https://doi.org/10.1007/s00446-006-0155-x},
doi = {10.1007/s00446-006-0155-x},
abstract = {Impossibility results and best-case lower bounds are proved for the number of message
delays and the number of processes required to reach agreement in an asynchronous
consensus algorithm that tolerates non-Byzantine failures. General algorithms exist
that achieve these lower bounds in the normal case, when the response time of non-faulty
processes and the transmission delay of messages they send to one another are bounded.
Our theorems allow algorithms to do better in certain exceptional cases, and such
algorithms are presented. Two of these exceptional algorithms may be of practical
interest.},
journal = {Distrib. Comput.},
month = oct,
pages = {104–125},
numpages = {22},
keywords = {Paxos, Distributed algorithms, Fault tolerance, Consensus}
}
@article{Lamport78,
author = {Lamport, L.},
title = {The Implementation of Reliable Distributed Multiprocess Systems},
year = {1978},
month = {08},
abstract = {In [27], I introduced the idea of implementing any distributed system by using an algorithm to implement an arbitrary state machine in a distributed system. However, the algorithm in [27] assumed that processors never fail and all messages are delivered. This paper gives a fault-tolerant algorithm. It's a real-time algorithm, assuming upper bounds on message delays in the absence of faults, and that nonfaulty processes had clocks synchronized to within a known bound.

To my knowledge, this is the first published paper to discuss arbitrary failures (later called Byzantine failures). It actually considered malicious behavior, not using such behavior simply as a metaphor for completely unpredictable failures. Its algorithm was the inspiration for the digital signature algorithm of [41]. With its use of real-time, this paper presaged the ideas in [55].},
url = {https://www.microsoft.com/en-us/research/publication/implementation-reliable-distributed-multiprocess-systems/},
pages = {95-114},
journal = {Computer Networks},
volume = {2},
}
@article{Lamport98,
author = {Lamport, L.},
title = {The Part-Time Parliament},
year = {1998},
month = {5},
url = {https://www.microsoft.com/en-us/research/publication/part-time-parliament/},
journal = {ACM Transactions on Computer Systems 16, 2 (May 1998), 133-169. Also appeared as SRC Research Report 49. This paper was first submitted in 1990, setting a personal record for publication delay that has since been broken by [60].},
edition = {ACM Transactions on Computer Systems 16, 2 (May 1998), 133-169. Also appeared as SRC Research Report 49. This paper was first submitted in 1990, setting a personal record for publication delay that has since been broken by [60].},
note = {ACM SIGOPS Hall of Fame Award in 2012},
}
@article{MilnerParrowWalker92,
title = {A calculus of mobile processes, I},
journal = {Information and Computation},
volume = {100},
number = {1},
pages = {1-40},
year = {1992},
issn = {0890-5401},
doi = {https://doi.org/10.1016/0890-5401(92)90008-4},
url = {https://www.sciencedirect.com/science/article/pii/0890540192900084},
author = {R. Milner and J. Parrow and D. Walker},
abstract = {We present the π-calculus, a calculus of communicating systems in which one can naturally express processes which have changing structure. Not only may the component agents of a system be arbitrarily linked, but a communication between neighbours may carry information which changes that linkage. The calculus is an extension of the process algebra CCS, following work by Engberg and Nielsen, who added mobility to CCS while preserving its algebraic properties. The π-calculus gains simplicity by removing all distinction between variables and constants; communication links are identified by names, and computation is represented purely as the communication of names across links. After an illustrated description of how the π-calculus generalises conventional process algebras in treating mobility, several examples exploiting mobility are given in some detail. The important examples are the encoding into the π-calculus of higher-order functions (the λ-calculus and combinatory algebra), the transmission of processes as values, and the representation of data structures as processes. The paper continues by presenting the algebraic theory of strong bisimilarity and strong equivalence, including a new notion of equivalence indexed by distinctions—i.e., assumptions of inequality among names. These theories are based upon a semantics in terms of a labeled transition system and a notion of strong bisimulation, both of which are expounded in detail in a companion paper. We also report briefly on work-in-progress based upon the corresponding notion of weak bisimulation, in which internal actions cannot be observed.}
}
@unpublished{PetersEtal21,
  author          = {K. Peters and U. Nestmann and C. Wagner},
  title           = {Fault-Tolerant Multiparty Session Types},
  year            = {2021},
  note            = {Provided by K. Peters.}
}
@article{ScalasEtal18,
  author          = {A. Scalas and N. Yoshida},
  title           = {Multiparty session types, beyond duality},
  journal         = {Journal of Logical and Algebraic Methods in Programming},
  volume          = {97},
  number          = {},
  year            = {2018},
  pages           = {55-84}
}
@book{TanenbaumSteen17,
  author         = {A.S. Tanenbaum and M. van Steen},
  editor         = {},
  title          = {Distributed Systems: principles and paradigms},
  publisher      = {Pearson Prentice Hall},
  year           = {2017}
}
@InProceedings{VieringEtal18,
author="Viering, M.
and Chen, T.
and Eugster, P.
and Hu, R.
and Ziarek, L.",
editor="Ahmed, A.",
title="A Typing Discipline for Statically Verified Crash Failure Handling in Distributed Systems",
booktitle="Programming Languages and Systems",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="799--826",
abstract="A key requirement for many distributed systems is to be resilient toward partial failures, allowing a system to progress despite the failure of some components. This makes programming of such systems daunting, particularly in regards to avoiding inconsistencies due to failures and asynchrony. This work introduces a formal model for crash failure handling in asynchronous distributed systems featuring a lightweight coordinator, modeled in the image of widely used systems such as ZooKeeper and Chubby. We develop a typing discipline based on multiparty session types for this model that supports the specification and static verification of multiparty protocols with explicit failure handling. We show that our type system ensures subject reduction and progress in the presence of failures. In other words, in a well-typed system even if some participants crash during execution, the system is guaranteed to progress in a consistent manner with the remaining participants.",
isbn="978-3-319-89884-1"
}
@InProceedings{YoshidaDanielouBejleriHu10,
author="Yoshida, N.
and Deni{\'e}lou, P.M.
and Bejleri, A.
and Hu, R.",
editor="Ong, L.",
title="Parameterised Multiparty Session Types ",
booktitle="Foundations of Software Science and Computational Structures",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="128--145",
abstract="For many application-level distributed protocols and parallel algorithms, the set of participants, the number of messages or the interaction structure are only known at run-time. This paper proposes a dependent type theory for multiparty sessions which can statically guarantee type-safe, deadlock-free multiparty interactions among processes whose specifications are parameterised by indices. We use the primitive recursion operator from G{\"o}del's System {\$}{\backslash}mathcal T{\$}to express a wide range of communication patterns while keeping type checking decidable. We illustrate our type theory through non-trivial programming and verification examples taken from parallel algorithms and Web services usecases.",
isbn="978-3-642-12032-9"
}
