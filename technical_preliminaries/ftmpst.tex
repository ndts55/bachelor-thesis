\section{Fault-Tolerant Multiparty Session Types}
Our model of the Paxos algorithm uses a fault-tolerant extension of Multiparty Session Types introduced by \citeauthor{PetersEtal21} in \cite{PetersEtal21}.
The following explanation of Fault-Tolerant Multiparty Session Types is from that same paper.

% Fault-Tolerance in Distributed Algorithms
\label{sec:faultTol}
We consider three sources of failure in an \unrel communication:
(1) the sender may crash before it releases the message,
(2) the receiver may crash before it can consume the message, or
(3) the communication medium may lose the message.
Since types consider only static and predictable information, we do not distinguish between different kinds of failure or model their source in types.
Instead, we only allow types, \ie the specifications of systems, to distinguish between potentially faulty and reliable interactions.

We consider three levels of failures in interactions:
\begin{description}
	\item[\StrongR ($ \iR $):] Neither the sender nor the receiver can crash as long as they are involved in this interaction. The message cannot be lost by the communication medium. This form corresponds to reliable communication as it was described in \cite{AguileraChenToueg97} in the context of distributed algorithms.
		This is the standard, failure-free case.
	\item[\WeakR ($ \iW $):] Both the sender and the receiver might crash at every possible point during this interaction. But the communication medium cannot lose the message.
	\item[\Unrel ($ \iU $):] Both the sender and the receiver might crash at every possible point during this interaction and the communication medium might lose the message. There are no guarantees that this interaction---or any part of it---takes place.
\end{description}

\subsection{Fault-Tolerant Types and Processes}

We assume that the sets $ \names $ of names $ \Chan[a], \Chan, \Args \ldots $; $ \roles $ of roles $ \Role[n], \Role, \ldots $; $ \labels $ of labels $ \Label, \LabelD, \ldots $; $ \typeVars $ of type variables $ \TypeV $; and $ \procVars $ of process variables $ \ProcV $ are pairwise distinct.
To simplify the reduction semantics of our session calculus, we use natural numbers as roles (compare to \cite{hondaYoshidaCarbone16}).
Sorts $ \Sort $ range over $ \mathbb{B}, \mathbb{N}, \ldots $.
The set $ \expressions $ of expressions $ \Expr, \Expr[v], \Expr[b], \ldots $ is constructed from the standard Boolean operations, natural numbers, names, and (in)equalities.

Global types specify the desired communication structure of systems from a global point of view.
In local types this global view is projected to the specification of a single role/participant.
We use standard \MPST (\cite{HondaYoshidaCarbone08,hondaYoshidaCarbone16}) extended by operators for \unrel communication and \weakR as shown in Fig.~\ref{fig:syntax}.

\begin{figure}[t]
	\centering
	\renewcommand{\tabcolsep}{1pt}
	\begin{tabular}{|llclr|llclr|llclr|}
		\hline
		\multicolumn{5}{|c|}{Global Types} & \multicolumn{5}{c|}{Local Types} & \multicolumn{5}{c|}{Processes}\\
		&&&&& &&&&& & $ P $ & $ \deffTerms $ & $ \PReq{\Chan[a]}{\Role[n]}{\Chan}{P} $ &\\
		&&&&& &&&&& & & $ \sepTerms $ & $ \PAcc{\Chan[a]}{\Role}{\Chan}{P} $ &\\
		& \multirow{2}{*}{$ \GT $} & \multirow{2}{*}{$ \deffTerms $} & \multirow{2}{*}{$ \GComR{\Role_1}{\Role_2}{\Sort}{\GT} $} & & & $ \LT $ & $ \deffTerms $ & $ \LSendR{\Role_2}{\Sort}{\LT} $ & & & & $ \sepTerms $ & $ \PSendR{\Chan}{\Role_1}{\Role_2}{\Expr}{P} $ &\\
		&&&&& & & $ \sepTerms $ & $ \LGetR{\Role_1}{\Sort}{\LT} $ & & & & $ \sepTerms $ & $ \PGetR{\Chan}{\Role_2}{\Role_1}{\Args}{\PT} $ &\\
		& & \multirow{2}{*}{$ \sepTerms $} & \multirow{2}{*}{$ \GComU{\Role_1}{\Role_2}{\Label}{\Sort}{\GT} $} & & & & $ \sepTerms $ & $ \LSendU{\Role_2}{\Label}{\Sort}{\LT} $ & & & & $ \sepTerms $ & $ \PSendU{\Chan}{\Role_1}{\Role_2}{\Label}{\Expr}{P} $ &\\
		&&&&& & & $ \sepTerms $ & $ \LGetU{\Role_1}{\Label}{\Sort}{\LT} $ & & & & $ \sepTerms $ & $ \PGetU{\Chan}{\Role_2}{\Role_1}{\Label}{\Expr[v]}{\Args}{P} $ &\\
		& & \multirow{2}{*}{$ \sepTerms $} & \multirow{2}{*}{$ \GBranR{\Role_1}{\Role_2}{\Set{ \Label_i.\GT_i}_{i \in \indexSet}} $} & & & & $ \sepTerms $ & $ \LSelR{\Role_2}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}} $ & & & & $ \sepTerms $ & $ \PSelR{\Chan}{\Role_1}{\Role_2}{\Label}{P} $ &\\
		&&&&& & & $ \sepTerms $ & $ \LBranR{\Role_1}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}} $ & & & & $ \sepTerms $ & $ \PBranR{\Chan}{\Role_2}{\Role_1}{\Set{ \Label_i.P_i }_{i \in \indexSet}} $ &\\
		& & \multirow{2}{*}{$ \sepTerms $} & \multirow{2}{*}{$ \GBranW{\Role}{\Role[R]}{\Set{ \Label_i.\GT_i }_{i \in \indexSet, \LabelD}} $} & & & & $ \sepTerms $ & $ \LSelW{\Role[R]}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}} $ & & & & $ \sepTerms $ & $ \PSelW{\Chan}{\Role}{\Role[R]}{\Label}{P} $ &\\
		&&&&& & & $ \sepTerms $ & $ \LBranW{\Role}{\Set{ \Label_i.\LT_i }_{i \in \indexSet, \LabelD}} $ & & & & $ \sepTerms $ & $ \PBranW{\Chan}{\Role_j}{\Role}{\Set{ \Label_i.P_i }_{i \in \indexSet, \LabelD}} $ &\\
		& & $ \sepTerms $ & $ \GPar{\GT_1}{\GT_2} $ & & &&&&& & & $ \sepTerms $ & $ P_1 \mid P_2 $ &\\
		& & $ \sepTerms $ & $ \GRep{\TypeV}{\GT} \sepTerms \TypeV \sepTerms \GEnd $ & & & & $ \sepTerms $ & $ \LRep{\TypeV}{\LT} \sepTerms \TypeV \sepTerms \LEnd $ & & & & $ \sepTerms $ & $ \PRep{\ProcV}{P} \sepTerms \ProcV \sepTerms \PEnd $ &\\
		&&&&& &&&&& & & $ \sepTerms $ & $ \PITE{\Expr[b]}{P_1}{P_2} $ &\\
		&&&&& &&&&& & & $ \sepTerms $ & $ \PRes{\Args}{P} \sepTerms \PCrash $ &\\
		& & \multirow{2}{*}{$ \sepTerms $} & \multirow{2}{*}{$ \GDel{\Role_1}{\Role_2}{\Chan'}{\Role}{\LT}{\GT} $} & & & & $ \sepTerms $ & $ \LDelA{\Role_2}{\Chan'}{\Role}{\LT}{\LT'} $ & & & & $ \sepTerms $ & $ \PDelA{\Chan}{\Role_1}{\Role_2}{\AT{\Chan'}{\Role}}{\PT} $ &\\
		&&&&& & & $ \sepTerms $ & $ \LDelB{\Role_1}{\Chan'}{\Role}{\LT}{\LT'} $ && & & $ \sepTerms $ & $ \PDelB{\Chan}{\Role_2}{\Role_1}{\AT{\Chan'}{\Role}}{\PT} $ &\\
		&&&&& &&&&& & & $ \sepTerms $ & $ \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} $ &\\
		\hline
		\multicolumn{10}{|c|}{Message Types} & \multicolumn{5}{c|}{Messages}\\
		\multicolumn{10}{|c|}{\multirow{2}{*}{$ \MT \deffTerms \MessR{\Sort} \sepTerms \MessU{\Label}{\Sort} \sepTerms \MessBR{\Label} \sepTerms \MessBW{\Label} \sepTerms \AT{\Chan}{\Role} $}} & \multicolumn{5}{c|}{$ \; \Queue \deffTerms \MessR{\Expr[v]} \sepTerms \MessU{\Label}{\Expr[v]} \sepTerms \MessBR{\Label} $}\\
		\multicolumn{10}{|c|}{} &&& $ \sepTerms $ & $ \MessBW{\Label} \sepTerms \AT{\Chan}{\Role} $ &\\
		\hline
	\end{tabular}
	\caption{Syntax of Fault-Tolerant \MPST{}}
	\label{fig:syntax}
\end{figure}

The processes $ \PReq{\Chan[a]}{\Role[n]}{\Chan}{P} $ and $ \PAcc{\Chan[a]}{\Role}{\Chan}{P} $ initialize a new session $ \Chan $ with $ \Role[n] $ roles via the shared channel $ \Chan[a] $ and then proceed as $ \PT $. We identify sessions with their unique session channel.

The type $ \GComR{\Role_1}{\Role_2}{\Sort}{\GT} $ specifies a \strongR communication from role $ \Role_1 $ to role $ \Role_2 $ to transmit a value of the sort $ \Sort $ and then continues with $ \GT $.
A system with this type will be guaranteed to perform a corresponding action.
In a session $ \Chan $ this communication is implemented by the sender $ \PSendR{\Chan}{\Role_1}{\Role_2}{\Expr}{\PT_1} $ (specified as $ \LSendR{\Role_2}{\Sort}{\LT_1} $) and the receiver $ \PGetR{\Chan}{\Role_2}{\Role_1}{\Args}{\PT_2} $ (specified as $ \LGetR{\Role_1}{\Sort}{\LT_2} $).
As result of the communication, the receiver instantiates $ \Args $ in its continuation $ \PT_2 $ with the received value.

The type $ \GComU{\Role_1}{\Role_2}{\Label}{\Sort}{\GT} $ specifies an \unrel communication from $ \Role_1 $ to $ \Role_2 $ transmitting (if successful) a label $ \Label $ and a value of type $ \Sort $ and then continues (regardless of the success of this communication) with $ \GT $.
The \unrel counterparts of senders and receivers are $ \PSendU{\Chan}{\Role_1}{\Role_2}{\Label}{\Expr}{\PT_1} $ (specified as $ \LSendU{\Role_2}{\Label}{\Sort}{\LT_1} $) and $ \PGetU{\Chan}{\Role_2}{\Role_1}{\Label}{\Args[v]}{\Args}{\PT_2} $ (specified as $ \LGetU{\Role_1}{\Label}{\Sort}{\LT_2} $).
The receiver $ \PGetU{\Chan}{\Role_2}{\Role_1}{\Label}{\Args[v]}{\Args}{\PT_2} $ declares a default value $ \Args[v] $ that is used instead of a received value to instantiate $ \Args $ after a failure.

The \strongR branching $ \GBranR{\Role_1}{\Role_2}{\Set{ \Label_i.\GT_i}_{i \in \indexSet}} $ allows $ \Role_1 $ to pick one of the branches offered by $ \Role_2 $.
We identify the branches with their respective label.
Selection of a branch is implemented by $ \PSelR{\Chan}{\Role_1}{\Role_2}{\Label}{P} $ (specified as $ \LSelR{\Role_2}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}} $).
Upon receiving branch $ \Label_j $ from $ \Role_1 $ the process $ \PBranR{\Chan}{\Role_2}{\Role_1}{\Set{ \Label_i.P_i }_{i \in \indexSet}} $ (specified as $ \LBranR{\Role_1}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}} $) continues with $ \PT_j $.

The \weakR counterpart of branching is $ \GBranW{\Role}{\Role[R]}{\Set{\Label_i.\GT_i}_{i \in \indexSet, \LabelD}} $, where $ \Role[R] \subseteq \roles $ and $ \LabelD $ with $ \default \in \indexSet $ is the default branch.
We use a broadcast from $ \Role $ to all roles in $ \Role[R] $ to ensure that the sender can influence several participants with its decision consistently as it is the case for \strongR branching.
The type system will ensure that this branching construct is \weakR, \ie the involved participants might crash, but no message is lost.
Because of that, all processes that are not crashed will move to the same branch.
We often abbreviate branching \wrt to a small set of branches by omitting the set brackets and instead separating the branches by $ \oplus $, where the last branch is always the default branch.
In contrast to the \strongR cases, the \weakR selection $ \PSelW{\Chan}{\Role}{\Role[R]}{\Label}{\PT} $ (specified as $ \LSelW{\Role[R]}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}} $) allows to broadcast its decision to $ \Role[R] $ and $ \PBranW{\Chan}{\Role_j}{\Role}{\Set{ \Label_i.\PT_i }_{i \in \indexSet, \LabelD}} $ (specified as $ \LBranW{\Role}{\Set{ \Label_i.\LT_i }_{i \in \indexSet, \LabelD}} $) defines a default label $ \LabelD $.

The $ \PCrash $ denotes a process that crashed.
Similar to \cite{hondaYoshidaCarbone16}, we use message queues to implement asynchrony in sessions.
Therefore, session initialization introduces a directed and initially empty message queue $ \MQ{\Chan[s]}{\Role_1}{\Role_2}{\emptyList} $ for each pair of roles $ \Role_1 \neq \Role_2 $ of the session $ \Chan[s] $.
We have five kinds of messages and corresponding message types in Fig.~\ref{fig:syntax}---one for each kind of interaction.

The remaining operators for independence $ \GPar{\GT}{\GT'} $; parallel composition $ \PPar{\PT}{\PT'} $; recursion $ \GRep{\TypeV}{\GT} $, $ \PRep{\ProcV}{\PT} $; inaction $ \GEnd $, $ \PEnd $; conditionals $ \PITE{\Expr[b]}{\PT_1}{\PT_2} $; session delegation $ \GDel{\Role_1}{\Role_2}{\Chan'}{\Role}{\LT}{\GT} $, $ \PDelA{\Chan}{\Role_1}{\Role_2}{\AT{\Chan'}{\Role}}{\PT} $, $ \PDelB{\Chan}{\Role_2}{\Role_1}{\AT{\Chan'}{\Role}}{\PT} $; and restriction $ \PRes{\Args}{\PT} $ are all standard.

Our type system verifies processes, \ie implementations, against a specification that is a global type.
Since processes implement local views, local types are used as a mediator between the global specification and the respective local end points.
To ensure that the local types correspond to the global type, they are derived by \emph{projection}.
Instead of the projection function described in \cite{hondaYoshidaCarbone16} we use a more relaxed variant of projection as introduced in \cite{YoshidaDanielouBejleriHu10}.

Projection maps global types onto the respective local type for a given role $ \Role[p] $.
The projections of the new global types are obtained straightforwardly from the projection of their respective \strongR counterparts:
\begin{align*}
	\Proj{\left( \Role_1 \to_{\diamond} \Role_2{:}{\mathfrak{S}}.\GT \right)}{\Role[p]} \deff
	\begin{cases}
		{\left[ \Role_2 \right]}\mathsf{!}_{\diamond}{\mathfrak{S}}.{\Proj{\GT}{\Role[p]}} & \text{if } \Role[p] = \Role_1\\
		{\left[ \Role_1 \right]}\mathsf{?}_{\diamond}{\mathfrak{S}}.{\Proj{\GT}{\Role[p]}} & \text{if } \Role[p] = \Role_2\\
		\Proj{\GT}{\Role[p]} & \text{otherwise}
	\end{cases}
\end{align*}
where either $ \diamond = \iR $, $ \mathfrak{S} = {\left< \Sort \right>} $ or $ \diamond = \iU $, $ \mathfrak{S} = \Label{\left< \Sort \right>} $ and
\begin{align*}
	\Proj{\left( \Role_1 \to_{\diamond} \mathfrak{R}{:}{\Set{ \Label_i.\GT_i }_{i \in \indexSet \mathfrak{D}}} \right)}{\Role[p]} \deff
	\begin{cases}
		{\left[ \mathfrak{R} \right]}\mathsf{!}_{\diamond}{\Set{ \Label_i.\Proj{\GT_i}{\Role[p]} }_{i \in \indexSet}} & \text{if } \Role[p] = \Role_1\\
		{\left[ \Role_1 \right]}\mathsf{?}_{\diamond}{\Set{ \Label_i.\Proj{\GT_i}{\Role[p]} }_{i \in \indexSet \mathfrak{D}}} & \text{if } \mathfrak{B}\\
		\bigsqcup_{i \in \indexSet} \left( \Proj{\GT_i}{\Role[p]} \right) & \text{otherwise}
	\end{cases}
\end{align*}
where either $ \diamond = \iR $, $ \mathfrak{R} = \Role_2 $, $ \mathfrak{B} $ is $ \Role[p] = \Role_2 $, $ \mathfrak{D} $ is empty or $ \diamond = \iW $, $ \mathfrak{R} = \Role[R] $, $ \mathfrak{B} $ is $ \Role[p] \in \Role[R] $, $ \mathfrak{D} $ is $ , \LabelD $.
In the last case of \strongR or \weakR branching---when projecting onto a role that does not participate in this branching---we map to $ \bigsqcup_{i \in \indexSet} \left( \Proj{\GT_i}{\Role[p]} \right) = \left( \Proj{\GT_1}{\Role[p]} \right) \sqcup \ldots \sqcup \left( \Proj{\GT_n}{\Role[p]} \right) $.
The operation $ \sqcup $ is (similar to \cite{YoshidaDanielouBejleriHu10}) inductively defined as:
\begin{align*}
	\LT \sqcup \LT &= \LT\\
	\left( \LBranR{\Role}{\indexSet_1} \right) \sqcup \left( \LBranR{\Role}{\indexSet_2} \right) &= \LBranR{\Role}{\left( \indexSet_1 \sqcup \indexSet_2 \right)}\\
	\left( \LBranW{\Role}{\indexSet_1} \right) \sqcup \left( \LBranW{\Role}{\indexSet_2} \right) &= \LBranW{\Role}{\left( \indexSet_1 \sqcup \indexSet_2 \right)} \quad \text{if } \indexSet_1 \text{ and } \indexSet_2 \text{ have the same default branch}\\
	\indexSet \sqcup \emptyset &= \indexSet\\
	\indexSet \sqcup \left( \Set{ \Label.\LT } \cup \indexSet[J] \right) &=
		\begin{cases}
			\Set{ \Label.\left( \LT' \sqcup \LT \right) } \cup \left( \left( \indexSet \setminus \Set{ \Label.\LT' } \right) \sqcup \indexSet[J] \right) & \text{if } \Label.\LT' \in \indexSet\\
			\Set{ \Label.\LT } \cup \left( \indexSet \sqcup \indexSet[J] \right) & \text{if } \Label \notin \indexSet
		\end{cases}
\end{align*}
where $ \LT, \LT' \in \localTypes $, $ \Label \notin \indexSet $ is short hand for $ \nexists \LT'\logdot \Label.\LT' \in \indexSet $, and is undefined in all other cases.
The mergeability relation $ \sqcup $ states that two types are identical up to their branching types, where only branches with distinct labels are allowed to be different.
This ensures that if the sender~$ \Role_1 $ in $ \GBranR{\Role_1}{\Role_2}{\Set{ \Label_i.\GT_i }_{i \in \indexSet}} $ decides to branch then only processes that are informed about this decision can adapt their behavior accordingly; else projection is \textbf{not} defined.

The remaining global types are projected as follows:
\[\begin{array}{c}
	\Proj{\left( \GPar{\GT_1}{\GT_2} \right)}{\Role[p]} \deff
		\begin{cases}
			\Proj{\GT_1}{\Role[p]} & \text{if } \Role[p] \notin \Roles{\GT_2}\\
			\Proj{\GT_2}{\Role[p]} & \text{if } \Role[p] \notin \Roles{\GT_1}
		\end{cases}
	\hspace{1em}
	\Proj{\left( \GRep{\TypeV}{\GT} \right)}{\Role[p]} \deff
		\begin{cases}
			\LRep{\TypeV}{\Proj{\GT}{\Role[p]}} & \text{if } \Role[p] \in \Roles{\GT}\\
			\LEnd & \text{otherwise}
		\end{cases} \vspace{0.5em}\\
	\Proj{\TypeV}{\Role[p]} \deff \TypeV
	\hspace{2em}
	\Proj{\GEnd}{\Role[p]} \deff \LEnd
\end{array}\]

Projecting a recursive global type results in a recursive local type if $ \Role[p] $ occurs in the body of the recursion or else in successful termination.
Type variables and successful termination are mapped onto themselves.
We denote a global type $ \GT $ as \emph{projectable} if for all $ \Role \in \Roles{\GT} $ the projection $ \Proj{\GT}{\Role} $ is defined.
We restrict our attention to projectable global types.

In types $ \GRep{\TypeV}{\GT} $ and $ \LRep{\TypeV}{\LT} $ the type variable $ \TypeV $ is \emph{bound}.
In processes $ \PRep{\ProcV}{\PT} $ the process variable $ \ProcV $ is bound.
Similarly, all names in round brackets are bound in the remainder of the respective process, \eg $ \Chan $ is bound in $ \PT $ by $ \PReq{\Chan[a]}{\Role[n]}{\Chan}{\PT} $ and $ \Args $ is bound in $ \PT $ by $ \PGetR{\Chan}{\Role_1}{\Role_2}{\Args}{\PT} $.
A variable or name is \emph{free} if it is not bound. Let $ \FreeNames{\PT} $ return the free names of $ \PT $.

We use '$. $' (as \eg in $ \PReq{\Chan[a]}{\Role}{\Chan}{\PT} $) to denote sequential composition. In all operators the \emph{prefix} before '$. $' guards the \emph{continuation} after the '$. $'.
Let $ \prod_{1 \leq i \leq n} \PT_i $ abbreviate the parallel composition $ \PPar{\PT_1}{\PPar{\ldots}{\PT_n}} $.

We write  $ \Unreliable{\GT} $, $ \Unreliable{\LT} $, and $ \Unreliable{\PT} $, if none of the prefixes in $ \GT $, $ \LT $, and $ \PT $ is \strongR or for delegation and if $ \PT $ does not contain message queues.

The combination of a session channel and a role uniquely identifies a participant of a session, called an \emph{actor}. A process has an actor $ \AT{\Chan[s]}{\Role} $ if it has an action prefix on $ \Chan $, where $ \Role $ is the first role mentioned in the prefix.
Let $ \Actors{\PT} $ be the set of actors of $ \PT $.

\subsection{A Semantics with Failure Patterns}
\label{sec:failurePatterns}

The application of a substitution $ \Subst{\Args[y]}{\Args} $ on a term $ A $, denoted as $ A\Subst{\Args[y]}{\Args} $, is defined as the result of replacing all free occurrences of $ \Args $ in $ A $ by $ \Args[y] $, possibly applying alpha-conversion to avoid capture or name clashes. For all names $ n \in \names \setminus \Set{ \Args } $ the substitution behaves as the identity mapping. We use substitution on types as well as processes and naturally extend substitution to the substitution of variables by terms (to unfold recursions) and names by expressions (to instantiate a bound name with a received value).

Labels allow us to distinguish between different branches.
Our \MPST variant will ensure that all occurrences of the same label are associated with the same sort.
We assume a predicate $ \compL[] $ that compares two labels and is valid if the parts of the labels that do not refer to runtime information correspond.
We require that $ \compL[] $ is unambiguous on labels used in types \cite{PetersEtal21}.

We use structural congruence to abstract from syntactically different processes with the same meaning, where $ \equiv $ is the least congruence that satisfies alpha conversion and the rules:
\[ \begin{array}{c}
	\PT \mid \PEnd \equiv \PT
	\hspace{2em} \PT_1 \mid \PT_2 \equiv \PT_2 \mid \PT_1
	\hspace{2em} \PT_1 \mid \left( \PT_2 \mid \PT_3 \right) \equiv \left( \PT_1 \mid \PT_2 \right) \mid \PT_3\\
	\PRep{\ProcV}{\PEnd} \equiv \PEnd
	\hspace{2em} \PRes{\Args}{\PEnd} \equiv \PEnd
	\hspace{2em} \PRes{\Args}{\PRes{\Args[y]}{\PT}} \equiv \PRes{\Args[y]}{\PRes{\Args}{\PT}}\\
	\PRes{\Args}{\left( \PT_1 \mid \PT_2 \right)} \equiv \PT_1 \mid \PRes{\Args}{\PT_2} \quad \text{if } \Args \notin \FreeNames{\PT_1}
\end{array} \]

\begin{figure}[tp]
    \centering
	\renewcommand{\tabcolsep}{2pt}
	\begin{tabular}{ll}
		(\textsf{Init}) & $ \PReq{\Chan[a]}{\Role[n]}{\Chan}{\PT_{\Role[n]}} \mid \prod_{1 \leq \Role[i] \leq \Role[n] - 1} \PAcc{\Chan[a]}{\Role[i]}{\Chan}{\PT_{\Role[i]}} \step \PRes{\Chan}{\left( \prod_{1 \leq \Role[i] \leq \Role[n]} \PT_{\Role[i]} \mid \prod_{1 \leq \Role[i], \Role[j] \leq \Role[n], \Role[i] \neq \Role[j]} \MQ{\Chan}{\Role[i]}{\Role[j]}{\emptyList} \right)} $\\
		& \hfill if $ \Chan[a] \neq \Chan $\\
		(\textsf{RSend}) & $ \PSendR{\Chan}{\Role_1}{\Role_2}{\Expr[y]}{\PT} \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} \step \PT \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue\#\MessR{\Expr[v]}} $ \hfill if $ \Eval{\Expr[y]} = \Expr[v] $\\
		(\textsf{RGet}) & $ \PGetR{\Chan}{\Role_1}{\Role_2}{\Args}{\PT} \mid \MQ{\Chan}{\Role_2}{\Role_1}{\MessR{\Expr[v]}\#\Queue} \step \PT\Subst{\Expr[v]}{\Args} \mid \MQ{\Chan}{\Role_2}{\Role_1}{\Queue} $\\
		(\textsf{USend}) & $ \PSendU{\Chan}{\Role_1}{\Role_2}{\Label}{\Expr[y]}{\PT} \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} \step \PT \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue\#\MessU{\Label}{\Expr[v]}} $ \hfill if $ \Eval{\Expr[y]} = \Expr[v] $\\
		(\textsf{UGet}) & $ \PGetU{\Chan}{\Role_1}{\Role_2}{\Label}{\Expr[dv]}{\Args}{\PT} \mid \MQ{\Chan}{\Role_2}{\Role_1}{\MessU{\Label'}{\Expr[v]}\#\Queue} \step \PT\Subst{\Expr[v]}{\Args} \mid \MQ{\Chan}{\Role_2}{\Role_1}{\Queue} $\\
		& \hfill if $ \Label \compL \Label' $, $ \fpUGet(\Chan, \Role_1, \Role_2, \Label') $\\
		(\textsf{USkip}) & $ \PGetU{\Chan}{\Role_1}{\Role_2}{\Label}{\Expr[dv]}{\Args}{\PT} \step \PT\Subst{\Expr[dv]}{\Args} $ \hfill if $ \fpUSkip(\Chan, \Role_1, \Role_2, \Label) $\\
		(\textsf{ML}) & $ \MQ{\Chan}{\Role_1}{\Role_2}{\MessU{\Label}{\Expr[v]}\#\Queue} \step \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} $ \hfill if $ \fpML(\Chan, \Role_1, \Role_2, \Label) $\\
		(\textsf{RSel}) & $ \PSelR{\Chan}{\Role_1}{\Role_2}{\Label}{\PT} \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} \step \PT \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue\#\MessBR{\Label}} $\\
		(\textsf{RBran}) & $ \PBranR{\Chan}{\Role_1}{\Role_2}{\Set{ \Label_i.\PT_i }_{i \in \indexSet}} \mid \MQ{\Chan}{\Role_2}{\Role_1}{\MessBR{\Label}\#\Queue} \step \PT_j \mid \MQ{\Chan}{\Role_2}{\Role_1}{\Queue} $ \hfill if $ \Label \compL \Label_j $, $ j \in \indexSet $\\
		(\textsf{WSel}) & $ \PSelW{\Chan}{\Role}{\Role[R]}{\Label}{\PT} \mid \prod_{\Role_i \in \Role[R]} \MQ{\Chan}{\Role}{\Role_i}{\Queue_i} \step \PT \mid \prod_{\Role_i \in \Role[R]} \MQ{\Chan}{\Role}{\Role_i}{\Queue_i\#\MessBW{\Label}} $\\
		(\textsf{WBran}) & $ \PBranW{\Chan}{\Role_1}{\Role_2}{\Set{ \Label_i.\PT_i }_{i \in \indexSet, \LabelD}} \mid \MQ{\Chan}{\Role_2}{\Role_1}{\MessBW{\Label}\#\Queue} \step \PT_j \mid \MQ{\Chan}{\Role_2}{\Role_1}{\Queue} $ \hfill if $ \Label \compL \Label_j $, $ j \in \indexSet $\\
		(\textsf{WSkip}) & $ \PBranW{\Chan}{\Role_1}{\Role_2}{\Set{ \Label_i.\PT_i }_{i \in \indexSet, \LabelD}} \step \PTD $ \hfill if $ \fpWSkip(\Chan, \Role_1, \Role_2) $\\
		(\textsf{Crash}) & $ \PT \step \PCrash $ \hfill if $ \fpCrash(\PT) $\\
        (\textsf{If-T}) & $ \PITE{\Expr}{\PT}{\PT'} \step \PT $ \hspace{15em} if $ \Expr $ is true\\
		(\textsf{If-F}) & $ \PITE{\Expr}{\PT}{\PT'} \step \PT' $ \hfill if $ \Expr $ is false\\
		(\textsf{Deleg}) & $ \PDelA{\Chan}{\Role_1}{\Role_2}{\AT{\Chan'}{\Role}}{\PT} \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} \step \PT \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue\#\AT{\Chan'}{\Role}} $\\
		(\textsf{SRecv}) & $ \PDelB{\Chan}{\Role_1}{\Role_2}{\AT{\Chan'}{\Role}}{\PT} \mid \MQ{\Chan}{\Role_2}{\Role_1}{\AT{\Chan''}{\Role'}\#\Queue} \step \PT\Subst{\Chan''}{\Chan'}\Subst{\Role'}{\Role} \mid \Queue $\\
		(\textsf{Par}) & $ \PT_1 \mid \PT_2 \step \PT_1' \mid \PT_2 $ \hfill if $ \PT_1 \step \PT_1' $\\
		(\textsf{Res}) & $ \PRes{\Args}{\PT} \step \PRes{\Args}{\PT'} $ \hfill if $ \PT \step \PT' $\\
		(\textsf{Rec}) & $ \PRep{\ProcV}{\PT} \step \PT\Subst{\PRep{\ProcV}{\PT}}{\ProcV} $\\
		(\textsf{Struc}) & $ \PT_1 \step \PT_1' $ \hfill if $ \PT_1 \equiv \PT_2 $, $ \PT_2 \step \PT_2' $, $ \PT_2' \equiv \PT_1' $
	\end{tabular}
	\vspace*{-0.5em}
	\caption{Reduction Rules ($ \step $) of Fault-Tolerant Processes.}
	\label{fig:semantics}
\end{figure}

The reduction semantics of the session calculus is defined in Fig.~\ref{fig:semantics}, where we follow~\cite{hondaYoshidaCarbone16}: we assume that session initialization is synchronous and communication within a session is asynchronous implemented using message queues.

Rule~(\textsf{Init}) initializes a session with $ \Role[n] $ roles.
Session initialization introduces a fresh session channel and unguards the participants of the session.
Finally, the message queues of this session are initialized with the empty list under the restriction of the session channel.

Rule~(\textsf{RSend}) implements an asynchronous \strongR message transmission.
As a result the value $ \Eval{\Expr[y]} $ is wrapped in a message and added to the end of the corresponding message queue and the continuation of the sender is unguarded.
Rule~(\textsf{USend}) is the counterpart of (\textsf{RSend}) for \unrel senders.
%
(\textsf{RGet}) consumes a message that is marked as \strongR with the index $ \operatorname{r} $ from the head of the respective message queue and replaces in the unguarded continuation of the receiver the bound variable $ \Args $ by the received value $ \Args[y] $.

There are two rules for the reception of a message in an \unrel communication that are guided by failure patterns.
\emph{Failure patterns} are predicates that we deliberately choose not to define here (see below).
They allow us to provide information about the underlying communication medium and the reliability of processes.
Rule~(\textsf{UGet}) is similar to Rule~(\textsf{RGet}), but specifies a failure pattern $ \fpUGet $ to decide whether this step is allowed.
The Rule~(\textsf{USkip}) allows to skip the reception of a message in an \unrel communication using a failure pattern $ \fpUSkip $ and instead substitutes the bound variable $ \Args $ in the continuation with the default value $ \Args[dv] $.
The failure pattern $ \fpUSkip $ tells us whether a reception can be skipped.

Rule~(\textsf{RSel}) puts the label $ \Label $ selected by $ \Role_1 $ at the end of the message queue towards $ \Role_2 $.
Its \weakR counterpart (\textsf{WSel}) is similar, but puts the label at the end of all relevant message queues.
%
With (\textsf{RBran}) a label is consumed from the top of a message queue and the receiver moves to the indicated branch.
There are again two \weakR counterparts of (\textsf{RBran}).
Rule~(\textsf{WBran}) is similar to (\textsf{RBran}), whereas (\textsf{WSkip}) allows $ \Role_1 $ to skip the message and to move to its default branch if the failure pattern $ \fpWSkip $ holds.

The Rules~(\textsf{Crash}) for \emph{crash failures} and (\textsf{ML}) for \emph{message loss}, describe failures of a system.
With Rule~(\textsf{Crash}) $ \PT $ can crash if $ \fpCrash $.
(\textsf{ML}) allows to drop an \unrel message if the failure pattern $ \fpML $ is valid.

The remaining rules for conditionals, session delegation, parallel composition, restriction, recursion, and structural congruence in Fig.~\ref{fig:semantics} are standard.

We augmented our reduction semantics in Fig.~\ref{fig:semantics} by five different failure patterns that we deliberately do not specify, although we usually assume that the failure patterns $ \fpUGet $, $ \fpUSkip $, and $ \fpWSkip $ use only local information, whereas $ \fpML $ and $ \fpCrash $ may use global information of the system in the current run.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Typing Fault-Tolerant Processes  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Typing Fault-Tolerant Processes}
\label{sec:typing}

The type of a process $ \PT $ is checked in a \emph{typed judgment}, \ie triples $ \Gamma \vdash \PT \triangleright \Delta $, where
\begin{align*}
	\Gamma & \deffTerms \emptyset
		\sepTerms \Gamma \compS \Typed{\Args}{\Sort}
		\sepTerms \Gamma \compS \Typed{\Chan[a]}{\GT}
		\sepTerms \Gamma \compS \Typed{\Label}{\Sort}\\
	\Delta &\deffTerms \emptyset
		\sepTerms \Delta \compS \Typed{\AT{\Chan}{\Role}}{\LT}
		\sepTerms \Delta \compS \MQ{\Chan}{\Role_1}{\Role_2}{\MT^*}
\end{align*}
Assignments in $ \Gamma $ relate variables to their sort, shared channels to the type of the session they introduce, and connect labels with a sort.
Session environments collect the local types of actors and the list of message types of queues, \ie $ \MT^* $ denotes a list of message types.

We write $ \Args \sharp \Gamma $ and $ \Args \sharp \Delta $ if the name $ \Args $ does not occur in $ \Gamma $ and $ \Delta $, respectively.
We use $ \compS $ to add an assignment provided that the new assignment is not in conflict with the type environment, \ie $ \Gamma \compS A $ implies that the respective name/variable/label in $ A $ is not contained in $ \Gamma $ and $ \Delta \compS A $ implies that the respective actor/queue in $ A $ is not contained in $ \Delta $.
These conditions on $ \compS $ for global and session environments are referred to as \emph{linearity}.
We restrict in the following our attention to linear environments.

\begin{figure}[tp]
	\centering
	\[ \begin{array}{c}
		\left( \textsf{Req} \right) \dfrac{\!\!\begin{array}{c} \Typed{\Chan[a]}{\GT} \in \Gamma \quad \Length{\Roles{\GT}} = \Role[n] \\ \Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role[n]}}{\Proj{\GT}{\Role[n]}} \end{array}}{\Gamma \vdash \PReq{\Chan[a]}{\Role[n]}{\Chan}{\PT} \triangleright \Delta} \hspace{2em}
		\left( \textsf{Acc} \right) \dfrac{\!\!\begin{array}{c} \Typed{\Chan[a]}{\GT} \in \Gamma \quad 0 < \Role < \Length{\Roles{\GT}} \\ \Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role}}{\Proj{\GT}{\Role}} \end{array}}{\Gamma \vdash \PAcc{\Chan[a]}{\Role}{\Chan}{\PT} \triangleright \Delta} \vspace{0.5em}\\
		\left( \textsf{RSend} \right) \dfrac{\Gamma \Vdash \Typed{\Expr[y]}{\Sort} \quad \Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT}}{\Gamma \vdash \PSendR{\Chan}{\Role_1}{\Role_2}{\Expr[y]}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LSendR{\Role_2}{\Sort}{\LT}}} \vspace{0.5em}\\
		\left( \textsf{RGet} \right) \dfrac{\Args \sharp \left( \Gamma, \Delta, \Chan \right) \quad \Gamma \compS \Typed{\Args}{\Sort} \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan[s]}{\Role_1}}{\LT}}{\Gamma \vdash \PGetR{\Chan}{\Role_1}{\Role_2}{\Args}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LGetR{\Role_2}{\Sort}{\LT}}} \vspace{0.5em}\\
		\left( \textsf{USend} \right) \dfrac{\Gamma \Vdash \Typed{\Expr[y]}{\Sort} \quad \Label \compL \Label' \quad \Typed{\Label'}{\Sort} \in \Gamma \quad \Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT}}{\Gamma \vdash \PSendU{\Chan}{\Role_1}{\Role_2}{\Label}{\Expr[y]}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LSendU{\Role_2}{\Label'}{\Sort}{\LT}}} \vspace{0.5em}\\
		\left( \textsf{UGet} \right) \dfrac{\Args \sharp \left( \Gamma, \Delta, \Chan \right) \quad \Gamma \Vdash \Typed{\Expr[v]}{\Sort} \quad \Label \compL \Label' \quad \Typed{\Label'}{\Sort} \in \Gamma \quad \Gamma \compS \Typed{\Args}{\Sort} \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan[s]}{\Role_1}}{\LT}}{\Gamma \vdash \PGetU{\Chan}{\Role_1}{\Role_2}{\Label}{\Expr[v]}{\Args}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LGetU{\Role_2}{\Label'}{\Sort}{\LT}}} \vspace{0.5em}\\
		\left( \textsf{RSel} \right) \dfrac{j \in \indexSet \quad \Label \compL \Label_j \quad \Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT_j}}{\Gamma \vdash \PSelR{\Chan}{\Role_1}{\Role_2}{\Label}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LSelR{\Role_2}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}}}} \hspace{2em}
		\left( \textsf{Var} \right) \dfrac{}{\Gamma \compS \Typed{\ProcV}{\TypeV} \vdash \ProcV \triangleright \Typed{\AT{\Chan}{\Role}}{\TypeV}} \vspace{0.5em}\\
		\left( \textsf{RBran} \right) \dfrac{\forall j \in \indexSet_2\logdot \exists i \in \indexSet_1\logdot \Label_i \compL \Label_j \wedge \Gamma \vdash \PT_i \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT_j}}{\Gamma \vdash \PBranR{\Chan}{\Role_1}{\Role_2}{\Set{ \Label_i.\PT_i }_{i \in \indexSet_1}} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LBranR{\Role_2}{\Set{ \Label_i.\LT_i }_{i \in \indexSet_2}}}} \vspace{0.5em}\\
		\left( \textsf{WSel} \right) \dfrac{j \in \indexSet \quad \Label \compL \Label_j \quad \Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role}}{\LT_j}}{\Gamma \vdash \PSelW{\Chan}{\Role}{\Role[R]}{\Label}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role}}{\LSelW{\Role[R]}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}}}} \hspace{2em}
		\left( \textsf{Crash} \right) \dfrac{\Unreliable{\Delta}}{\Gamma \vdash \PCrash \triangleright \Delta} \vspace{0.5em}\\
		\left( \textsf{WBran} \right) \dfrac{\LabelD \compL \LabelD' \quad \forall j \in \indexSet_2\logdot \exists i \in \indexSet_1\logdot \Label_i \compL \Label_j \wedge \Gamma \vdash \PT_i \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT_j}}{\Gamma \vdash \PBranW{\Chan}{\Role_1}{\Role_2}{\Set{ \Label_i.\PT_i }_{i \in \indexSet_1, \LabelD}} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LBranW{\Role_2}{\Set{ \Label_i.\LT_i }_{i \in \indexSet_2, \LabelD'}}}} \vspace{0.5em}\\
		\left( \textsf{Deleg} \right) \dfrac{\Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT}}{\Gamma \vdash \PDelA{\Chan}{\Role_1}{\Role_2}{\AT{\Chan'}{\Role}}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LDelA{\Role_2}{\Chan'}{\Role}{\LT'}{\LT}} \compS \Typed{\AT{\Chan'}{\Role}}{\LT'}} \vspace{0.5em}\\
		\left( \textsf{SRecv} \right) \dfrac{\Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT} \compS \Typed{\AT{\Chan'}{\Role}}{\LT'}}{\Gamma \vdash \PDelB{\Chan}{\Role_1}{\Role_2}{\AT{\Chan'}{\Role}}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LDelB{\Role_2}{\Chan'}{\Role}{\LT'}{\LT}}} \hspace{2em}
		\left( \textsf{End} \right) \dfrac{}{\Gamma \vdash \PEnd \triangleright \emptyset} \vspace{0.5em}\\
		\left( \textsf{If} \right) \dfrac{\Gamma \Vdash \Typed{\Expr}{\bool} \quad \Gamma \vdash \PT \triangleright \Delta \quad \Gamma \vdash \PT' \triangleright \Delta}{\Gamma \vdash \PITE{\Expr}{\PT}{\PT'} \triangleright \Delta} \hspace{1em}
		\left( \textsf{Par} \right) \dfrac{\Gamma \vdash \PT \triangleright \Delta \quad \Gamma \vdash \PT' \triangleright \Delta'}{\Gamma \vdash \PT \mid \PT' \triangleright \Delta \compS \Delta'} \vspace{0.5em}\\
		\left( \textsf{Res1} \right) \dfrac{\Args \sharp \left( \Gamma, \Delta \right) \quad \Gamma \compS \Typed{\Args}{\Sort} \vdash \PT \triangleright \Delta}{\Gamma \vdash \PRes{\Args}{\PT} \triangleright \Delta} \hspace{2em}
		\left( \textsf{Rec} \right) \dfrac{\Gamma \compS \Typed{\ProcV}{\TypeV} \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan[s]}{\Role}}{\LT}}{\Gamma \vdash \PRep{\ProcV}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan[s]}{\Role}}{\LRep{\TypeV}{\LT}}}
	\end{array} \]
	\caption{Typing Rules for Fault-Tolerant Systems.}
	\label{fig:typingRules}
\end{figure}

We write $ \Unreliable{\Delta} $ if $ \Unreliable{\LT} $ for all local types $ \LT $ in $ \Delta $ and if $ \Delta $ does not contain message queues.
With $ \Gamma \Vdash \Typed{\Expr[y]}{\Sort} $ we check that $ \Expr[y] $ is an expression of the sort $ \Sort $ if all names $ \Args $ in $ \Expr[y] $ are replaced by arbitrary values of sort $ \Sort_{\Args} $ for $ \Typed{\Args}{\Sort_{\Args}} \in \Gamma $.

A process $ \PT $ is \emph{well-typed} \wrt $ \Gamma $ and $ \Delta $ if $ \Gamma \vdash \PT \triangleright \Delta $ can be derived from the rules in the Fig.~\ref{fig:typingRules}.
We concentrate on the interaction cases, where we observe that all new cases are quite similar to their \strongR counterparts.
%The \unrel and \weakR cases additionally check the sorts assigned to labels in $ \Gamma $, the sorts of default values, and the relation between default labels of processes and their types.

Rule~(\textsf{RSend}) checks \strongR senders, \ie requires a matching \strongR sending in the local type of the actor and compares the actor with this type.
With $ \Gamma \Vdash \Typed{\Expr[y]}{\Sort} $ we check that $ \Expr[y] $ is an expression of the sort $ \Sort $ if all names $ \Args $ in $ \Expr[y] $ are replaced by arbitrary values of sort $ \Sort_{\Args} $ for $ \Typed{\Args}{\Sort_{\Args}} \in \Gamma $.
Then the continuation of the process is checked against the continuation of the type.
The \unrel case is very similar, but additionally checks that the label is assigned to the sort of the expression in $ \Gamma $.
Rule~(\textsf{RGet}) type \strongR receivers, where again the prefix is checked against a corresponding type prefix and the assumption $ \Typed{\Args}{\Sort} $ is added to the type check of the continuation.
Again the \unrel case is very similar, but apart from the label also checks the sort of the default value.

Rule~(\textsf{RSel}) checks the \strongR selection prefix, that the selected label matches one of the specified labels, and that the process continuation is well-typed \wrt the type continuation following the selected label.
The only difference in the \weakR case is the set of roles for the receivers.
For \strongR branching we have to check the prefix and that for each branch in the type there is a matching branch in the process that is well-typed \wrt the respective branch in the type.
For the \weakR case we have to additionally check that the default labels of the process and the type coincide.

Rule~(\textsf{Crash}) for crashed processes checks that $ \Unreliable{\Delta} $.

% Because of the failure pattern in the reduction semantics in Fig.~\ref{fig:semantics}, subject reduction and progress do not hold in general.
% Instead we have to fix conditions on failure patterns that ensure these properties.

We have to fix conditions on failure patterns to ensure that subject reduction and progress hold in general.

\begin{condition}[Failure Pattern]
	\label{cond:all}
	\begin{enumerate}
		\item If $ \fpCrash(\PT) $, then $ \Unreliable{\PT} $. \label{cond:crash}
		\item The failure pattern $ \fpUGet(\Chan, \Role_1, \Role_2, \Label) $ is always valid. \label{cond:ugetValid}
		\item The pattern $ \fpML(\Chan, \Role_1, \Role_2, \Label) $ is valid iff $ \fpUSkip(\Chan, \Role_2, \Role_1, \Label) $ is valid. \label{cond:fpMLifffpUSkip}
		\item If $ \fpCrash(\PT) $ and $ \AT{\Chan}{\Role} \in \Actors{\PT} $ then eventually $ \fpUSkip(\Chan, \Role_2, \Role, \Label) $ and also $ \fpWSkip(\Chan, \Role_2, \Role, \Label) $ for all $ \Role_2, \Label $. \label{cond:fpCrashImpliesSkip}
		\item If $ \fpCrash(\PT) $ and $ \AT{\Chan}{\Role} \in \Actors{\PT} $ then eventually $ \fpML(\Chan, \Role_1, \Role, \Label) $ for all $ \Role_1, \Label $. \label{cond:fpCrashImpliesML}
		\item If $ \fpWSkip(\Chan, \Role_1, \Role_2) $ then $ \AT{\Chan}{\Role_2} $ is crashed, \ie the system does no longer contain an actor $ \AT{\Chan}{\Role_2} $ and the message queue $ \MQS{\Chan}{\Role_2}{\Role_1} $ is empty. \label{cond:fpWskip}
	\end{enumerate}
\end{condition}

The crash of a process should not block \strongR actions, \ie only processes with $ \Unreliable{\PT} $ can crash (Condition~\ref{cond:all}.\ref{cond:crash}).
Condition~\ref{cond:all}.\ref{cond:ugetValid} requires that no process can refuse to consume a message on its queue.
This condition prevents deadlocks that may arise from refusing a message $ m $ that is never dropped from the message queue.
Condition~\ref{cond:all}.\ref{cond:fpMLifffpUSkip} requires that if a message can be dropped from a message queue then the corresponding receiver has to be able to skip this message and vice versa.
Similarly, processes that wait for messages from a crashed process have to be able to skip (Condition~\ref{cond:all}.\ref{cond:fpCrashImpliesSkip}) and all messages of a queue towards a crashed receiver can be dropped (Condition~\ref{cond:all}.\ref{cond:fpCrashImpliesML}).
Finally, \weakR branching requests should not be lost.
To ensure that the receiver of such a branching request can proceed if the sender is crashed but is not allowed to skip the reception of the branching request before the sender crashed, we require that $ \fpWSkip(\Chan, \Role_1, \Role_2) $ is false as long as $ \AT{\Chan}{\Role_2} $ is alive or messages on the respective queue are still in transit (Condition~\ref{cond:all}.\ref{cond:fpWskip}).

% TODO "it is an established method to verify the correctness of algorithms \wrt given system requirements (\eg in \cite{ChandraToueg96,Lamport01,TanenbaumSteen17}), even if these system requirements are not verified and often do not hold in all (but only nearly all) cases."

\emph{Coherence} intuitively describes that a session environment captures all local endpoints of a collection of global types.
Since we capture all relevant global types in the global environment, we define
coherence on pairs of global and session environments.

\begin{theorem}[Subject Reduction]
	\label{thm:subjectReduction}
	If $ \Gamma \vdash \PT \triangleright \Delta $, $ \Gamma, \Delta $ are coherent, and $ \PT \step \PT' $, then there are some $ \Delta' $ such that $ \Gamma \vdash \PT' \triangleright \Delta' $.
\end{theorem}

\emph{Progress} states that no part of a well-typed and coherent system can block other parts, that eventually all matching communication partners of \strongR and \weakR communications (that are not crashed) are unguarded, and that there are no communication mismatches.
Subject reduction and progress together then imply \emph{session fidelity}, \ie that processes behave as specified in their global types.

To ensure that the interleaving of sessions and session delegation cannot introduce deadlocks, we assume an interaction type system as introduced in \cite{BettiniEtal08,hondaYoshidaCarbone16}.
For this type system it does not matter whether the considered actions are \strongR, \weakR, or \unrel.
More precisely, we can adapt the interaction type system of \cite{BettiniEtal08} in a straightforward way to the above session calculus, where \unrel communication and \weakR branching is treated in exactly the same way as \strongR communication/branching.
We say that \emph{$ \PT $ is free of cyclic dependencies between sessions} if this interaction type system does not detect any cyclic dependencies.

In the literature there are different formulations of progress.
We are interested in a rather strict definition of progress that ensures that well-typed systems cannot block.
Therefore, we need an additional assumption on session requests and acceptances.
Coherence ensures the existence of communication partners within sessions only.
If we want to avoid blocking, we need to be sure, that no participant of a session is missing during its initialization.
Note that without action prefixes all participants either terminated or crashed.

\begin{theorem}[Progress/Session Fidelity]
	\label{thm:progress}
	Let $ \Gamma \vdash \PT \triangleright \Delta $, $ \Gamma, \Delta $ be coherent, and let $ \PT $ be free of cyclic dependencies between sessions.
	Assume that in the derivation of $ \Gamma \vdash \PT \triangleright \Delta $, whenever $ \PReq{\Chan[a]}{\Role[n]}{\Chan}{\PT[Q]} $ or $ \PAcc{\Chan[a]}{\Role}{\Chan}{\PT[Q]} $ with $ \Typed{\Chan[a]}{\GT} $, then there are $ \PReq{\Chan[a]}{\Role[n]}{\Chan}{\PT[Q]_n} $ or $ \PAcc{\Chan[a]}{\Role_i}{\Chan}{\PT[Q]_i} $ for all $ 1 \leq \Role_i < \Role[n] $.
	\begin{enumerate}
		\item Then either $ \PT $ does not contain any action prefixes or $ \PT \step \PT' $.
		\item If $ \PT $ does not contain recursion, then there exists $ P' $ such that $ \PT \steps \PT' $ and $ \PT' $ does not contain any action prefixes.
	\end{enumerate}
\end{theorem}

