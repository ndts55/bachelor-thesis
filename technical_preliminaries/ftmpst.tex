\section{Fault-Tolerant Multiparty Session Types}
Our model of the Paxos algorithm uses a fault-tolerant extension of Multiparty Session Types introduced by \citeauthor{PetersEtal21} in \cite{PetersEtal21}.
The following explanation of Fault-Tolerant Multiparty Session Types is from that same paper.

\subsection{Fault-Tolerance in Distributed Algorithms}
\label{sec:faultTol}
We consider three sources of failure in an \unrel communication (Fig.~\ref{fig:unrelComWeakRBran}(a)):
(1) the sender may crash before it releases the message,
(2) the receiver may crash before it can consume the message, or
(3) the communication medium may lose the message.
The design of a distributed algorithm may allow it to handle some kinds of failures better than others.
Failures are unpredictable events that occur at runtime.
Since types consider only static and predictable information, we do not distinguish between different kinds of failure or model their source in types.
Instead, we only allow types, \ie the specifications of systems, to distinguish between potentially faulty and reliable interactions.

\begin{figure}[t]
	\centering
	\scalebox{0.75}{
	\begin{tikzpicture}[auto]
		% a
		\node at (-0.5, 1.5) {(a)};
		\node[state, minimum size=5mm] at (2.5, 1.5) (r11) {$ \Role_1 $};
		\node[state, minimum size=5mm] at (4, 1.5) (r12) {$ \Role_2 $};
		\node[state, minimum size=5mm] at (0, 0) (r111) {$ \Role_1 $};
		\node[state, minimum size=5mm] at (1.5, 0) (r112) {$ \Role_2 $};
		\node[state, minimum size=5mm] at (3, 0) (r121) {$ \Role_1 $};
		\node[state, minimum size=5mm] at (4.5, 0) (r122) {$ \Role_2 $};
		\node[state, minimum size=5mm] at (6, 0) (r131) {$ \Role_1 $};
		\node[state, minimum size=5mm] at (7.5, 0) (r132) {$ \Role_2 $};
		\path[->] (r11) edge node{$ \Label{\left<\Expr[v]\right>} $} (r12);
		\draw[-, thick, color=red] (-0.4, -0.4) -- (0.4, 0.4);
		\draw[-, thick, color=red] (-0.4, 0.4) -- (0.4, -0.4);
		\path[-] (r121) edge node{$ \Label{\left<\Expr[v]\right>} $} (4, 0);
		\draw[-, thick, color=red] (4.1, -0.4) -- (4.9, 0.4);
		\draw[-, thick, color=red] (4.1, 0.4) -- (4.9, -0.4);
		\path[-] (r131) edge node{$ \Label{\left<\Expr[v]\right>} $} (7, 0);
		\draw[-, thick, color=red] (6.45, 0.1) -- (6.85, 0.5);
		\draw[-, thick, color=red] (6.45, 0.5) -- (6.85, 0.1);
		\path[->, dotted, color = blue] (3.25, 1.2) edge node[above, near end]{(1)} (1, 0.4);
		\path[->, dotted, color = blue] (3.25, 1.2) edge node[left] {(2)} (3.25, 0.4);
		\path[->, dotted, color = blue] (3.25, 1.2) edge node[above, near end] {(3)} (5.5, 0.4);
		\draw[-, dashed, color=blue] (2.25, -0.5) -- (2.25, 0.5);
		\draw[-, dashed, color=blue] (5.25, -0.5) -- (5.25, 0.5);
		% b
		\node at (9, 1.5) {(b)};
		\node[state, minimum size=5mm] at (11, 1.5) (r21) {$ \Role_1 $};
		\node[state, minimum size=5mm] at (12.5, 1.5) (r22) {$ \Role_2 $};
		\node[state, minimum size=5mm] at (9.5, 0) (r211) {$ \Role_1 $};
		\node[state, minimum size=5mm] at (11, 0) (r212) {$ \Role_2 $};
		\node[state, minimum size=5mm] at (12.5, 0) (r221) {$ \Role_1 $};
		\node[state, minimum size=5mm] at (14, 0) (r222) {$ \Role_2 $};
		\path[->] (r21) edge node{$ \Label $} (r22);
		\draw[-, thick, color=red] (9.1, -0.4) -- (9.9, 0.4);
		\draw[-, thick, color=red] (9.1, 0.4) -- (9.9, -0.4);
		\path[-] (r221) edge node{$ \Label $} (13.5, 0);
		\draw[-, thick, color=red] (13.6, -0.4) -- (14.4, 0.4);
		\draw[-, thick, color=red] (13.6, 0.4) -- (14.4, -0.4);
		\path[->, dotted, color = blue] (11.75, 1.2) edge node[left]{(1)} (10.5, 0.4);
		\path[->, dotted, color = blue] (11.75, 1.2) edge node[right] {(2)} (12.75, 0.4);
		\draw[-, dashed, color=blue] (11.75, -0.5) -- (11.75, 0.5);
	\end{tikzpicture}}
	\caption{\Unrel Communication (a) and \WeakR Branching (b).}
	\label{fig:unrelComWeakRBran}
\end{figure}

A fault-tolerant algorithm has to solve its task despite such failures.
Remember that \MPST analyse the communication structure.
Accordingly, we need a mechanism to tolerate faults in the communication structure.
We want our type system to ensure that a faulty interaction neither blocks the overall protocol nor influences the communication structure of the system after this fault.
We consider an \unrel communication as fault-tolerant if a failure does not influence the guarantees that our type system provides for the overall communication structure except for this particular communication.
Moreover, if a potentially unreliable communication is executed successfully, then our type system ensures the same guarantees as for reliable communication such as \eg the absence of communication mismatches.

To ensure that a failure does not block the algorithm, both the receiver and the sender need to be allowed to proceed without their \unrel communication partner. Therefore, the receiver of an \unrel communication is required to specify a default value that, in the case of failure, is used instead of the value the process was supposed to receive.
The type system ensures the existence of such default values and checks their sort.
Moreover, we augment unreliable communication with labels that help us to avoid communication mismatches.
This is enough to ensure that the communication structure of a distributed algorithm is fault-tolerant.

Branching in the context of failures is more difficult, because a branch marks a decision point in a specification, \ie the participants of the session are supposed to behave differently \wrt this decision.
In an \unrel setting it is difficult to ensure that all participants are informed consistently about such a decision and adapt their behaviour accordingly.

Consider a reliable branching that is decided by a process $ \Role_1 $ and transmitted to $ \Role_2 $.
If we try to execute such a branching despite failures, we observe that there are again three ways in that this branching can go wrong (Fig.~\ref{fig:unrelComWeakRBran}(b)):
(1) The sender may crash before it releases its decision.
This will block $ \Role_2 $, because it is missing the information about the branch it should move to.
(2) The receiver might crash.
(3) The message of $ \Role_1 $ about the decided branch is lost.
Then again $ \Role_2 $ is blocked.

Case~(2) can be dealt with similar to \unrel communication, \ie by marking the branching as potentially faulty and by ensuring that a crash of $ \Role_2 $ will not block another process.
For Case~(1) we declare one of the offered branches as default to that $ \Role_2 $ moves if $ \Role_1 $ has crashed.
Then $ \Role_2 $ will not necessarily move to the branch that $ \Role_1 $ had in mind before it crashed, but to a valid/specified branch and, since $ \Role_1 $ is crashed, no two processes move to different branches.
The main problem is in Case~(3).
Let $ \Role_1 $ move to a non-default branch and transmit its decision to $ \Role_2 $, this message gets lost, and $ \Role_2 $ moves to the default branch.
Now both processes did move to branches that are described by their types; but they are in different branches.
Accordingly, this case violates the specification in the type, and we want to reject it.
More precisely, we consider three levels of failures in interactions:
\begin{description}
	\item[\StrongR ($ \iR $):] Neither the sender nor the receiver can crash as long as they are involved in this interaction. The message cannot be lost by the communication medium. This form corresponds to reliable communication as it was described in \cite{AguileraChenToueg97} in the context of distributed algorithms.
		This is the standard, failure-free case.
	\item[\WeakR ($ \iW $):] Both the sender and the receiver might crash at every possible point during this interaction. But the communication medium cannot lose the message.
	\item[\Unrel ($ \iU $):] Both the sender and the receiver might crash at every possible point during this interaction and the communication medium might lose the message. There are no guarantees that this interaction---or any part of it---takes place.
		In this case, it is difficult for the type system to ensure interesting properties in branching.
\end{description}

\subsection{Fault-Tolerant Types and Processes}
\label{sec:syntax}

We assume that the sets $ \names $ of names $ \Chan[a], \Chan, \Args \ldots $; $ \roles $ of roles $ \Role[n], \Role, \ldots $; $ \labels $ of labels $ \Label, \LabelD, \ldots $; $ \typeVars $ of type variables $ \TypeV $; and $ \procVars $ of process variables $ \ProcV $ are pairwise distinct.
For clarity, we often distinguish names into \emph{values}, \ie the payload of messages, \emph{shared channels}, or \emph{session channels} according to their usage; there is, however, no need to formally distinguish between different kinds of names.
To simplify the reduction semantics of our session calculus, we use natural numbers as roles (compare to \cite{hondaYoshidaCarbone16}).
Sorts $ \Sort $ range over $ \mathbb{B}, \mathbb{N}, \ldots $.
The set $ \expressions $ of expressions $ \Expr, \Expr[v], \Expr[b], \ldots $ is constructed from the standard Boolean operations, natural numbers, names, and (in)equalities.

Global types specify the desired communication structure of systems from a global point of view.
In local types this global view is projected to the specification of a single role/participant.
We use standard \MPST (\cite{HondaYoshidaCarbone08,hondaYoshidaCarbone16}) extended by operators for \unrel communication and \weakR branching that are highlighted in blue colour in Fig.~\ref{fig:syntax}.

\begin{figure}[t]
	\centering
	\renewcommand{\tabcolsep}{1pt}
	\begin{tabular}{|llclr|llclr|llclr|}
		\hline
		\multicolumn{5}{|c|}{Global Types} & \multicolumn{5}{c|}{Local Types} & \multicolumn{5}{c|}{Processes}\\
		&&&&& &&&&& & $ P $ & $ \deffTerms $ & $ \PReq{\Chan[a]}{\Role[n]}{\Chan}{P} $ &\\
		&&&&& &&&&& & & $ \sepTerms $ & $ \PAcc{\Chan[a]}{\Role}{\Chan}{P} $ &\\
		& \multirow{2}{*}{$ \GT $} & \multirow{2}{*}{$ \deffTerms $} & \multirow{2}{*}{$ \GComR{\Role_1}{\Role_2}{\Sort}{\GT} $} & & & $ \LT $ & $ \deffTerms $ & $ \LSendR{\Role_2}{\Sort}{\LT} $ & & & & $ \sepTerms $ & $ \PSendR{\Chan}{\Role_1}{\Role_2}{\Expr}{P} $ &\\
		&&&&& & & $ \sepTerms $ & $ \LGetR{\Role_1}{\Sort}{\LT} $ & & & & $ \sepTerms $ & $ \PGetR{\Chan}{\Role_2}{\Role_1}{\Args}{\PT} $ &\\
		& & \multirow{2}{*}{$ \sepTerms $} & \multirow{2}{*}{$ \textcolor{blue}{\GComU{\Role_1}{\Role_2}{\Label}{\Sort}{\GT}} $} & & & & $ \sepTerms $ & $ \textcolor{blue}{\LSendU{\Role_2}{\Label}{\Sort}{\LT}} $ & & & & $ \sepTerms $ & $ \textcolor{blue}{\PSendU{\Chan}{\Role_1}{\Role_2}{\Label}{\Expr}{P}} $ &\\
		&&&&& & & $ \sepTerms $ & $ \textcolor{blue}{\LGetU{\Role_1}{\Label}{\Sort}{\LT}} $ & & & & $ \sepTerms $ & $ \textcolor{blue}{\PGetU{\Chan}{\Role_2}{\Role_1}{\Label}{\Expr[v]}{\Args}{P}} $ &\\
		& & \multirow{2}{*}{$ \sepTerms $} & \multirow{2}{*}{$ \GBranR{\Role_1}{\Role_2}{\Set{ \Label_i.\GT_i}_{i \in \indexSet}} $} & & & & $ \sepTerms $ & $ \LSelR{\Role_2}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}} $ & & & & $ \sepTerms $ & $ \PSelR{\Chan}{\Role_1}{\Role_2}{\Label}{P} $ &\\
		&&&&& & & $ \sepTerms $ & $ \LBranR{\Role_1}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}} $ & & & & $ \sepTerms $ & $ \PBranR{\Chan}{\Role_2}{\Role_1}{\Set{ \Label_i.P_i }_{i \in \indexSet}} $ &\\
		& & \multirow{2}{*}{$ \sepTerms $} & \multirow{2}{*}{$ \textcolor{blue}{\GBranW{\Role}{\Role[R]}{\Set{ \Label_i.\GT_i }_{i \in \indexSet, \LabelD}}} $} & & & & $ \sepTerms $ & $ \textcolor{blue}{\LSelW{\Role[R]}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}}} $ & & & & $ \sepTerms $ & $ \textcolor{blue}{\PSelW{\Chan}{\Role}{\Role[R]}{\Label}{P}} $ &\\
		&&&&& & & $ \sepTerms $ & $ \textcolor{blue}{\LBranW{\Role}{\Set{ \Label_i.\LT_i }_{i \in \indexSet, \LabelD}}} $ & & & & $ \sepTerms $ & $ \textcolor{blue}{\PBranW{\Chan}{\Role_j}{\Role}{\Set{ \Label_i.P_i }_{i \in \indexSet, \LabelD}}} $ &\\
		& & $ \sepTerms $ & $ \GPar{\GT_1}{\GT_2} $ & & &&&&& & & $ \sepTerms $ & $ P_1 \mid P_2 $ &\\
		& & $ \sepTerms $ & $ \GRep{\TypeV}{\GT} \sepTerms \TypeV \sepTerms \GEnd $ & & & & $ \sepTerms $ & $ \LRep{\TypeV}{\LT} \sepTerms \TypeV \sepTerms \LEnd $ & & & & $ \sepTerms $ & $ \PRep{\ProcV}{P} \sepTerms \ProcV \sepTerms \PEnd $ &\\
		&&&&& &&&&& & & $ \sepTerms $ & $ \PITE{\Expr[b]}{P_1}{P_2} $ &\\
		&&&&& &&&&& & & $ \sepTerms $ & $ \PRes{\Args}{P} \sepTerms \PCrash $ &\\
		& & \multirow{2}{*}{$ \sepTerms $} & \multirow{2}{*}{$ \GDel{\Role_1}{\Role_2}{\Chan'}{\Role}{\LT}{\GT} $} & & & & $ \sepTerms $ & $ \LDelA{\Role_2}{\Chan'}{\Role}{\LT}{\LT'} $ & & & & $ \sepTerms $ & $ \PDelA{\Chan}{\Role_1}{\Role_2}{\AT{\Chan'}{\Role}}{\PT} $ &\\
		&&&&& & & $ \sepTerms $ & $ \LDelB{\Role_1}{\Chan'}{\Role}{\LT}{\LT'} $ && & & $ \sepTerms $ & $ \PDelB{\Chan}{\Role_2}{\Role_1}{\AT{\Chan'}{\Role}}{\PT} $ &\\
		&&&&& &&&&& & & $ \sepTerms $ & $ \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} $ &\\
		\hline
		\multicolumn{10}{|c|}{Message Types} & \multicolumn{5}{c|}{Messages}\\
		\multicolumn{10}{|c|}{\multirow{2}{*}{$ \MT \deffTerms \MessR{\Sort} \sepTerms \textcolor{blue}{\MessU{\Label}{\Sort}} \sepTerms \MessBR{\Label} \sepTerms \textcolor{blue}{\MessBW{\Label}} \sepTerms \AT{\Chan}{\Role} $}} & \multicolumn{5}{c|}{$ \; \Queue \deffTerms \MessR{\Expr[v]} \sepTerms \textcolor{blue}{\MessU{\Label}{\Expr[v]}} \sepTerms \MessBR{\Label} $}\\
		\multicolumn{10}{|c|}{} &&& $ \sepTerms $ & $ \textcolor{blue}{\MessBW{\Label}} \sepTerms \AT{\Chan}{\Role} $ &\\
		\hline
	\end{tabular}
	\caption{Syntax of Fault-Tolerant \MPST{}}
	\label{fig:syntax}
\end{figure}

The processes $ \PReq{\Chan[a]}{\Role[n]}{\Chan}{P} $ and $ \PAcc{\Chan[a]}{\Role}{\Chan}{P} $ initialise a new session $ \Chan $ with $ \Role[n] $ roles via the shared channel $ \Chan[a] $ and then proceed as $ \PT $. We identify sessions with their unique session channel.

The type $ \GComR{\Role_1}{\Role_2}{\Sort}{\GT} $ specifies a \strongR communication from role $ \Role_1 $ to role $ \Role_2 $ to transmit a value of the sort $ \Sort $ and then continues with $ \GT $.
A system with this type will be guaranteed to perform a corresponding action.
In a session $ \Chan $ this communication is implemented by the sender $ \PSendR{\Chan}{\Role_1}{\Role_2}{\Expr}{\PT_1} $ (specified as $ \LSendR{\Role_2}{\Sort}{\LT_1} $) and the receiver $ \PGetR{\Chan}{\Role_2}{\Role_1}{\Args}{\PT_2} $ (specified as $ \LGetR{\Role_1}{\Sort}{\LT_2} $).
As result of the communication, the receiver instantiates $ \Args $ in its continuation $ \PT_2 $ with the received value.

The type $ \GComU{\Role_1}{\Role_2}{\Label}{\Sort}{\GT} $ specifies an \unrel communication from $ \Role_1 $ to $ \Role_2 $ transmitting (if successful) a label $ \Label $ and a value of type $ \Sort $ and then continues (regardless of the success of this communication) with $ \GT $.
The \unrel counterparts of senders and receivers are $ \PSendU{\Chan}{\Role_1}{\Role_2}{\Label}{\Expr}{\PT_1} $ (specified as $ \LSendU{\Role_2}{\Label}{\Sort}{\LT_1} $) and $ \PGetU{\Chan}{\Role_2}{\Role_1}{\Label}{\Args[v]}{\Args}{\PT_2} $ (specified as $ \LGetU{\Role_1}{\Label}{\Sort}{\LT_2} $).
The receiver $ \PGetU{\Chan}{\Role_2}{\Role_1}{\Label}{\Args[v]}{\Args}{\PT_2} $ declares a default value $ \Args[v] $ that is used instead of a received value to instantiate $ \Args $ after a failure.
Moreover, a label is communicated that helps us to ensure that a faulty \unrel communication has no influence on later actions.

The \strongR branching $ \GBranR{\Role_1}{\Role_2}{\Set{ \Label_i.\GT_i}_{i \in \indexSet}} $ allows $ \Role_1 $ to pick one of the branches offered by $ \Role_2 $.
We identify the branches with their respective label.
Selection of a branch is implemented by $ \PSelR{\Chan}{\Role_1}{\Role_2}{\Label}{P} $ (specified as $ \LSelR{\Role_2}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}} $).
Upon receiving branch $ \Label_j $ from $ \Role_1 $ the process $ \PBranR{\Chan}{\Role_2}{\Role_1}{\Set{ \Label_i.P_i }_{i \in \indexSet}} $ (specified as $ \LBranR{\Role_1}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}} $) continues with $ \PT_j $.

The \weakR counterpart of branching is $ \GBranW{\Role}{\Role[R]}{\Set{\Label_i.\GT_i}_{i \in \indexSet, \LabelD}} $, where $ \Role[R] \subseteq \roles $ and $ \LabelD $ with $ \default \in \indexSet $ is the default branch.
We use a broadcast from $ \Role $ to all roles in $ \Role[R] $ to ensure that the sender can influence several participants with its decision consistently as it is the case for \strongR branching.
Note that splitting this action to inform the roles in $ \Role[R] $ separately does not work, because \strongR branching does not allow participants to crash and subsequent \weakR branchings cannot ensure that all receivers get the message if the sender crashes while performing these subsequent actions.
The type system will ensure that this branching construct is \weakR, \ie the involved participants might crash but no message is lost.
Because of that, all processes that are not crashed will move to the same branch.
We often abbreviate branching \wrt to a small set of branches by omitting the set brackets and instead separating the branches by $ \oplus $, where the last branch is always the default branch.
In contrast to the \strongR cases, the \weakR selection $ \PSelW{\Chan}{\Role}{\Role[R]}{\Label}{\PT} $ (specified as $ \LSelW{\Role[R]}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}} $) allows to broadcast its decision to $ \Role[R] $ and $ \PBranW{\Chan}{\Role_j}{\Role}{\Set{ \Label_i.\PT_i }_{i \in \indexSet, \LabelD}} $ (specified as $ \LBranW{\Role}{\Set{ \Label_i.\LT_i }_{i \in \indexSet, \LabelD}} $) defines a default label $ \LabelD $.

The $ \PCrash $ denotes a process that crashed.
Similar to \cite{hondaYoshidaCarbone16}, we use message queues to implement asynchrony in sessions.
Therefore, session initialisation introduces a directed and initially empty message queue $ \MQ{\Chan[s]}{\Role_1}{\Role_2}{\emptyList} $ for each pair of roles $ \Role_1 \neq \Role_2 $ of the session $ \Chan[s] $.
The separate message queues ensure that messages with different sources or destinations are not ordered, but each message queue is FIFO.
Since \strongR, \weakR, and \unrel forms of interaction might be implemented differently (\eg by TCP or UDP), it make sense to further split the message queues into three message queues for each pair $ \Role_1 \neq \Role_2 $ such that different kinds of messages do not need to be ordered.
To simplify the presentation of examples in this paper and not to blow up the number of message queues, we stick to a single message queue for each pair $ \Role_1 \neq \Role_2 $, but the correctness of our type system does not depend on this decision.
We have five kinds of messages and corresponding message types in Fig.~\ref{fig:syntax}---one for each kind of interaction.

The remaining operators for independence $ \GPar{\GT}{\GT'} $; parallel composition $ \PPar{\PT}{\PT'} $; recursion $ \GRep{\TypeV}{\GT} $, $ \PRep{\ProcV}{\PT} $; inaction $ \GEnd $, $ \PEnd $; conditionals $ \PITE{\Expr[b]}{\PT_1}{\PT_2} $; session delegation $ \GDel{\Role_1}{\Role_2}{\Chan'}{\Role}{\LT}{\GT} $, $ \PDelA{\Chan}{\Role_1}{\Role_2}{\AT{\Chan'}{\Role}}{\PT} $, $ \PDelB{\Chan}{\Role_2}{\Role_1}{\AT{\Chan'}{\Role}}{\PT} $; and restriction $ \PRes{\Args}{\PT} $ are all standard.

Consider the specification $ \GDice $ of a simple dice game in a bar
\begin{align*}
	\GRep{\TypeV}{\GComR{\Role[3]}{\Role[1]}{\nat}{\GComR{\Role[3]}{\Role[2]}{\nat}{\GBranR{\Role[3]}{\Role[1]}{{\Set{\Label[roll].\GBranR{\Role[3]}{\Role[2]}{\Label[roll].\TypeV}, \Label[exit].\GBranR{\Role[3]}{\Role[2]}{\Label[exit].\GEnd}}}}}}} & \tag{1}\label{eq:diceG}
\end{align*}
where the dealer Role~$ \Role[3] $ continues to $ \Label[roll] $ a dice and tell its value to player $ \Role[1] $ and then to $ \Label[roll] $ another time for player $ \Role[2] $ until the dealer decides to $ \Label[exit] $ the game.

We can combine \strongR communication/branching and \unrel communication, \eg by ordering a drink before each round in $ \GDice $.
\begin{align*}
	& \GRep{\TypeV}{\GComU{\Role[3]}{\Role[4]}{\Label[drink]}{\nat}{\GComR{\Role[3]}{\Role[1]}{\nat}{\GComR{\Role[3]}{\Role[2]}{\nat}{}}}}\\
	& \GBranR{\Role[3]}{\Role[1]}{{\Set{\Label[roll].\GBranR{\Role[3]}{\Role[2]}{\Label[roll].\TypeV}, \quad \Label[exit].\GBranR{\Role[3]}{\Role[2]}{\Label[exit].\GEnd}}}}
\end{align*}
where role~$ \Role[4] $ represents the bar tender and the noise of the bar may swallow these orders.
Moreover, we can remove the branching and specify a variant of the dice game in that $ \Role[3] $ keeps on rolling the dice forever, but, \eg due to a bar fight, one of our three players might get knocked out at some point or the noise of this fight might swallow the announcements of role~$ \Role[3] $:
\begin{align*}
	\GDiceUC &= \GRep{\TypeV}{\GComU{\Role[3]}{\Role[1]}{\Label[roll]}{\nat}{\GComU{\Role[3]}{\Role[2]}{\Label[roll]}{\nat}{\TypeV}}} & \tag{2}\label{eq:diceGU}
\end{align*}

To restore the branching despite the bar fight that causes failures, we need the \weakR branching mechanism.
\begin{align*}
	\GDiceW = \GRep{\TypeV}{}\GBranW{\Role[3]}{\Set{\Role[1], \Role[2]}}{}
		\begin{array}[t]{l}
			\Label[play].\GComU{\Role[3]}{\Role[1]}{\Label[roll]}{\nat}{\GComU{\Role[3]}{\Role[2]}{\Label[roll]}{\nat}{\TypeV}},\\
			\oplus \; \Label[end].\GComU{\Role[3]}{\Role[1]}{\Label[win]}{\bool}{\GComU{\Role[3]}{\Role[2]}{\Label[win]}{\bool}{\GEnd}}
		\end{array} & \tag{3}\label{eq:diceGW}
\end{align*}
If $ \Role[3] $ is knocked out by the fight, \ie crashes, the game cannot continue.
Then $ \Role[1] $ and $ \Role[2] $ move to the default branch $ \Label[end] $, have to skip the respective \unrel communications, and terminate.
But the game can continue as long as $ \Role[3] $ and at least one of the players $ \Role[1], \Role[2] $ participate.

An implementation of $ \GDiceW $ is $ \PDice = \PPar{\PDiceD}{\PPar{\PDiceR}{\PDiceQ}} $, where for $ \Role[i] \in \Set{ \Role[1], \Role[2] } $:
\begin{align*}
	\PDiceD ={}& \PReq{\Chan[a]}{\Role[3]}{\Chan}{\PRep{\ProcV}{\myif \; \Args_{\Role[1]} \leq 21 \wedge \Args_{\Role[2]} \leq 21}}\\
		& \begin{array}{l}
			\mythen \; \PSelW{\Chan}{\Role[3]}{\Set{\Role[1], \Role[2]}}{\Label[play]}{\PSendU{\Chan}{\Role[3]}{\Role[1]}{\Label[roll]}{\textsf{roll}(\Args_{\Role[1]})}{\PSendU{\Chan}{\Role[3]}{\Role[2]}{\Label[roll]}{\textsf{roll}(\Args_{\Role[2]})}{\ProcV}}}\\
			\myelse \; \PSelW{\Chan}{\Role[3]}{\Set{\Role[1], \Role[2]}}{\Label[end]}{\PSendU{\Chan}{\Role[3]}{\Role[1]}{\Label[win]}{\Args_{\Role[1]} \leq 21}{\PSendU{\Chan}{\Role[3]}{\Role[2]}{\Label[win]}{\Args_{\Role[2]} \leq 21}{\PEnd}}}
		\end{array}\\
	\PDiceP ={}& \PAcc{\Chan[a]}{\Role[i]}{\Chan}{\PRep{\ProcV}{\PBranW{\Chan}{\Role[i]}{\Role[3]}{\Label[play].\PGetU{\Chan}{\Role[i]}{\Role[3]}{\Label[roll]}{\Args}{\Args}{\ProcV} \oplus \Label[end].\PGetU{\Chan}{\Role[i]}{\Role[3]}{\Label[win]}{\false}{\Args[w]}{\PEnd}}}}
\end{align*}
Role~$ \Role[3] $ stores the sums of former dice rolls for the two players in its local variables $ \Args_{\Role[1]} $ and $ \Args_{\Role[2]} $, and $ \textsf{roll}(\Args_{\Role[i]}) $ rolls a dice and adds its value to the respective $ \Args_{\Role[i]} $.
Role~$ \Role[3] $ keeps rolling dice until the sum $ \Args_{\Role[i]} $ for one of the players exceeds $ 21 $.
If both sums $ \Args_{\Role[1]} $ and $ \Args_{\Role[2]} $ exceed $ 21 $ in the same round, then $ \Role[3] $ wins, \ie both players receive $ \false $; else, the player that stayed below $ 21 $ wins and receives $ \true $.
The players $ \Role[1] $ and $ \Role[2] $ use their respective last known sum that is stored in $ \Args $ as default value for the \unrel communication in the branch $ \Label[play] $ and $ \false $ as default value in the branch $ \Label[end] $.
The last branch, \ie $ \Label[end] $, is the default branch.

Our type system verifies processes, \ie implementations, against a specification that is a global type.
Since processes implement local views, local types are used as a mediator between the global specification and the respective local end points.
To ensure that the local types correspond to the global type, they are derived by \emph{projection}.
Instead of the projection function described in \cite{hondaYoshidaCarbone16} we use a more relaxed variant of projection as introduced in \cite{YoshidaDanielouBejleriHu10}.

Projection maps global types onto the respective local type for a given role $ \Role[p] $.
The projections of the new global types are obtained straightforwardly from the projection of their respective \strongR counterparts:
\begin{align*}
	\Proj{\left( \Role_1 \to_{\textcolor{blue}{\diamond}} \Role_2{:}{\textcolor{blue}{\mathfrak{S}}}.\GT \right)}{\Role[p]} \deff
	\begin{cases}
		{\left[ \Role_2 \right]}\mathsf{!}_{\textcolor{blue}{\diamond}}{\textcolor{blue}{\mathfrak{S}}}.{\Proj{\GT}{\Role[p]}} & \text{if } \Role[p] = \Role_1\\
		{\left[ \Role_1 \right]}\mathsf{?}_{\textcolor{blue}{\diamond}}{\textcolor{blue}{\mathfrak{S}}}.{\Proj{\GT}{\Role[p]}} & \text{if } \Role[p] = \Role_2\\
		\Proj{\GT}{\Role[p]} & \text{otherwise}
	\end{cases}
\end{align*}
where either $ \diamond = \iR $, $ \mathfrak{S} = {\left< \Sort \right>} $ or $ \textcolor{blue}{\diamond = \iU} $, $ \textcolor{blue}{\mathfrak{S} = \Label{\left< \Sort \right>}} $ and
\begin{align*}
	\Proj{\left( \Role_1 \to_{\textcolor{blue}{\diamond}} \textcolor{blue}{\mathfrak{R}}{:}{\Set{ \Label_i.\GT_i }_{i \in \indexSet \textcolor{blue}{\mathfrak{D}}}} \right)}{\Role[p]} \deff
	\begin{cases}
		{\left[ \textcolor{blue}{\mathfrak{R}} \right]}\mathsf{!}_{\textcolor{blue}{\diamond}}{\Set{ \Label_i.\Proj{\GT_i}{\Role[p]} }_{i \in \indexSet}} & \text{if } \Role[p] = \Role_1\\
		{\left[ \Role_1 \right]}\mathsf{?}_{\textcolor{blue}{\diamond}}{\Set{ \Label_i.\Proj{\GT_i}{\Role[p]} }_{i \in \indexSet \textcolor{blue}{\mathfrak{D}}}} & \text{if } \textcolor{blue}{\mathfrak{B}}\\
		\bigsqcup_{i \in \indexSet} \left( \Proj{\GT_i}{\Role[p]} \right) & \text{otherwise}
	\end{cases}
\end{align*}
where either $ \diamond = \iR $, $ \mathfrak{R} = \Role_2 $, $ \mathfrak{B} $ is $ \Role[p] = \Role_2 $, $ \mathfrak{D} $ is empty or $ \textcolor{blue}{\diamond = \iW} $, $ \textcolor{blue}{\mathfrak{R} = \Role[R]} $, $ \textcolor{blue}{\mathfrak{B}} $ is $ \textcolor{blue}{\Role[p] \in \Role[R]} $, $ \textcolor{blue}{\mathfrak{D}} $ is $ \textcolor{blue}{, \LabelD} $.
In the last case of \strongR or \weakR branching---when projecting onto a role that does not participate in this branching---we map to $ \bigsqcup_{i \in \indexSet} \left( \Proj{\GT_i}{\Role[p]} \right) = \left( \Proj{\GT_1}{\Role[p]} \right) \sqcup \ldots \sqcup \left( \Proj{\GT_n}{\Role[p]} \right) $.
The operation $ \sqcup $ is (similar to \cite{YoshidaDanielouBejleriHu10}) inductively defined as:
\begin{align*}
	\LT \sqcup \LT &= \LT\\
	\left( \LBranR{\Role}{\indexSet_1} \right) \sqcup \left( \LBranR{\Role}{\indexSet_2} \right) &= \LBranR{\Role}{\left( \indexSet_1 \sqcup \indexSet_2 \right)}\\
	\left( \LBranW{\Role}{\indexSet_1} \right) \sqcup \left( \LBranW{\Role}{\indexSet_2} \right) &= \LBranW{\Role}{\left( \indexSet_1 \sqcup \indexSet_2 \right)} \quad \text{if } \indexSet_1 \text{ and } \indexSet_2 \text{ have the same default branch}\\
	\indexSet \sqcup \emptyset &= \indexSet\\
	\indexSet \sqcup \left( \Set{ \Label.\LT } \cup \indexSet[J] \right) &=
		\begin{cases}
			\Set{ \Label.\left( \LT' \sqcup \LT \right) } \cup \left( \left( \indexSet \setminus \Set{ \Label.\LT' } \right) \sqcup \indexSet[J] \right) & \text{if } \Label.\LT' \in \indexSet\\
			\Set{ \Label.\LT } \cup \left( \indexSet \sqcup \indexSet[J] \right) & \text{if } \Label \notin \indexSet
		\end{cases}
\end{align*}
where $ \LT, \LT' \in \localTypes $, $ \Label \notin \indexSet $ is short hand for $ \nexists \LT'\logdot \Label.\LT' \in \indexSet $, and is undefined in all other cases.
The mergeability relation $ \sqcup $ states that two types are identical up to their branching types, where only branches with distinct labels are allowed to be different.
This ensures that if the sender~$ \Role_1 $ in $ \GBranR{\Role_1}{\Role_2}{\Set{ \Label_i.\GT_i }_{i \in \indexSet}} $ decides to branch then only processes that are informed about this decision can adapt their behaviour accordingly; else projection is \textbf{not} defined.

The remaining global types are projected as follows:
\[\begin{array}{c}
	\Proj{\left( \GPar{\GT_1}{\GT_2} \right)}{\Role[p]} \deff
		\begin{cases}
			\Proj{\GT_1}{\Role[p]} & \text{if } \Role[p] \notin \Roles{\GT_2}\\
			\Proj{\GT_2}{\Role[p]} & \text{if } \Role[p] \notin \Roles{\GT_1}
		\end{cases}
	\hspace{1em}
	\Proj{\left( \GRep{\TypeV}{\GT} \right)}{\Role[p]} \deff
		\begin{cases}
			\LRep{\TypeV}{\Proj{\GT}{\Role[p]}} & \text{if } \Role[p] \in \Roles{\GT}\\
			\LEnd & \text{otherwise}
		\end{cases} \vspace{0.5em}\\
	\Proj{\TypeV}{\Role[p]} \deff \TypeV
	\hspace{2em}
	\Proj{\GEnd}{\Role[p]} \deff \LEnd
\end{array}\]

The projection of $ \GPar{\GT_1}{\GT_2} $ on $ \Role[p] $ is \textbf{not} defined if $ \Role[p] $ occurs on both sides of this parallel composition; it is $ \Proj{\GT_i}{\Role[p]} $ if $ \Role[p] $ occurs in exactly one side $ i \in \Set{ 1, 2 } $; or it is $ \Proj{\left( \GPar{\GT_1}{\GT_2} \right)}{\Role[p]} = \Proj{\GT_1}{\Role[p]} = \Proj{\GT_2}{\Role[p]} = \LEnd $ if $ \Role[p] $ does not occur at all.
Projecting a recursive global type results in a recursive local type if $ \Role[p] $ occurs in the body of the recursion or else in successful termination.
Type variables and successful termination are mapped onto themselves.
We denote a global type $ \GT $ as \emph{projectable} if for all $ \Role \in \Roles{\GT} $ the projection $ \Proj{\GT}{\Role} $ is defined.
We restrict our attention to projectable global types.

Projecting the global type $ \GDice $ in (\ref{eq:diceG}) results in the local types
\begin{align*}
	\LDice{\Role[3]} &= \LRep{\TypeV}{\LSendR{\Role[1]}{\nat}{\LSendR{\Role[2]}{\nat}{\LSelR{\Role[1]}{{\Set{\Label[roll].\LSelR{\Role[2]}{\Label[roll].\TypeV}, \quad \Label[exit].\LSelR{\Role[2]}{\Label[exit].\LEnd}}}}}}}\\
	\LDice{\Role[i]} &= \LRep{\TypeV}{\LGetR{\Role[3]}{\nat}{\LBranR{\Role[3]}{\Set{\Label[roll].\TypeV, \quad \Label[exit].\LEnd}}}}
\end{align*}
where the types of the two players $ \LDice{\Role[1]} = \LDice{\Role[2]} = \LDice{\Role[i]} $ are identical.
The projection of the outer branching in $ \GDice $ on $ \Role[2] $ results in $ \LBranR{\Role[3]}{\Label[roll].\TypeV} $ for the first branch and $ \LBranR{\Role[3]}{\Label[exit].\LEnd} $ for the second branch.
These two $ \LBranR{\Role[3]}{} $ types are unified by $ \sqcup $ into a single $ \LBranR{\Role[3]}{} $ type with two branches.

Projection maps $ \GDiceW $ in (\ref{eq:diceGW}) to:
\begin{align*}
	\LDiceW{\Role[3]} &= \LRep{\TypeV}{\LSelW{\Set{ \Role[1], \Role[2] }}{}
		\begin{array}[t]{l}
			\Label[play].\LSendU{\Role[1]}{\Label[roll]}{\nat}{\LSendU{\Role[2]}{\Label[roll]}{\nat}{\TypeV}}\\
			\oplus \; \Label[end].\LSendU{\Role[1]}{\Label[win]}{\bool}{\LSendU{\Role[2]}{\Label[win]}{\bool}{\LEnd}}
		\end{array}}\\
	\LDiceW{\Role[i]} &= \LRep{\TypeV}{\LBranW{\Role[3]}{\left( \Label[play].\LGetU{\Role[3]}{\Label[roll]}{\nat}{\TypeV} \oplus \Label[end].\LGetU{\Role[3]}{\Label[win]}{\bool}{\LEnd} \right)}}
\end{align*}
where $ \Role[i] \in \Set{ \Role[1], \Role[2] } $ and both $ \LDiceW{\Role[i]} $ are obtained by the second case of projection.
The type system will ensure that either $ \Role[3] $ transmits the request to branch to both players $ \Role[1], \Role[2] $ simultaneously and, since these messages cannot be lost, all players that are not crashed move to same branch or $ \Role[3] $ crashes and all remaining players move to the default branch.

Assume instead that $ \Role[3] $ can only inform one of the players $ \Role[1], \Role[2] $ at once.
The type
\begin{align*}
	\GRep{\TypeV}{\GBranW{\Role[3]}{\Set{ \Role[1] }}{}
		\begin{array}[t]{l}
			\Label[play].\GComU{\Role[3]}{\Role[1]}{\Label[roll]}{\nat}{\GComU{\Role[3]}{\Role[2]}{\Label[roll]}{\nat}{\TypeV}}\\
			\oplus \; \Label[end].\GComU{\Role[3]}{\Role[1]}{\Label[win]}{\bool}{\GComU{\Role[3]}{\Role[2]}{\Label[win]}{\bool}{\GEnd}}
		\end{array}}
\end{align*}
is not projectable, because $ \sqcup $ does not allow to unify the projections $ \LGetU{\Role[3]}{\Label[roll]}{\nat}{\TypeV} $ and $ \LGetU{\Role[3]}{\Label[win]}{\bool}{\LEnd} $ of the two branches of $ \Role[2] $.
Replacing the two \unrel communications with $ \Role[2] $ by \strongR communications implies that neither $ \Role[3] $ nor $ \Role[2] $ fail.
The type
\begin{align*}
	& \GRep{\TypeV}{\GBranW{\Role[3]}{\Set{ \Role[1] }}{}\\
	& \hspace{2em} \begin{array}[t]{l}
			\Label[play].\GComU{\Role[3]}{\Role[1]}{\Label[roll]}{\nat}{\GBranW{\Role[3]}{\Set{ \Role[2] }}{\left( \Label[play].\GComU{\Role[3]}{\Role[2]}{\Label[roll]}{\nat}{\TypeV} \oplus \Label[end].\GEnd \right)}}\\
			\oplus \; \Label[end].\GComU{\Role[3]}{\Role[1]}{\Label[win]}{\bool}{\GBranW{\Role[3]}{\Set{ \Role[2] }}{\left( \Label[play].\GEnd \oplus \Label[end].\GComU{\Role[3]}{\Role[2]}{\Label[win]}{\bool}{\GEnd} \right)}}
		\end{array}}
\end{align*}
	where $ \Role[3] $ informs its two players subsequently about the chosen branch is projectable.
	But it introduces the two additional branches $ \Label[end].\GEnd $ and $ \Label[play].\GEnd $, \ie $ \Role[3] $ is allowed to choose the branches for the players $ \Role[1], \Role[2] $ separately and differently, whereas in (\ref{eq:diceG}) as well as in (\ref{eq:diceGW}) the players $ \Role[1], \Role[2] $ are always in the same branch.
Because of that, we allow for broadcast in \weakR branching such that $ \Role[3] $ can inform both players consistently without introducing additional and not-intended branches.

In types $ \GRep{\TypeV}{\GT} $ and $ \LRep{\TypeV}{\LT} $ the type variable $ \TypeV $ is \emph{bound}.
In processes $ \PRep{\ProcV}{\PT} $ the process variable $ \ProcV $ is bound.
Similarly, all names in round brackets are bound in the remainder of the respective process, \eg $ \Chan $ is bound in $ \PT $ by $ \PReq{\Chan[a]}{\Role[n]}{\Chan}{\PT} $ and $ \Args $ is bound in $ \PT $ by $ \PGetR{\Chan}{\Role_1}{\Role_2}{\Args}{\PT} $.
A variable or name is \emph{free} if it is not bound. Let $ \FreeNames{\PT} $ return the free names of $ \PT $.

Let \emph{subterm} denote a (type or process) expression that syntactically occurs within another (type or process) term.
We use '$. $' (as \eg in $ \PReq{\Chan[a]}{\Role}{\Chan}{\PT} $) to denote sequential composition. In all operators the \emph{prefix} before '$. $' guards the \emph{continuation} after the '$. $'.
Let $ \prod_{1 \leq i \leq n} \PT_i $ abbreviate the parallel composition $ \PPar{\PT_1}{\PPar{\ldots}{\PT_n}} $.

We write  $ \Unreliable{\GT} $, $ \Unreliable{\LT} $, and $ \Unreliable{\PT} $, if none of the prefixes in $ \GT $, $ \LT $, and $ \PT $ is \strongR or for delegation and if $ \PT $ does not contain message queues.
Let $ \Roles{\GT} $ return all roles that occur in $ \GT $.
A global type is \emph{well-formed} if
(1) it neither contains free nor unguarded type variables,
(2) $ \Roles{G} = \Set{ 1, \ldots, \Length{\Roles{G}} } $,
(3) for all its subterms of the form $ \GComR{\Role_1}{\Role_2}{\Sort}{\GT} $ and $ \GComU{\Role_1}{\Role_2}{\Label}{\Sort}{\GT} $, we have $ \Role_1 \neq \Role_2 $,
(4) for all its subterms of the form $ \GBranR{\Role_1}{\Role_2}{\Set{ \Label_i.\GT_i }_{i \in \indexSet}} $ and $ \GBranW{\Role}{\Role[R]}{\Set{ \Label_i.\GT_i }_{i \in \indexSet, \LabelD}} $, we have $ \Role_1 \neq \Role_2 $, $ \Role \notin \Role[R] $, $ \default \in \indexSet $, and the labels $ \Label_i $ are pairwise distinct, and
(5) for all its subterms of the form $ \GPar{\GT_1}{\GT_2} $, we have $ \Roles{\GT_1} \cap \Roles{\GT_2} = \emptyset $.
We restrict our attention to well-formed global types for that projection is defined on all its roles.

The combination of a session channel and a role uniquely identifies a participant of a session, called an \emph{actor}. A process has an actor $ \AT{\Chan[s]}{\Role} $ if it has an action prefix on $ \Chan $, where $ \Role $ is the first role mentioned in the prefix.
Let $ \Actors{\PT} $ be the set of actors of $ \PT $.

\subsection{A Semantics with Failure Patterns}
\label{sec:failurePatterns}

The application of a substitution $ \Subst{\Args[y]}{\Args} $ on a term $ A $, denoted as $ A\Subst{\Args[y]}{\Args} $, is defined as the result of replacing all free occurrences of $ \Args $ in $ A $ by $ \Args[y] $, possibly applying alpha-conversion to avoid capture or name clashes. For all names $ n \in \names \setminus \Set{ \Args } $ the substitution behaves as the identity mapping. We use substitution on types as well as processes and naturally extend substitution to the substitution of variables by terms (to unfold recursions) and names by expressions (to instantiate a bound name with a received value).

We use labels for two purposes:
they allow us to distinguish between different branches, as usual in \MPST-frameworks, and we assume that they may carry additional runtime information such as time\-stamps.
Of course, the presented type system remains valid if we use labels without additional information.
In contrast to standard \MPST (as \eg in \cite{hondaYoshidaCarbone16}) and to support \unrel communication, our \MPST variant will ensure that all occurrences of the same label are associated with the same sort.
We assume a predicate $ \compL[] $ that compares two labels and is valid if the parts of the labels that do not refer to runtime information correspond.
If runtime information are irrelevant, $ \compL[] $ can be instantiated with equality.
We require that $ \compL[] $ is unambiguous on labels used in types, \ie given two labels of processes $ \Label_{\PT}, \Label_{\PT}' $ and two labels of types $ \Label_{\LT}, \Label_{\LT}' $ then $ \Label_{\PT} \compL \Label_{\PT}' \wedge \Label_{\PT} \compL \Label_{\LT} \Rightarrow \Label_{\PT}' \compL \Label_{\LT} $ and $ \Label_{\PT} \compL \Label_{\LT} \wedge \Label_{\LT} \nCompL \Label_{\LT}' \Rightarrow \Label_{\PT} \nCompL \Label_{\LT}' $.
%Since runtime information is not available in types, it cannot be used to guide branching.

We use structural congruence to abstract from syntactically different processes with the same meaning, where $ \equiv $ is the least congruence that satisfies alpha conversion and the rules:
\[ \begin{array}{c}
	\PT \mid \PEnd \equiv \PT
	\hspace{2em} \PT_1 \mid \PT_2 \equiv \PT_2 \mid \PT_1
	\hspace{2em} \PT_1 \mid \left( \PT_2 \mid \PT_3 \right) \equiv \left( \PT_1 \mid \PT_2 \right) \mid \PT_3\\
	\PRep{\ProcV}{\PEnd} \equiv \PEnd
	\hspace{2em} \PRes{\Args}{\PEnd} \equiv \PEnd
	\hspace{2em} \PRes{\Args}{\PRes{\Args[y]}{\PT}} \equiv \PRes{\Args[y]}{\PRes{\Args}{\PT}}\\
	\PRes{\Args}{\left( \PT_1 \mid \PT_2 \right)} \equiv \PT_1 \mid \PRes{\Args}{\PT_2} \quad \text{if } \Args \notin \FreeNames{\PT_1}
\end{array} \]

\begin{figure}[tp]
	\renewcommand{\tabcolsep}{2pt}
	\begin{tabular}{ll}
		(\textsf{Init}) & $ \PReq{\Chan[a]}{\Role[n]}{\Chan}{\PT_{\Role[n]}} \mid \prod_{1 \leq \Role[i] \leq \Role[n] - 1} \PAcc{\Chan[a]}{\Role[i]}{\Chan}{\PT_{\Role[i]}} \step \PRes{\Chan}{\left( \prod_{1 \leq \Role[i] \leq \Role[n]} \PT_{\Role[i]} \mid \prod_{1 \leq \Role[i], \Role[j] \leq \Role[n], \Role[i] \neq \Role[j]} \MQ{\Chan}{\Role[i]}{\Role[j]}{\emptyList} \right)} $\\
		& \hfill if $ \Chan[a] \neq \Chan $\\
		(\textsf{RSend}) & $ \PSendR{\Chan}{\Role_1}{\Role_2}{\Expr[y]}{\PT} \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} \step \PT \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue\#\MessR{\Expr[v]}} $ \hfill if $ \Eval{\Expr[y]} = \Expr[v] $\\
		(\textsf{RGet}) & $ \PGetR{\Chan}{\Role_1}{\Role_2}{\Args}{\PT} \mid \MQ{\Chan}{\Role_2}{\Role_1}{\MessR{\Expr[v]}\#\Queue} \step \PT\Subst{\Expr[v]}{\Args} \mid \MQ{\Chan}{\Role_2}{\Role_1}{\Queue} $\\
		\textcolor{blue}{(\textsf{USend})} & \textcolor{blue}{$ \PSendU{\Chan}{\Role_1}{\Role_2}{\Label}{\Expr[y]}{\PT} \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} \step \PT \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue\#\MessU{\Label}{\Expr[v]}} $ \hfill if $ \Eval{\Expr[y]} = \Expr[v] $}\\
		\textcolor{blue}{(\textsf{UGet})} & \textcolor{blue}{$ \PGetU{\Chan}{\Role_1}{\Role_2}{\Label}{\Expr[dv]}{\Args}{\PT} \mid \MQ{\Chan}{\Role_2}{\Role_1}{\MessU{\Label'}{\Expr[v]}\#\Queue} \step \PT\Subst{\Expr[v]}{\Args} \mid \MQ{\Chan}{\Role_2}{\Role_1}{\Queue} $}\\
		& \hfill \textcolor{blue}{if $ \Label \compL \Label' $, $ \fpUGet(\Chan, \Role_1, \Role_2, \Label') $}\\
		\textcolor{blue}{(\textsf{USkip})} & \textcolor{blue}{$ \PGetU{\Chan}{\Role_1}{\Role_2}{\Label}{\Expr[dv]}{\Args}{\PT} \step \PT\Subst{\Expr[dv]}{\Args} $ \hfill if $ \fpUSkip(\Chan, \Role_1, \Role_2, \Label) $}\\
		\textcolor{blue}{(\textsf{ML})} & \textcolor{blue}{$ \MQ{\Chan}{\Role_1}{\Role_2}{\MessU{\Label}{\Expr[v]}\#\Queue} \step \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} $ \hfill if $ \fpML(\Chan, \Role_1, \Role_2, \Label) $}\\
		(\textsf{RSel}) & $ \PSelR{\Chan}{\Role_1}{\Role_2}{\Label}{\PT} \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} \step \PT \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue\#\MessBR{\Label}} $\\
		(\textsf{RBran}) & $ \PBranR{\Chan}{\Role_1}{\Role_2}{\Set{ \Label_i.\PT_i }_{i \in \indexSet}} \mid \MQ{\Chan}{\Role_2}{\Role_1}{\MessBR{\Label}\#\Queue} \step \PT_j \mid \MQ{\Chan}{\Role_2}{\Role_1}{\Queue} $ \hfill if $ \Label \compL \Label_j $, $ j \in \indexSet $\\
		\textcolor{blue}{(\textsf{WSel})} & \textcolor{blue}{$ \PSelW{\Chan}{\Role}{\Role[R]}{\Label}{\PT} \mid \prod_{\Role_i \in \Role[R]} \MQ{\Chan}{\Role}{\Role_i}{\Queue_i} \step \PT \mid \prod_{\Role_i \in \Role[R]} \MQ{\Chan}{\Role}{\Role_i}{\Queue_i\#\MessBW{\Label}} $}\\
		\textcolor{blue}{(\textsf{WBran})} & \textcolor{blue}{$ \PBranW{\Chan}{\Role_1}{\Role_2}{\Set{ \Label_i.\PT_i }_{i \in \indexSet, \LabelD}} \mid \MQ{\Chan}{\Role_2}{\Role_1}{\MessBW{\Label}\#\Queue} \step \PT_j \mid \MQ{\Chan}{\Role_2}{\Role_1}{\Queue} $ \hfill if $ \Label \compL \Label_j $, $ j \in \indexSet $}\\
		\textcolor{blue}{(\textsf{WSkip})} & \textcolor{blue}{$ \PBranW{\Chan}{\Role_1}{\Role_2}{\Set{ \Label_i.\PT_i }_{i \in \indexSet, \LabelD}} \step \PTD $ \hfill if $ \fpWSkip(\Chan, \Role_1, \Role_2) $}\\
		\textcolor{blue}{(\textsf{Crash})} & \textcolor{blue}{$ \PT \step \PCrash $ \hfill if $ \fpCrash(\PT) $}
	\end{tabular}
	\vspace*{-0.5em}
	\caption{Reduction Rules ($ \step $) of Fault-Tolerant Processes (Part 1).}
	\label{fig:semanticsPartA}
\end{figure}

The reduction semantics of the session calculus is defined in Fig.~\ref{fig:semanticsPartA} and Fig.~\ref{fig:semanticsPartB}, where we follow~\cite{hondaYoshidaCarbone16}: we assume that session initialisation is synchronous and communication within a session is asynchronous implemented using message queues.

Rule~(\textsf{Init}) initialises a session with $ \Role[n] $ roles.
Session initialisation introduces a fresh session channel and unguards the participants of the session.
Finally, the message queues of this session are initialised with the empty list under the restriction of the session channel.

Rule~(\textsf{RSend}) implements an asynchronous \strongR message transmission.
As a result the value $ \Eval{\Expr[y]} $ is wrapped in a message and added to the end of the corresponding message queue and the continuation of the sender is unguarded.
Rule~(\textsf{USend}) is the counterpart of (\textsf{RSend}) for \unrel senders.
%
(\textsf{RGet}) consumes a message that is marked as \strongR with the index $ \operatorname{r} $ from the head of the respective message queue and replaces in the unguarded continuation of the receiver the bound variable $ \Args $ by the received value $ \Args[y] $.

There are two rules for the reception of a message in an \unrel communication that are guided by failure patterns.
\emph{Failure patterns} are predicates that we deliberately choose not to define here (see below).
They allow us to provide information about the underlying communication medium and the reliability of processes.
Rule~(\textsf{UGet}) is similar to Rule~(\textsf{RGet}), but specifies a failure pattern $ \fpUGet $ to decide whether this step is allowed.
This failure pattern could, \eg, be used to reject messages that are too old.
The Rule~(\textsf{USkip}) allows to skip the reception of a message in an \unrel communication using a failure pattern $ \fpUSkip $ and instead substitutes the bound variable $ \Args $ in the continuation with the default value $ \Args[dv] $.
The failure pattern $ \fpUSkip $ tells us whether a reception can be skipped (\eg via failure detector).

Rule~(\textsf{RSel}) puts the label $ \Label $ selected by $ \Role_1 $ at the end of the message queue towards $ \Role_2 $.
Its \weakR counterpart (\textsf{WSel}) is similar, but puts the label at the end of all relevant message queues.
%
With (\textsf{RBran}) a label is consumed from the top of a message queue and the receiver moves to the indicated branch.
There are again two \weakR counterparts of (\textsf{RBran}).
Rule~(\textsf{WBran}) is similar to (\textsf{RBran}), whereas (\textsf{WSkip}) allows $ \Role_1 $ to skip the message and to move to its default branch if the failure pattern $ \fpWSkip $ holds.

The Rules~(\textsf{Crash}) for \emph{crash failures} and (\textsf{ML}) for \emph{message loss}, describe failures of a system.
With Rule~(\textsf{Crash}) $ \PT $ can crash if $ \fpCrash $, where $ \fpCrash $ can \eg model immortal processes or global bounds on the number of crashes.
(\textsf{ML}) allows to drop an \unrel message if the failure pattern $ \fpML $ is valid.
$ \fpML $ allows, \eg, to implement safe channels that never lose messages or a global bound on the number of lost messages.

\begin{figure}[t]
	\renewcommand{\tabcolsep}{2pt}
	\begin{tabular}{ll}
		(\textsf{If-T}) & $ \PITE{\Expr}{\PT}{\PT'} \step \PT $ \hspace{15em} if $ \Expr $ is true\\
		(\textsf{If-F}) & $ \PITE{\Expr}{\PT}{\PT'} \step \PT' $ \hfill if $ \Expr $ is false\\
		(\textsf{Deleg}) & $ \PDelA{\Chan}{\Role_1}{\Role_2}{\AT{\Chan'}{\Role}}{\PT} \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} \step \PT \mid \MQ{\Chan}{\Role_1}{\Role_2}{\Queue\#\AT{\Chan'}{\Role}} $\\
		(\textsf{SRecv}) & $ \PDelB{\Chan}{\Role_1}{\Role_2}{\AT{\Chan'}{\Role}}{\PT} \mid \MQ{\Chan}{\Role_2}{\Role_1}{\AT{\Chan''}{\Role'}\#\Queue} \step \PT\Subst{\Chan''}{\Chan'}\Subst{\Role'}{\Role} \mid \Queue $\\
		(\textsf{Par}) & $ \PT_1 \mid \PT_2 \step \PT_1' \mid \PT_2 $ \hfill if $ \PT_1 \step \PT_1' $\\
		(\textsf{Res}) & $ \PRes{\Args}{\PT} \step \PRes{\Args}{\PT'} $ \hfill if $ \PT \step \PT' $\\
		(\textsf{Rec}) & $ \PRep{\ProcV}{\PT} \step \PT\Subst{\PRep{\ProcV}{\PT}}{\ProcV} $\\
		(\textsf{Struc}) & $ \PT_1 \step \PT_1' $ \hfill if $ \PT_1 \equiv \PT_2 $, $ \PT_2 \step \PT_2' $, $ \PT_2' \equiv \PT_1' $
	\end{tabular}
	\caption{Reduction Rules ($ \step $) of Fault-Tolerant Processes (Part 2).}
	\label{fig:semanticsPartB}
\end{figure}

The remaining rules for conditionals, session delegation, parallel composition, restriction, recursion, and structural congruence in Fig.~\ref{fig:semanticsPartB} are standard.

We augmented our reduction semantics in Fig.~\ref{fig:semanticsPartA} by five different failure patterns that we deliberately do not specify, although we usually assume that the failure patterns $ \fpUGet $, $ \fpUSkip $, and $ \fpWSkip $ use only local information, whereas $ \fpML $ and $ \fpCrash $ may use global information of the system in the current run.
We provide these predicates to allow for the implementation of system requirements or abstractions like failure detectors that are typical for distributed algorithms.
Directly including them in the semantics has the advantage that all traces satisfy the corresponding requirements, \ie all traces are valid \wrt the assumed system requirements.
An example for the instantiation of these patterns is given implicitly via the Conditions~\ref{cond:all}.\ref{cond:crash}--\ref{cond:all}.\ref{cond:fpWskip} in Section~\ref{sec:typing} and explicitly in Section~\ref{sec:example}.
If we instantiate the patterns $ \fpUGet $ with true and the patterns $ \fpUSkip $, $ \fpWSkip $, $ \fpCrash $, $ \fpML $ with false, then we obtain a system without failures.
In contrast, the instantiation of all five patterns with true results in a system where failures can happen completely non-deterministically at any time.

One of the properties that our type system has to ensure even in the case of failures is the absence of communication mismatches, \ie the type of a transmitted value has to be the type that the receiver expects.
The global type $ \GComU{\Role[1]}{\Role[2]}{\Label_1}{\nat}{\GComU{\Role[1]}{\Role[2]}{\Label_2}{\bool}{\GEnd}} $ specifies two subsequent \unrel communications in that values of different sorts are transmitted.
If the first message with its natural number is lost but the second message containing a Boolean value is transmitted, $ \Role[2] $ could wrongly receive a Boolean value although it still waits for a natural number.
To avoid this mismatch, we add a label to \unrel communication and ensure (by the typing rules) that the same label is never associated with different types.
Similarly, labels are used in \cite{CairesVieira10} to avoid communication errors.
Accordingly, we require $ \Label_1 \nCompL \Label_2 $ such that the reduction rules in Fig.~\ref{fig:semanticsPartA} will not allow to consume the Boolean message before $ \Role[2] $ has reduced its first prefix.

We do that, because we think of labels not only as identifiers for branching but also as some kind of meta data of messages as they can be often found in communication media or as they are assumed by many distributed algorithms.
Our \unrel communication mechanism exploits such meta data to guarantee strong properties about the communication structure including the described absence of communication mismatches.

Note that we keep the failure patterns abstract and do not model how to check them in producing runs.
Indeed system requirements such as bounds on the number of processes that can crash usually cannot be checked, but result from observations, \ie system designers ensure that a violation of this bound is very unlikely and algorithm designers are willing to ignore these unlikely events.
In particular, $ \fpML $ and $ \fpCrash $ are thus often implemented as oracles for verification, whereas \eg $ \fpUSkip $ and $ \fpWSkip $ are often implemented by system specific time-outs.
Note that we are talking about implementing these failure patterns and not formalising them.
Failure patterns are abstractions of real world system requirements or software.
We implement them by conditions providing the necessary guarantees that we need in general (\ie for subject reduction and progress) or for the verification of concrete algorithms.
In practise, we expect that the systems on that the verified algorithms are running satisfy the respective conditions.
Accordingly, the session channels, roles, labels, and processes mentioned in Fig.~\ref{fig:semanticsPartA} are not parameters of the failure patterns, but just a vehicle to more formally specify the conditions on failure patterns in Section~\ref{sec:typing}.

Similarly, \strongR and \weakR interactions in potentially faulty systems are abstractions.
They are usually implemented by handshakes and redundancy; replicated servers against crash failures and retransmission of late messages against message loss.
Algorithm designers have to be aware of the additional costs of these interactions.

Consider the implementation of $ \GDiceUC $ in (\ref{eq:diceGU}), \ie an infinite variant of the dice game, where the players $ \Role[1] $ and $ \Role[2] $ use their respective last known sum $ \Args_{\Role[i]} $ of former dice rolls as default values:
\begin{align*}
	\PDiceUC ={}& \PPar{\PDiceDUC}{\PPar{\PDicePUC}{\PDiceQUC}}\\
	\PDiceDUC ={}& \PReq{\Chan[a]}{\Role[3]}{\Chan}{\PRep{\ProcV}{\PSendU{\Chan}{\Role[3]}{\Role[1]}{\Label[roll]}{\textsf{roll}(\Args_{\Role[1]})}{\PSendU{\Chan}{\Role[3]}{\Role[2]}{\Label[roll]}{\textsf{roll}(\Args_{\Role[2]})}{\ProcV}}}}\\
	\PDicePUC ={}& \PAcc{\Chan[a]}{\Role[i]}{\Chan}{\PRep{\ProcV}{\PGetU{\Chan}{\Role[i]}{\Role[3]}{\Label[roll]}{\Args_{\Role[i]}}{\Args_{\Role[i]}}{\ProcV}}}
%		\PDiceQUC ={}& \PInp{\Chan}{2}{\Chan[s]}{\PRec{\ProcV}{\Chan[s]}{\Role[2]}{\left( \PGetU{\Chan[s]}{\Role[2]}{\Role[3]}{\Label[roll]}{\Args_{\Role[2]}}{\Args_{\Role[2]}}{\PVar{\Chan[s]}{\Role[2]}} \right)}}
\end{align*}
An \unrel communication in a global type specifies a communication that, due to system failures, may or may not happen.
Moreover, regardless of the successful completion of this \unrel communication, the future behaviour of a well-typed system will follow its specification in the global type.
Since the players $ \Role[1] $ and $ \Role[2] $ repeat the same kind of \unrel action, they may lose track of the current round.
If they successfully receive a new sum of dice rolls from $ \Role[3] $ they cannot be sure on how often $ \Role[3] $ actually did roll the dice.
Because of lost messages, they may have missed some former announcements of $ \Role[3] $ and, because of their ability to skip the reception of messages, they may have proceeded to the next round before $ \Role[3] $ rolled a dice.
Because the information about the current round is irrelevant for the communication structure in this case, there is no need to enforce round information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Typing Fault-Tolerant Processes  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Typing Fault-Tolerant Processes}
\label{sec:typing}

The type of a process $ \PT $ is checked in a \emph{typed judgment}, \ie triples $ \Gamma \vdash \PT \triangleright \Delta $, where
\begin{align*}
	\Gamma & \deffTerms \emptyset
		\sepTerms \Gamma \compS \Typed{\Args}{\Sort}
		\sepTerms \Gamma \compS \Typed{\Chan[a]}{\GT}
		\sepTerms \textcolor{blue}{\Gamma \compS \Typed{\Label}{\Sort}}\\
%		\sepTerms \Gamma \compS \Typed{\ProcV}{\Typed{\AT{\Chan}{\Role}}{\TypeV}}
	\Delta &\deffTerms \emptyset
		\sepTerms \Delta \compS \Typed{\AT{\Chan}{\Role}}{\LT}
		\sepTerms \Delta \compS \MQ{\Chan}{\Role_1}{\Role_2}{\MT^*}
\end{align*}
Assignments in $ \Gamma $ relate variables to their sort, shared channels to the type of the session they introduce, and connect labels with a sort.
Session environments collect the local types of actors and the list of message types of queues, \ie $ \MT^* $ denotes a list of message types.

We write $ \Args \sharp \Gamma $ and $ \Args \sharp \Delta $ if the name $ \Args $ does not occur in $ \Gamma $ and $ \Delta $, respectively.
We use $ \compS $ to add an assignment provided that the new assignment is not in conflict with the type environment, \ie $ \Gamma \compS A $ implies that the respective name/variable/label in $ A $ is not contained in $ \Gamma $ and $ \Delta \compS A $ implies that the respective actor/queue in $ A $ is not contained in $ \Delta $.
These conditions on $ \compS $ for global and session environments are referred to as \emph{linearity}.
We restrict in the following our attention to linear environments.



\begin{figure}[tp]
	\centering
	\[ \begin{array}{c}
		\left( \textsf{Req} \right) \dfrac{\!\!\begin{array}{c} \Typed{\Chan[a]}{\GT} \in \Gamma \quad \Length{\Roles{\GT}} = \Role[n] \\ \Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role[n]}}{\Proj{\GT}{\Role[n]}} \end{array}}{\Gamma \vdash \PReq{\Chan[a]}{\Role[n]}{\Chan}{\PT} \triangleright \Delta} \hspace{2em}
		\left( \textsf{Acc} \right) \dfrac{\!\!\begin{array}{c} \Typed{\Chan[a]}{\GT} \in \Gamma \quad 0 < \Role < \Length{\Roles{\GT}} \\ \Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role}}{\Proj{\GT}{\Role}} \end{array}}{\Gamma \vdash \PAcc{\Chan[a]}{\Role}{\Chan}{\PT} \triangleright \Delta} \vspace{0.5em}\\
		\left( \textsf{RSend} \right) \dfrac{\Gamma \Vdash \Typed{\Expr[y]}{\Sort} \quad \Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT}}{\Gamma \vdash \PSendR{\Chan}{\Role_1}{\Role_2}{\Expr[y]}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LSendR{\Role_2}{\Sort}{\LT}}} \vspace{0.5em}\\
		\left( \textsf{RGet} \right) \dfrac{\Args \sharp \left( \Gamma, \Delta, \Chan \right) \quad \Gamma \compS \Typed{\Args}{\Sort} \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan[s]}{\Role_1}}{\LT}}{\Gamma \vdash \PGetR{\Chan}{\Role_1}{\Role_2}{\Args}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LGetR{\Role_2}{\Sort}{\LT}}} \vspace{0.5em}\\
		\textcolor{blue}{\left( \textsf{USend} \right) \dfrac{\Gamma \Vdash \Typed{\Expr[y]}{\Sort} \quad \Label \compL \Label' \quad \Typed{\Label'}{\Sort} \in \Gamma \quad \Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT}}{\Gamma \vdash \PSendU{\Chan}{\Role_1}{\Role_2}{\Label}{\Expr[y]}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LSendU{\Role_2}{\Label'}{\Sort}{\LT}}}} \vspace{0.5em}\\
		\textcolor{blue}{\left( \textsf{UGet} \right) \dfrac{\Args \sharp \left( \Gamma, \Delta, \Chan \right) \quad \Gamma \Vdash \Typed{\Expr[v]}{\Sort} \quad \Label \compL \Label' \quad \Typed{\Label'}{\Sort} \in \Gamma \quad \Gamma \compS \Typed{\Args}{\Sort} \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan[s]}{\Role_1}}{\LT}}{\Gamma \vdash \PGetU{\Chan}{\Role_1}{\Role_2}{\Label}{\Expr[v]}{\Args}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LGetU{\Role_2}{\Label'}{\Sort}{\LT}}}} \vspace{0.5em}\\
		\left( \textsf{RSel} \right) \dfrac{j \in \indexSet \quad \Label \compL \Label_j \quad \Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT_j}}{\Gamma \vdash \PSelR{\Chan}{\Role_1}{\Role_2}{\Label}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LSelR{\Role_2}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}}}} \hspace{2em}
		\left( \textsf{Var} \right) \dfrac{}{\Gamma \compS \Typed{\ProcV}{\TypeV} \vdash \ProcV \triangleright \Typed{\AT{\Chan}{\Role}}{\TypeV}} \vspace{0.5em}\\
		\left( \textsf{RBran} \right) \dfrac{\forall j \in \indexSet_2\logdot \exists i \in \indexSet_1\logdot \Label_i \compL \Label_j \wedge \Gamma \vdash \PT_i \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT_j}}{\Gamma \vdash \PBranR{\Chan}{\Role_1}{\Role_2}{\Set{ \Label_i.\PT_i }_{i \in \indexSet_1}} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LBranR{\Role_2}{\Set{ \Label_i.\LT_i }_{i \in \indexSet_2}}}} \vspace{0.5em}\\
		\textcolor{blue}{\left( \textsf{WSel} \right) \dfrac{j \in \indexSet \quad \Label \compL \Label_j \quad \Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role}}{\LT_j}}{\Gamma \vdash \PSelW{\Chan}{\Role}{\Role[R]}{\Label}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role}}{\LSelW{\Role[R]}{\Set{ \Label_i.\LT_i }_{i \in \indexSet}}}}} \hspace{2em}
		\textcolor{blue}{\left( \textsf{Crash} \right) \dfrac{\Unreliable{\Delta}}{\Gamma \vdash \PCrash \triangleright \Delta}} \vspace{0.5em}\\
		\textcolor{blue}{\left( \textsf{WBran} \right) \dfrac{\LabelD \compL \LabelD' \quad \forall j \in \indexSet_2\logdot \exists i \in \indexSet_1\logdot \Label_i \compL \Label_j \wedge \Gamma \vdash \PT_i \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT_j}}{\Gamma \vdash \PBranW{\Chan}{\Role_1}{\Role_2}{\Set{ \Label_i.\PT_i }_{i \in \indexSet_1, \LabelD}} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LBranW{\Role_2}{\Set{ \Label_i.\LT_i }_{i \in \indexSet_2, \LabelD'}}}}} \vspace{0.5em}\\
		\left( \textsf{Deleg} \right) \dfrac{\Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT}}{\Gamma \vdash \PDelA{\Chan}{\Role_1}{\Role_2}{\AT{\Chan'}{\Role}}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LDelA{\Role_2}{\Chan'}{\Role}{\LT'}{\LT}} \compS \Typed{\AT{\Chan'}{\Role}}{\LT'}} \vspace{0.5em}\\
		\left( \textsf{SRecv} \right) \dfrac{\Gamma \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT} \compS \Typed{\AT{\Chan'}{\Role}}{\LT'}}{\Gamma \vdash \PDelB{\Chan}{\Role_1}{\Role_2}{\AT{\Chan'}{\Role}}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LDelB{\Role_2}{\Chan'}{\Role}{\LT'}{\LT}}} \hspace{2em}
		\left( \textsf{End} \right) \dfrac{}{\Gamma \vdash \PEnd \triangleright \emptyset} \vspace{0.5em}\\
		\left( \textsf{If} \right) \dfrac{\Gamma \Vdash \Typed{\Expr}{\bool} \quad \Gamma \vdash \PT \triangleright \Delta \quad \Gamma \vdash \PT' \triangleright \Delta}{\Gamma \vdash \PITE{\Expr}{\PT}{\PT'} \triangleright \Delta} \hspace{1em}
		\left( \textsf{Par} \right) \dfrac{\Gamma \vdash \PT \triangleright \Delta \quad \Gamma \vdash \PT' \triangleright \Delta'}{\Gamma \vdash \PT \mid \PT' \triangleright \Delta \compS \Delta'} \vspace{0.5em}\\
		\left( \textsf{Res1} \right) \dfrac{\Args \sharp \left( \Gamma, \Delta \right) \quad \Gamma \compS \Typed{\Args}{\Sort} \vdash \PT \triangleright \Delta}{\Gamma \vdash \PRes{\Args}{\PT} \triangleright \Delta} \hspace{2em}
		\left( \textsf{Rec} \right) \dfrac{\Gamma \compS \Typed{\ProcV}{\TypeV} \vdash \PT \triangleright \Delta \compS \Typed{\AT{\Chan[s]}{\Role}}{\LT}}{\Gamma \vdash \PRep{\ProcV}{\PT} \triangleright \Delta \compS \Typed{\AT{\Chan[s]}{\Role}}{\LRep{\TypeV}{\LT}}}
	\end{array} \]
	\caption{Typing Rules for Fault-Tolerant Systems.}
	\label{fig:typingRules}
\end{figure}

We write $ \Unreliable{\Delta} $ if $ \Unreliable{\LT} $ for all local types $ \LT $ in $ \Delta $ and if $ \Delta $ does not contain message queues.
With $ \Gamma \Vdash \Typed{\Expr[y]}{\Sort} $ we check that $ \Expr[y] $ is an expression of the sort $ \Sort $ if all names $ \Args $ in $ \Expr[y] $ are replaced by arbitrary values of sort $ \Sort_{\Args} $ for $ \Typed{\Args}{\Sort_{\Args}} \in \Gamma $.

A process $ \PT $ is \emph{well-typed} \wrt $ \Gamma $ and $ \Delta $ if $ \Gamma \vdash \PT \triangleright \Delta $ can be derived from the rules in the Fig.~\ref{fig:typingRules} and \ref{fig:runtimeTypingRules}.
We concentrate on the interaction cases, where we observe that all new cases are quite similar to their \strongR counterparts.
%The \unrel and \weakR cases additionally check the sorts assigned to labels in $ \Gamma $, the sorts of default values, and the relation between default labels of processes and their types.

Rule~(\textsf{RSend}) checks \strongR senders, \ie requires a matching \strongR sending in the local type of the actor and compares the actor with this type.
With $ \Gamma \Vdash \Typed{\Expr[y]}{\Sort} $ we check that $ \Expr[y] $ is an expression of the sort $ \Sort $ if all names $ \Args $ in $ \Expr[y] $ are replaced by arbitrary values of sort $ \Sort_{\Args} $ for $ \Typed{\Args}{\Sort_{\Args}} \in \Gamma $.
Then the continuation of the process is checked against the continuation of the type.
The \unrel case is very similar, but additionally checks that the label is assigned to the sort of the expression in $ \Gamma $.
Rule~(\textsf{RGet}) type \strongR receivers, where again the prefix is checked against a corresponding type prefix and the assumption $ \Typed{\Args}{\Sort} $ is added to the type check of the continuation.
Again the \unrel case is very similar, but apart from the label also checks the sort of the default value.

Rule~(\textsf{RSel}) checks the \strongR selection prefix, that the selected label matches one of the specified labels, and that the process continuation is well-typed \wrt the type continuation following the selected label.
The only difference in the \weakR case is the set of roles for the receivers.
For \strongR branching we have to check the prefix and that for each branch in the type there is a matching branch in the process that is well-typed \wrt the respective branch in the type.
For the \weakR case we have to additionally check that the default labels of the process and the type coincide.

Rule~(\textsf{Crash}) for crashed processes checks that $ \Unreliable{\Delta} $.

Figure~\ref{fig:runtimeTypingRules} presents the runtime typing rules, \ie the typing rules for processes that may result from steps of a system that implements a global type.
Since it covers only operators that are not part of initial systems, a type checking tool might ignore them.
We need these rules however for the proofs of progress and subject reduction.
Under the assumption that initial systems cannot contain crashed processes, Rule~(\textsf{Crash}) may be moved to the set of runtime typing rules.

\begin{figure}[tp]
	\[ \begin{array}{c}
		\left( \textsf{Res2} \right) \dfrac{\!\!\begin{array}{c} \Set{ \Typed{\AT{\Chan}{\Role}}{\Proj{\GT}{\Role}} \mid \Role \in \Roles{\GT} } \compS \Set{ \MQ{\Chan}{\Role}{\Role'}{\emptyList} \mid \Role, \Role' \in \Roles{\GT'} \wedge \Role \neq \Role' } \stackrel{\Chan}{\Mapsto} \Delta'\\ \Chan \sharp \left(\Gamma, \Delta \right) \quad \Typed{\Chan[a]}{G} \in \Gamma \quad \Gamma \vdash \PT \triangleright \Delta \compS \Delta' \end{array}\!\!}{\Gamma \vdash \PRes{\Chan[s]}{\PT} \triangleright \Delta} \vspace{0.5em}\\
		\left( \textsf{MQComR} \right) \dfrac{\Gamma \Vdash \Typed{\Expr[v]}{\Sort} \quad \Gamma \vdash \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} \triangleright \MQ{\Chan}{\Role_1}{\Role_2}{\MT}}{\Gamma \vdash \MQ{\Chan}{\Role_1}{\Role_2}{\MessR{\Expr[v]}\#\Queue} \triangleright \MQ{\Chan}{\Role_1}{\Role_2}{\MessR{\Sort}\#\MT}} \vspace{0.5em}\\
		\textcolor{blue}{\left( \textsf{MQComU} \right) \dfrac{\Gamma \Vdash \Typed{\Expr[v]}{\Sort} \quad \Label \compL \Label' \quad \Typed{\Label'}{\Sort} \in \Gamma \quad \Gamma \vdash \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} \triangleright \MQ{\Chan}{\Role_1}{\Role_2}{\MT}}{\Gamma \vdash \MQ{\Chan}{\Role_1}{\Role_2}{\MessU{\Label}{\Expr[v]}\#\Queue} \triangleright \MQ{\Chan}{\Role_1}{\Role_2}{\MessU{\Label'}{\Sort}\#\MT}}} \vspace{0.5em}\\
		\left( \textsf{MQBranR} \right) \dfrac{\Label \compL \Label' \quad \Gamma \vdash \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} \triangleright \MQ{\Chan}{\Role_1}{\Role_2}{\MT}}{\Gamma \vdash \MQ{\Chan}{\Role_1}{\Role_2}{\MessBR{\Label}\#\Queue} \triangleright \MQ{\Chan}{\Role_1}{\Role_2}{\MessBR{\Label'}\#\MT}} \vspace{0.5em}\\
		\textcolor{blue}{\left( \textsf{MQBranW} \right) \dfrac{\Label \compL \Label' \quad \Gamma \vdash \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} \triangleright \MQ{\Chan}{\Role_1}{\Role_2}{\MT}}{\Gamma \vdash \MQ{\Chan}{\Role_1}{\Role_2}{\MessBW{\Label}\#\Queue} \triangleright \MQ{\Chan}{\Role_1}{\Role_2}{\MessBW{\Label'}\#\MT}}} \vspace{0.5em}\\
		\left( \textsf{MQDeleg} \right) \dfrac{\Gamma \vdash \MQ{\Chan}{\Role_1}{\Role_2}{\Queue} \triangleright \MQ{\Chan}{\Role_1}{\Role_2}{\MT}}{\Gamma \vdash \MQ{\Chan}{\Role_1}{\Role_2}{\AT{\Chan'}{\Role}\#\Queue} \triangleright \MQ{\Chan}{\Role_1}{\Role_2}{\AT{\Chan'}{\Role}\#\MT}} \hspace{1em}
		\left( \textsf{MQNil} \right) \dfrac{}{\Gamma \vdash \MQ{\Chan}{\Role_1}{\Role_2}{\emptyList} \triangleright \MQ{\Chan}{\Role_1}{\Role_2}{\emptyList}}
	\end{array} \]
	\caption{Runtime Typing Rules for Fault-Tolerant Systems.}
	\label{fig:runtimeTypingRules}
\end{figure}

We have to prove that our extended type system satisfies the standard properties of \MPST, \ie subject reduction and progress.
\emph{Subject reduction} tells us that derivatives of well-typed systems are again well-typed.
This is fundamental, since it ensures that our formalism can be used to analyse processes by static type checking.
We extend subject reduction such that it provides some information on how the session environment evolves alongside reductions of the system.
Therefore we introduce a reduction relation $ \stackrel{\Chan}{\mapsto} $ on session environments, that emulates the reduction steps of processes.
As an example consider the rule
$ \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LSendR{\Role_2}{\Sort}{\LT}} \compS \MQ{\Chan}{\Role_1}{\Role_2}{\MT} \stackrel{\Chan}{\mapsto} \Delta \compS \Typed{\AT{\Chan}{\Role_1}}{\LT} \compS \MQ{\Chan}{\Role_1}{\Role_2}{\MT\#\MessR{\Sort}} $
that emulates the transfer of a value in (\textsf{RSend}).
Let $ \stackrel{\Chan}{\Mapsto} $ denote the reflexive and transitive closure of $ \stackrel{\Chan}{\mapsto} $.

\emph{Coherence} intuitively describes that a session environment captures all local endpoints of a collection of global types.
Since we capture all relevant global types in the global environment, we define
coherence on pairs of global and session environments.

\begin{definition}[Coherence]
	\label{def:coherence}
	The type environments $ \Gamma, \Delta $ are \emph{coherent} if, for all session channels $ \Chan $ in $ \Delta $, there exists a global type $ G $ in $ \Gamma $ such that the restriction of $ \Delta $ on assignments with $ \Chan $ is the set $ \Delta' $ such that $ \Set{ \Typed{\AT{\Chan}{\Role}}{\Proj{\GT}{\Role}} \mid \Role \in \Roles{\GT} } \compS \Set{ \MQ{\Chan}{\Role}{\Role'}{\emptyList} \mid \Role, \Role' \in \Roles{\GT} } \stackrel{\Chan}{\Mapsto} \Delta' $.
\end{definition}

Because of the failure pattern in the reduction semantics in Fig.~\ref{fig:semanticsPartA}, subject reduction and progress do not hold in general.
Instead we have to fix conditions on failure patterns that ensure these properties.
Subjection reduction needs one condition on crashed processes and progress requires that the instantiation of the failure patterns is such that they do not block parts of the system.
In fact, different instantiations of these failure patterns may allow for progress. We leave it to further work to determine what kind of conditions on failure patterns or requirements on their interactions are necessary to prove these properties. Here, we consider only one such set of conditions.

\begin{condition}[Failure Pattern]
	\label{cond:all}
	\begin{enumerate}
		\item If $ \fpCrash(\PT) $, then $ \Unreliable{\PT} $. \label{cond:crash}
		\item The failure pattern $ \fpUGet(\Chan, \Role_1, \Role_2, \Label) $ is always valid. \label{cond:ugetValid}
		\item The pattern $ \fpML(\Chan, \Role_1, \Role_2, \Label) $ is valid iff $ \fpUSkip(\Chan, \Role_2, \Role_1, \Label) $ is valid. \label{cond:fpMLifffpUSkip}
		\item If $ \fpCrash(\PT) $ and $ \AT{\Chan}{\Role} \in \Actors{\PT} $ then eventually $ \fpUSkip(\Chan, \Role_2, \Role, \Label) $ and also $ \fpWSkip(\Chan, \Role_2, \Role, \Label) $ for all $ \Role_2, \Label $. \label{cond:fpCrashImpliesSkip}
		\item If $ \fpCrash(\PT) $ and $ \AT{\Chan}{\Role} \in \Actors{\PT} $ then eventually $ \fpML(\Chan, \Role_1, \Role, \Label) $ for all $ \Role_1, \Label $. \label{cond:fpCrashImpliesML}
		\item If $ \fpWSkip(\Chan, \Role_1, \Role_2) $ then $ \AT{\Chan}{\Role_2} $ is crashed, \ie the system does no longer contain an actor $ \AT{\Chan}{\Role_2} $ and the message queue $ \MQS{\Chan}{\Role_2}{\Role_1} $ is empty. \label{cond:fpWskip}
	\end{enumerate}
\end{condition}

The crash of a process should not block \strongR actions, \ie only processes with $ \Unreliable{\PT} $ can crash (Condition~\ref{cond:all}.\ref{cond:crash}).
Condition~\ref{cond:all}.\ref{cond:ugetValid} requires that no process can refuse to consume a message on its queue.
This condition prevents deadlocks that may arise from refusing a message $ m $ that is never dropped from the message queue.
Condition~\ref{cond:all}.\ref{cond:fpMLifffpUSkip} requires that if a message can be dropped from a message queue then the corresponding receiver has to be able to skip this message and vice versa.
Similarly, processes that wait for messages from a crashed process have to be able to skip (Condition~\ref{cond:all}.\ref{cond:fpCrashImpliesSkip}) and all messages of a queue towards a crashed receiver can be dropped (Condition~\ref{cond:all}.\ref{cond:fpCrashImpliesML}).
Finally, \weakR branching requests should not be lost.
To ensure that the receiver of such a branching request can proceed if the sender is crashed but is not allowed to skip the reception of the branching request before the sender crashed, we require that $ \fpWSkip(\Chan, \Role_1, \Role_2) $ is false as long as $ \AT{\Chan}{\Role_2} $ is alive or messages on the respective queue are still in transit (Condition~\ref{cond:all}.\ref{cond:fpWskip}).

The combination of these 6 conditions might appear quite restrictive on a first glance.
For example the combination of the Conditions~\ref{cond:all}.\ref{cond:fpCrashImpliesSkip} and \ref{cond:all}.\ref{cond:fpWskip} ensures the correct behaviour of \weakR branching such that branching messages can be skipped if and only if the respective sender has crashed.
An implementation of such a \weakR interaction in an asynchronous system that is subject to message losses and process crashes, might require something like a perfect failure detector or actually solving consensus\footnote{Note that the example we present in Section~\ref{sec:example} is a consensus algorithm. So, if the Conditions~\ref{cond:all} require a solution of consensus, an example on top of that solving consensus would be pointless.}.
Here it is important to remember that these conditions are minimal assumptions on the system requirements and that system requirements are just abstractions.
Parts of them may be realised by actual software-code (which then allows to check them), whereas other parts of the system requirements may not be realised at all but rather observed (which then does not allow to very them).
Weakly reliable branching is a good example of this case.
The easiest way to obtain a \weakR interaction, is by using a handshake communication and time-outs.
If the sender time-outs while waiting for an acknowledgement, it resends the message.
If the sender does not hear from its receiver for a long enough period of time, it assumes that the receiver has crashed and proceeds.
With carefully chosen time-frames for the time-outs, this approach is a compromise between correctness and efficiency.
In a theoretical sense, it is clearly not correct.
There is no time-frame such that the sender can be really sure that the receiver has crashed.
From a practical point of view, this is not so problematic, since in many systems failures are very unlikely.
If failures that are so severe that they are not captured by the time-outs are extremely unlikely, then it is often much more efficient to just accept that the algorithm is not correct in these cases.
Trying to obtain an algorithm that is always correct might be impossible or at least usually results into very inefficient algorithms.
Moreover, verifying this requires to also verify the underlying communication infrastructure and the way in that failures may occur, which is impossible or at least impracticable.
Because of that, it is an established method to verify the correctness of algorithms \wrt given system requirements (\eg in \cite{ChandraToueg96,Lamport01,TanenbaumSteen17}), even if these system requirements are not verified and often do not hold in all (but only nearly all) cases.

With Conditions~\ref{cond:all}, we can now analyse our fault-tolerant type system.

\begin{theorem}[Subject Reduction]
	\label{thm:subjectReduction}
	If $ \Gamma \vdash \PT \triangleright \Delta $, $ \Gamma, \Delta $ are coherent, and $ \PT \step \PT' $, then there are some $ \Delta', \Chan $ such that $ \Gamma \vdash \PT' \triangleright \Delta' $, $ \Gamma, \Delta' $ are coherent, and $ \Delta \stackrel{\Chan}{\Mapsto} \Delta' $.
\end{theorem}

The proof is by induction on the derivation of $ \PT \step \PT' $.
In every case, we use the information about the structure of the processes to generate partial proof trees for the respective typing judgement.
Additionally, we use Condition~\ref{cond:all}.\ref{cond:crash} to ensure that the type environment of a crashed process cannot contain the types of reliable communication prefixes.

\emph{Progress} states that no part of a well-typed and coherent system can block other parts, that eventually all matching communication partners of \strongR and \weakR communications (that are not crashed) are unguarded, and that there are no communication mismatches.
Subject reduction and progress together then imply \emph{session fidelity}, \ie that processes behave as specified in their global types.

To ensure that the interleaving of sessions and session delegation cannot introduce deadlocks, we assume an interaction type system as introduced in \cite{BettiniEtal08,hondaYoshidaCarbone16}.
For this type system it does not matter whether the considered actions are \strongR, \weakR, or \unrel.
More precisely, we can adapt the interaction type system of \cite{BettiniEtal08} in a straightforward way to the above session calculus, where \unrel communication and \weakR branching is treated in exactly the same way as \strongR communication/branching.
We say that \emph{$ \PT $ is free of cyclic dependencies between sessions} if this interaction type system does not detect any cyclic dependencies.
In this sense fault-tolerance is more flexible than explicit failure handling as \eg \cite{VieringEtal18} has to exclude interleaved sessions.

In the literature there are different formulations of progress.
We are interested in a rather strict definition of progress that ensures that well-typed systems cannot block.
Therefore, we need an additional assumption on session requests and acceptances.
Coherence ensures the existence of communication partners within sessions only.
If we want to avoid blocking, we need to be sure, that no participant of a session is missing during its initialisation.
Note that without action prefixes all participants either terminated or crashed.

\begin{theorem}[Progress/Session Fidelity]
	\label{thm:progress}
	Let $ \Gamma \vdash \PT \triangleright \Delta $, $ \Gamma, \Delta $ be coherent, and let $ \PT $ be free of cyclic dependencies between sessions.
	Assume that in the derivation of $ \Gamma \vdash \PT \triangleright \Delta $, whenever $ \PReq{\Chan[a]}{\Role[n]}{\Chan}{\PT[Q]} $ or $ \PAcc{\Chan[a]}{\Role}{\Chan}{\PT[Q]} $ with $ \Typed{\Chan[a]}{\GT} $, then there are $ \PReq{\Chan[a]}{\Role[n]}{\Chan}{\PT[Q]_n} $ or $ \PAcc{\Chan[a]}{\Role_i}{\Chan}{\PT[Q]_i} $ for all $ 1 \leq \Role_i < \Role[n] $.
	\begin{enumerate}
		\item Then either $ \PT $ does not contain any action prefixes or $ \PT \step \PT' $.
		\item If $ \PT $ does not contain recursion, then there exists $ P' $ such that $ \PT \steps \PT' $ and $ \PT' $ does not contain any action prefixes.
	\end{enumerate}
\end{theorem}

