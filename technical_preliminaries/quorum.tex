\section{Quorum}
\citeauthor{Lamport06} provided a definition of quorums in \cite{Lamport06}.
The definition relies on other concepts, which were also defined in \cite{Lamport06}.
The following includes the relevant assumptions and definitions from that paper.

\begin{assumption}[Agent]
    The set of acceptors is finite, and there are at least two proposers and two learners.
\end{assumption}

\begin{assumption}[Value]
    There are at least two proposable values.
\end{assumption}

We let $n$ be the number of acceptors, and we define an \emph{agent} to be a proposer, a learner, or an acceptor.

% Scenarios and Algorithms

We begin by defining what an event is.
We assume that the events performed by a single agent are totally ordered.
(Events performed concurrently by a single agent can be ordered arbitrarily.)
So an event $e$ specifies an agent \agent{e} and a positive integer $\num{e}$, indicating that $e$ is the $\num{e}^{\text{th}}$ event performed by \agent{e}.
An event can be performed either spontaneously or upon receipt of a message.
For a message-receiving event $e$, we let \rcvd{e} be a triple $\langle m, a, i \rangle$, indicating that the event was triggered by the receipt of a message $m$ sent by the $i^{\text{th}}$ event of agent $a$.
For simplicity, we assume that each event $e$ sends exactly one message \msg{e}, which can be received by any agent (including itself).
The sending of a possibly empty set $\mathcal{M}$ of messages can be modeled by letting \msg{e} equal $\mathcal{M}$ and having an event that receives $\mathcal{M}$ ignore any of its elements not meant for the receiver.
Since we are concerned with when learning occurs and not with termination, we don't care if an agent ever stops sending messages.

For any set $S$ of events, we define the precedence relation \preceqS on $S$ to be the transitive closure of the relation $\to$ such that $d \to e$ iff either (i) $\agent{d} = \agent{e}$ and $\num{d} \leq \num{e}$ or (ii) $e$ is a message-receiving event such that $\rcvd{e} = \langle \msg{d}, \agent{d}, \num{d} \rangle$.
A scenario is then defined as follows.

\begin{asyncdef}[Scenario]
    A \emph{scenario} $S$ is a set of events such that
    \begin{itemize}
        \item For any agent $a$, the set of events in $S$ performed by $a$ consists of $k_a$ events numbered from 1 through $k_a$, for some natural number $k_a$.
        \item For every message-receiving event $e$ in $S$, there exists an event $d$ in $S$ different from $e$ such that $\rcvd{e} = \langle \msg{d}, \agent{d}, \num{d} \rangle$.
        \item \preceqS is a partial order on $S$.
    \end{itemize}
\end{asyncdef}

A \emph{prefix} of a scenario $T$ consists of a set of events in $T$ that precede all other events in $T$.
The precise definition is:

\begin{asyncdef}[Prefix]
    A subset $S$ of a scenario $T$ is a \emph{prefix} of $T$, written $S \sqsubseteq T$, iff for any events $d$ in $T$ and $e$ in $S$, if $d \preceqOf{T} e$ then $d$ is in $S$.
\end{asyncdef}

It is easy to see that any prefix of a scenario is also a scenario.

An \emph{algorithm} is defined to be any non-empty set of scenarios.
Let \Agents{S} be the set of all agents that perform events in the set $S$ of events, and $A\setminus B$ is the subset of the set $A$ consisting of all elements not in the set $B$.

\begin{asyncdef}[Asynchronous Algorithm]
    An \emph{asynchronous algorithm} \Alg is a set of scenarios such that:

    \begin{algorithmdef}
        Every prefix of a scenario in \Alg is in \Alg.
    \end{algorithmdef}
    \begin{algorithmdef}
        If $T$ and $U$ are scenarios of \Alg and $S$ is a prefix of both $T$ and $U$ such that \Agents{T\setminus S} and \Agents{U\setminus S} are disjoint sets, then $T \cup U$ is a scenario of \Alg.
    \end{algorithmdef}
\end{asyncdef}

We now assume that there are proposing and learning events.
A proposing event $e$ is one in which proposer \agent{e} proposes a value \proposed{e}.
A learning event $e$ is one in which learner \agent{e} learns a value \learned{e}.
Nontriviality and consistency are defined by:

\begin{asyncdef}[Nontriviality]
    An algorithm \Alg is \emph{nontrivial} iff, for every scenario $S$ in \Alg and any learning event $e$ in $S$, there is a proposing event $d$ in $S$ with $\proposed{d} = \learned{e}$.
\end{asyncdef}

\begin{asyncdef}[Consistency]
    An algorithm \Alg is \emph{consistent} iff, for every scenario $S$ in \Alg, if $d$ and $e$ are learning events in $S$, then $\learned{d} = \learned{e}$.
\end{asyncdef}

We define a \emph{consensus algorithm} to be an algorithm that is nontrivial and consistent.

% The Lower Bound on Acceptors

A quorum is a set of acceptors that is large enough to choose a value, regardless of what steps of the algorithm have been performed so far.
Here, we define an \emph{accepting set} to be one large enough that it can choose a value starting \emph{ab initio}.
A quorum is therefore an accepting set.

\begin{asyncdef}[Accepting Set]
    A set $Q$ of acceptors is \emph{accepting} for a proposer $p$ in algorithm \Alg iff for every value $v$ and learner $l$, there is a scenario $S$ of \Alg with $\Agents{S} \subseteq \{p, l\} \cup Q$ such that $S$ has an event in which $p$ proposes $v$ and an event in which $l$ learns $v$.
\end{asyncdef}

% Fast Learning

\begin{asyncdef}[Quorum]
    A set $Q$ of acceptors is a \emph{quorum} for an algorithm \Alg iff it is an accepting set in \Alg for every proposer and, for every proposer $p$, learner $l$, and scenario $S$ of \Alg, there exists a scenario $T$ of \Alg such that (i) $S$ is a prefix of $T$, (ii) $\Agents{T\setminus S} \subseteq \{p, l\}\cup Q$, and (iii) $T$ contains a learning event of $l$.
\end{asyncdef}
